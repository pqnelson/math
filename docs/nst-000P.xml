<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3321</fr:anchor><fr:addr
type="user">nst-000P</fr:addr><fr:route>nst-000P.xml</fr:route><fr:title
text="Basic concepts and constructions of naive set theory">Basic concepts and constructions of naive set theory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>910</fr:anchor><fr:addr
type="user">nst-000R</fr:addr><fr:route>nst-000R.xml</fr:route><fr:title
text="Ontology of Mathematics">Ontology of Mathematics</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>What are the basic "things" we work with in Mathematics? It may seem that we have numbers, functions, and quite possibly other objects.</fr:p><fr:p>Broadly speaking, we could describe Mathematics as working with "sets" (unordered collections of stuff) and "objects" (any generic term or object).</fr:p><fr:p>In practice, there are compelling reasons to stipulate that <fr:em>everything</fr:em> in Mathematics consists of sets. This should be understood as saying that sets form the "machine code" of Mathematics. This is explicitly stated in Bourbaki's <fr:link
type="local"
href="bourbaki-1968-theory.xml"
addr="bourbaki-1968-theory"
title="Theory of Sets">Theory of Sets</fr:link>, II §1.1 (bottom of page 65 of English edition):</fr:p>
  <html:blockquote
xmlns:html="http://www.w3.org/1999/xhtml"><fr:p>From a "naive" point of view, many mathematical entities can be formalized as collections or "sets" of objects. We do not seek to formalize this notion, and in the formalistic interpretation of what follows, the word "set" is to be considered as strictly synonymous with "term".</fr:p></html:blockquote>
<fr:p>We will just stipulate that everything in Mathematics may be considered as an instance of some abstract type we call an "object". We extend this with a subtype called a "set". All sets are objects.</fr:p><fr:p>But some Mathematicians want to discuss the collection of all sets. This can't possibly be a set (otherwise we run into Russell's paradox), so we need to either modify our ontology (and work with "classes" instead of "sets", and call a class a "set" when it's a member of a class) or extend our ontology (to include a "class" as a third species of object). We will discuss this when the time comes, but the ontology is mildly flexible.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>912</fr:anchor><fr:addr
type="user">nst-0001</fr:addr><fr:route>nst-0001.xml</fr:route><fr:title
text="Set">Set</fr:title><fr:taxon>Provisional definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We [pretend to] define a [naive] <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Set</html:dfn> to be a well-defined unordered collection of objects.</fr:p><fr:p>If <fr:tex
display="inline"><![CDATA[x]]></fr:tex> is an object and <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a set, then we write <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> if <fr:tex
display="inline"><![CDATA[x]]></fr:tex> is an element (or member) of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>. If <fr:tex
display="inline"><![CDATA[x]]></fr:tex> is not an element of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, then we write <fr:tex
display="inline"><![CDATA[x\notin  X]]></fr:tex>.</fr:p><fr:p>We will also write <fr:tex
display="inline"><![CDATA[X\ni  x]]></fr:tex> as a synonym for <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>. We also write <fr:tex
display="inline"><![CDATA[X\not \ni  x]]></fr:tex>.</fr:p><fr:p>This isn't really a definition, because set theory is given axiomatically. We usually give axioms to specify the behaviour of the binary infixed predicate <fr:tex
display="inline"><![CDATA[\in ]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>914</fr:anchor><fr:addr
type="user">nst-000C</fr:addr><fr:route>nst-000C.xml</fr:route><fr:title
text="Proving well-definedness of terms">Proving well-definedness of terms</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>When we define a new term in Mathematics, we should prove it is well-defined. What this proof requires depends on what we're defining.</fr:p><fr:ul><fr:li>A new constant (possibly parametrized by other objects) <fr:tex
display="inline"><![CDATA[C]]></fr:tex> defined as satisfying some condition <fr:tex
display="inline"><![CDATA[\Phi [C]]]></fr:tex> requires proving (1) its existence (i.e, proving <fr:tex
display="inline"><![CDATA[\exists  x\ldotp \Phi [x]]]></fr:tex>), and (2) its uniqueness (i.e., <fr:tex
display="inline"><![CDATA[\forall  x,y\ldotp \Phi [x]\land \Phi [y]\implies  x=y]]></fr:tex>).</fr:li>
<fr:li>A new constant <fr:tex
display="inline"><![CDATA[C]]></fr:tex> which is defined as abbreviating some complicated expression is usually well-defined, sometimes we need to prove it has the "correct type".</fr:li>
<fr:li>A new species of thing (like a vector space or a <fr:link
type="local"
href="field-0001.xml"
addr="field-0001"
title="Field">Field</fr:link>) should require proving the existence of at least one such gadget.</fr:li>
<fr:li>All other types of definitions (predicates, adjectives, etc.) are well-defined.</fr:li></fr:ul><fr:p>One of the reasons why the <fr:link
type="local"
href="nst-0001.xml"
addr="nst-0001"
title="Set">"definition" of a set</fr:link> is not really a definition is because we should prove the existence of a set, but that's not possible. It's also why Mathematicians invented <fr:em>axiomatic</fr:em> set theory: presumably there are mathematical objects called "sets" which already exist, and we're trying to specify their behaviour (or some reasonable approximation) using axioms.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>916</fr:anchor><fr:addr
type="user">nst-000U</fr:addr><fr:route>nst-000U.xml</fr:route><fr:title
text="Examples of common sets">Examples of common sets</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We have some very common sets encountered in Mathematics, so we have special notation for them:</fr:p><fr:ul><fr:li><fr:tex
display="inline"><![CDATA[\mathbb {N}_{0}=\{0,1,2,3,…\}]]></fr:tex> the set of all non-negative integers</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[\mathbb {N}=\{1,2,3,4,…\}]]></fr:tex> the set of all positive integers</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[\mathbb {Z}=\{…,-3,-2,-1,0,1,2,3,…\}]]></fr:tex> the set of all integers</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[\mathbb {Q}=\{\frac {m}{n}\mid  m\in \mathbb {Z},n\in \mathbb {N}]]></fr:tex> the set of all rational numbers</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[\mathbb {R}]]></fr:tex> the set of real numbers</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[\mathbb {C}=\{x+\mathrm {i} y\mid  x,y\in \mathbb {R}\}]]></fr:tex> the set of complex numbers</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>918</fr:anchor><fr:addr
type="user">nst-0002</fr:addr><fr:route>nst-0002.xml</fr:route><fr:title
text="Finite sets">Finite sets</fr:title><fr:taxon>Notation</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If we have a set consisting of finitely many elements, we write it out as a comma-separated list delimited by <fr:tex
display="inline"><![CDATA[\{…\}]]></fr:tex>.</fr:p><fr:p>For example, the set of prime numbers less than 10 is <fr:tex
display="inline"><![CDATA[\{2,3,5,7\}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>920</fr:anchor><fr:addr
type="user">nst-0003</fr:addr><fr:route>nst-0003.xml</fr:route><fr:title
text="Empty set">Empty set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We say <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Empty</html:dfn> if there is no object <fr:tex
display="inline"><![CDATA[x]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>922</fr:anchor><fr:addr
type="user">nst-0004</fr:addr><fr:route>nst-0004.xml</fr:route><fr:title
text="Set equality">Set equality</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the predicate <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Set Equality</html:dfn> (or just <fr:em>equality</fr:em>) of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, denoted <fr:tex
display="inline"><![CDATA[X=Y]]></fr:tex>, to mean they have the same elements; i.e., for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> if and only if <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>.</fr:p><fr:p>When <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are not equal, we write <fr:tex
display="inline"><![CDATA[X\neq  Y]]></fr:tex>.</fr:p><fr:p>(This is technically an axiom of ZFC called the "axiom of extensionality".)</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>924</fr:anchor><fr:addr
type="user">nst-0005</fr:addr><fr:route>nst-0005.xml</fr:route><fr:title
text="The empty set">The empty set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We define <fr:em>the</fr:em> empty set to be the constant denoted <fr:tex
display="inline"><![CDATA[\emptyset ]]></fr:tex> (or sometimes <fr:tex
display="inline"><![CDATA[\{\}]]></fr:tex>).</fr:p><fr:p>We need to prove this is well-defined. For constants, this means proving it exists and is unique.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>926</fr:anchor><fr:addr
type="machine">#265</fr:addr><fr:route>unstable-265.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Existence:</fr:strong> Take the empty list as a set <fr:tex
display="inline"><![CDATA[\{\}]]></fr:tex>. This is clearly empty.</fr:p>

<fr:p><fr:strong>Uniqueness:</fr:strong> Suppose we have <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> both be empty sets. We want to prove <fr:tex
display="inline"><![CDATA[X=Y]]></fr:tex>. Then for any object <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, we want to prove (1) if <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> then <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>, and (2) if <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex> then <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>.</fr:p>

<fr:p>(1) Assume <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>. But <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is <fr:link
type="local"
href="nst-0004.xml"
addr="nst-0004"
title="Set equality">empty</fr:link>, so <fr:tex
display="inline"><![CDATA[X]]></fr:tex> cannot have any members. Then we have a contradiction. Hence we can conclude whatever we want, in particular <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>.</fr:p>

<fr:p>(2) The argument is the same but switching <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>928</fr:anchor><fr:addr
type="user">nst-0006</fr:addr><fr:route>nst-0006.xml</fr:route><fr:title
text="Subset">Subset</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the predicate <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex> to mean: for any object <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> then <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>. In other words, all elements of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> are also elements of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>. (This is very different than <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is an element of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>!)</fr:p><fr:p>We write <fr:tex
display="inline"><![CDATA[Y\supseteq  X]]></fr:tex> as a synonym for <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>.</fr:p><fr:p>We also write <fr:tex
display="inline"><![CDATA[X\nsubseteq  Y]]></fr:tex> as the antonym for <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[Y\nsupseteq  X]]></fr:tex> for the antonym of <fr:tex
display="inline"><![CDATA[Y\supseteq  X]]></fr:tex>.</fr:p><fr:p>Observe that <fr:tex
display="inline"><![CDATA[X\subseteq  X]]></fr:tex> for any set <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>930</fr:anchor><fr:addr
type="user">nst-0007</fr:addr><fr:route>nst-0007.xml</fr:route><fr:title
text="Proper subset">Proper subset</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the predicate <fr:tex
display="inline"><![CDATA[X\subset  Y]]></fr:tex> to mean <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[X\neq  Y]]></fr:tex>.</fr:p><fr:p>We also have the synonym <fr:tex
display="inline"><![CDATA[Y\supset  X]]></fr:tex> for <fr:tex
display="inline"><![CDATA[X\subset  Y]]></fr:tex>.</fr:p><fr:p>The choice of notation varies wildly. Some authors do not even distinguish proper subsets from "improper" subsets. Worse, some use <fr:tex
display="inline"><![CDATA[\subset ]]></fr:tex> for improper subsets. We have chosen to use notation analogous to <fr:tex
display="inline"><![CDATA[\leq ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\lt ]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>932</fr:anchor><fr:addr
type="user">nst-0008</fr:addr><fr:route>nst-0008.xml</fr:route><fr:title
text="Proving two sets are equal">Proving two sets are equal</fr:title><fr:taxon>Strategy</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Generically, when we want to prove <fr:link
type="local"
href="nst-0004.xml"
addr="nst-0004"
title="Set equality">Set equality</fr:link> like proving <fr:tex
display="inline"><![CDATA[X=Y]]></fr:tex>, we can use the <fr:link
type="local"
href="nst-0006.xml"
addr="nst-0006"
title="Subset">Subset</fr:link> predicate to prove two claims: (1) <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>, (2) <fr:tex
display="inline"><![CDATA[Y\subseteq  X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>934</fr:anchor><fr:addr
type="user">nst-0009</fr:addr><fr:route>nst-0009.xml</fr:route><fr:title
text="Set builder notation">Set builder notation</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.2</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>There are times when the notation for <fr:link
type="local"
href="nst-0002.xml"
addr="nst-0002"
title="Finite sets">Finite sets</fr:link> is clunky or impractical (e.g., write out the first <fr:tex
display="inline"><![CDATA[10^{120}]]></fr:tex> prime numbers). We have another notation for describing a set: if <fr:tex
display="inline"><![CDATA[P[x]]]></fr:tex> is a unary predicate and <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a set, then we write
<fr:tex
display="block"><![CDATA[\{x\in  X\mid  P[x]\}]]></fr:tex>
which describes "The set of <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[P[x]]]></fr:tex> holds". The vertical bar ("|") is read "such that". The allowable predicates <fr:tex
display="inline"><![CDATA[P[-]]]></fr:tex> must form a valid <fr:link
type="local"
href="nst-000A.xml"
addr="nst-000A"
title="Sentences in set theory">sentence</fr:link>. (This form of set builder notation is called "the axiom scheme of specification" in ZFC set theory.)</fr:p><fr:p>The other form of set builder notation which appears frequently: if <fr:tex
display="inline"><![CDATA[F(-)]]></fr:tex> is some construction, and <fr:tex
display="inline"><![CDATA[P[-]]]></fr:tex> is a unary predicate, and <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a set, then
<fr:tex
display="block"><![CDATA[\{F(x)\mid  x\in  X,P[x]\}]]></fr:tex>
describes the set obtained by applying <fr:tex
display="inline"><![CDATA[F]]></fr:tex> to each element of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> which satisfies the predicate <fr:tex
display="inline"><![CDATA[P]]></fr:tex>.</fr:p><fr:p>The Working Mathematician usually "suppresses" (omits) the <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> clause when it is understood.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>936</fr:anchor><fr:addr
type="user">nst-000A</fr:addr><fr:route>nst-000A.xml</fr:route><fr:title
text="Sentences in set theory">Sentences in set theory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.2</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>The allowed sentences or predicates appearing in set builder notation may be described recursively.</fr:p><fr:p>We can describe what possible formulas appear using the following:</fr:p><fr:ul><fr:li><fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[X=Y]]></fr:tex> are the atomic formulas</fr:li>
<fr:li>"not &lt;formula&gt;"</fr:li>
<fr:li>"&lt;formula&gt; and &lt;formula&gt;" or just a comma-separated list of formulas, all of which are expected to hold</fr:li>
<fr:li>"&lt;formula&gt; or &lt;formula&gt;" for the disjunction of formulas (in the sense of "either &lt;formula&gt; or &lt;formula&gt; or both")</fr:li>
<fr:li>"if &lt;formula&gt; then &lt;formula&gt;" (or "&lt;formula&gt; implies &lt;formula&gt;")</fr:li>
<fr:li>"&lt;formula&gt; iff &lt;formula&gt;"</fr:li>
<fr:li>"for all …"</fr:li>
<fr:li>"for some …" (or "exists …")</fr:li></fr:ul><fr:p>… as well as using any predicates we've defined (like the <fr:link
type="local"
href="nst-0006.xml"
addr="nst-0006"
title="Subset">Subset</fr:link> predicate).</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>938</fr:anchor><fr:addr
type="user">nst-001N</fr:addr><fr:route>nst-001N.xml</fr:route><fr:title
text="Russell's paradox">Russell's paradox</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose we try defining the set
<fr:tex
display="block"><![CDATA[R=\{S\hbox { is a set}\mid  S\notin  S\}.]]></fr:tex>
Then we obtain a contradiction if such a set exists. (The solution is to restrict what set-builder notation.)</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>652</fr:anchor><fr:addr
type="machine">#261</fr:addr><fr:route>unstable-261.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Well, assume <fr:tex
display="inline"><![CDATA[R]]></fr:tex> exists. We will prove we obtain a contradiction. Our proof is by cases: either <fr:tex
display="inline"><![CDATA[R\in  R]]></fr:tex> or <fr:tex
display="inline"><![CDATA[R\notin  R]]></fr:tex>.</fr:p>
<fr:p><fr:strong>Case 1:</fr:strong> Assume <fr:tex
display="inline"><![CDATA[R\in  R]]></fr:tex>. Then this means <fr:tex
display="inline"><![CDATA[R\notin  R]]></fr:tex>. But we have both <fr:tex
display="inline"><![CDATA[R\in  R]]></fr:tex> and <fr:tex
display="inline"><![CDATA[R\notin  R]]></fr:tex> which is a contradiction.</fr:p>
<fr:p><fr:strong>Case 2:</fr:strong> Assume <fr:tex
display="inline"><![CDATA[R\notin  R]]></fr:tex>. But this is the defining property for members of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>. This implies <fr:tex
display="inline"><![CDATA[R\in  R]]></fr:tex>. Again, we have both <fr:tex
display="inline"><![CDATA[R\in  R]]></fr:tex> and <fr:tex
display="inline"><![CDATA[R\notin  R]]></fr:tex> which is a contradiction.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>940</fr:anchor><fr:addr
type="user">nst-001O</fr:addr><fr:route>nst-001O.xml</fr:route><fr:title
text="There is no set of all sets">There is no set of all sets</fr:title><fr:taxon>Corollary</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An immediate consequence of <fr:link
type="local"
href="nst-001N.xml"
addr="nst-001N"
title="Russell's paradox">Russell's paradox</fr:link> is that there is no set of all sets. If there were a set <fr:tex
display="inline"><![CDATA[V]]></fr:tex> of all sets, then <fr:tex
display="inline"><![CDATA[V\in  V]]></fr:tex> which leads to problems.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>942</fr:anchor><fr:addr
type="user">nst-001P</fr:addr><fr:route>nst-001P.xml</fr:route><fr:title
text="Classes">Classes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We will often informally refer to a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">(Proper) Class</html:dfn> as an unordered collection which is "too big" to be a set.</fr:p><fr:p>For example, the von Neumann universe <fr:tex
display="inline"><![CDATA[\mathbf {V}]]></fr:tex> is the proper class of all sets.</fr:p><fr:p>In practice, we seldom need to work with proper classes directly. The Working Mathematician needs only sets (until we get to Category Theory, but we'll revisit this as needed).</fr:p><fr:p>The <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Axiom of limitation of size</html:dfn> asserts a collection <fr:tex
display="inline"><![CDATA[C]]></fr:tex> is a proper class if and only if there exists a surjective function from <fr:tex
display="inline"><![CDATA[C]]></fr:tex> to the von Neumann universe <fr:tex
display="inline"><![CDATA[\mathbf {V}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>944</fr:anchor><fr:addr
type="user">nst-000B</fr:addr><fr:route>nst-000B.xml</fr:route><fr:title
text="Union of a family of sets">Union of a family of sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/tarski.html#K3">tarski:def 4</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[F]]></fr:tex> be a family of sets (i.e., set whose elements are sets). We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Union</html:dfn> of <fr:tex
display="inline"><![CDATA[F]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[\bigcup  F]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in \bigcup  F]]></fr:tex> iff there is some set <fr:tex
display="inline"><![CDATA[X\in  F]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>.</fr:p><fr:p>This defines a new constant and we should set about to <fr:link
type="local"
href="nst-000C.xml"
addr="nst-000C"
title="Proving well-definedness of terms">proving it is well-defined</fr:link>, but proving its existence is impossible because it is just stipulated to exist ("axiom of union").</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>946</fr:anchor><fr:addr
type="user">nst-000D</fr:addr><fr:route>nst-000D.xml</fr:route><fr:title
text="Union of two sets">Union of two sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_0.html#K2">xboole_0:def 3</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Union</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[X\cup  Y]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  X\cup  Y]]></fr:tex> iff either <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> or <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>.</fr:p><fr:p>We see that this is commutative <fr:tex
display="inline"><![CDATA[X\cup  Y=Y\cup  X]]></fr:tex> and idempotent <fr:tex
display="inline"><![CDATA[X\cup  X=X]]></fr:tex>.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>948</fr:anchor><fr:addr
type="machine">#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Existence:</fr:strong> take <fr:tex
display="inline"><![CDATA[X\cup  Y=\bigcup \{X,Y\}]]></fr:tex>. We need to prove <fr:tex
display="inline"><![CDATA[x\in  X\cup  Y\implies  x\in \bigcup \{X,Y\}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x\in \bigcup \{X,Y\}\implies  x\in  X\cup  Y]]></fr:tex>, but these follow immediately.</fr:p>

<fr:p><fr:strong>Uniqueness:</fr:strong> Suppose <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is such that for all <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  A]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> or <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is such that for all <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  B]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> or <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>. We will prove for all <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  A]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[x\in  B]]></fr:tex>: let <fr:tex
display="inline"><![CDATA[x]]></fr:tex> be an arbitrary object. Then
<fr:tex
display="block"><![CDATA[x\in  A\iff  x\in  A\hbox { or }x\in  A\iff  x\in  B]]></fr:tex>
which implies <fr:tex
display="inline"><![CDATA[x\in  A\iff  x\in  B]]></fr:tex>. Hence <fr:tex
display="inline"><![CDATA[A=B]]></fr:tex> by <fr:link
type="local"
href="nst-0004.xml"
addr="nst-0004"
title="Set equality">Set equality</fr:link>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>950</fr:anchor><fr:addr
type="user">nst-000E</fr:addr><fr:route>nst-000E.xml</fr:route><fr:title
text="Basic properties of union of two sets">Basic properties of union of two sets</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/boole.html#T1">boole:th1</fr:link></fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T4">xboole_1:th4</fr:link></fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T12">xboole_1:th12</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, <fr:tex
display="inline"><![CDATA[B]]></fr:tex>, <fr:tex
display="inline"><![CDATA[C]]></fr:tex> be arbitrary sets. Then the following all hold:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[A\cup \emptyset =A]]></fr:tex></fr:li>
<fr:li>Associativity: <fr:tex
display="inline"><![CDATA[A\cup (B\cup  C)=(A\cup  B)\cup  C]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[A\subseteq  B]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[A\cup  B=B]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>952</fr:anchor><fr:addr
type="user">nst-000F</fr:addr><fr:route>nst-000F.xml</fr:route><fr:title
text="Intersection of two sets">Intersection of two sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_0.html#K3">xboole_0:def 4</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define their <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Intersection</html:dfn> to be the set denoted <fr:tex
display="inline"><![CDATA[X\cap  Y]]></fr:tex> such that: for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  X\cap  Y]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>.</fr:p><fr:p>We see this is commutative <fr:tex
display="inline"><![CDATA[X\cap  Y=Y\cap  X]]></fr:tex> and idempotent <fr:tex
display="inline"><![CDATA[X\cap  X=X]]></fr:tex>.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>954</fr:anchor><fr:addr
type="machine">#263</fr:addr><fr:route>unstable-263.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Existence:</fr:strong> We see this exists using <fr:link
type="local"
href="nst-0009.xml"
addr="nst-0009"
title="Set builder notation">set-builder notation</fr:link>  <fr:tex
display="inline"><![CDATA[\{x\in  X\mid  x\in  Y\}]]></fr:tex>.</fr:p>
<fr:p><fr:strong>Uniqueness:</fr:strong> let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[B]]></fr:tex> be two possible candidates for the definition. We see <fr:tex
display="inline"><![CDATA[x\in  A\iff  x\in  X\hbox { and }x\in  Y\iff  x\in  B]]></fr:tex>, which implies <fr:tex
display="inline"><![CDATA[A=B]]></fr:tex> by <fr:link
type="local"
href="nst-0004.xml"
addr="nst-0004"
title="Set equality">Set equality</fr:link>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>956</fr:anchor><fr:addr
type="user">nst-000G</fr:addr><fr:route>nst-000G.xml</fr:route><fr:title
text="Basic properties of intersection of two sets">Basic properties of intersection of two sets</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/boole.html#T2">boole:2</fr:link></fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T17">xboole_1:17</fr:link></fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T28">xboole_1:28</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, <fr:tex
display="inline"><![CDATA[B]]></fr:tex>, <fr:tex
display="inline"><![CDATA[C]]></fr:tex> be any three sets. Then the following all hold:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[A\cap \emptyset =\emptyset ]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[A\cap (B\cap  C)=(A\cap  B)\cap  C]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[A\subseteq  B]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[A\cap  B=A]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>958</fr:anchor><fr:addr
type="user">nst-000H</fr:addr><fr:route>nst-000H.xml</fr:route><fr:title
text="Intersection of family of sets">Intersection of family of sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/setfam_1.html#K1">setfam_1:def 1</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[F]]></fr:tex> be a family of sets (i.e., a set whose members are all sets). We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Intersection</html:dfn> of <fr:tex
display="inline"><![CDATA[F]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[\bigcap  F]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in \bigcap  F]]></fr:tex> iff for each set <fr:tex
display="inline"><![CDATA[Y\in  F]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>960</fr:anchor><fr:addr
type="user">nst-000I</fr:addr><fr:route>nst-000I.xml</fr:route><fr:title
text="Relative complement of a set">Relative complement of a set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.5</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_0.html#K4">xboole_0:def 5</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Relative complement</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> with respect to <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[Y\setminus  X]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  Y\setminus  X]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x\notin  X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>962</fr:anchor><fr:addr
type="user">nst-000J</fr:addr><fr:route>nst-000J.xml</fr:route><fr:title
text="Complement of a subset">Complement of a subset</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.5</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/subset_1.html#K3">subset_1:def 4</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a subset of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Complement</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to be the subset <fr:tex
display="inline"><![CDATA[X^{\complement }]]></fr:tex> of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> equal to <fr:tex
display="inline"><![CDATA[Y\setminus  X]]></fr:tex>.</fr:p><fr:p>Some texts use <fr:tex
display="inline"><![CDATA[\complement  X]]></fr:tex> or <fr:tex
display="inline"><![CDATA[X']]></fr:tex> for the complement of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>964</fr:anchor><fr:addr
type="user">nst-000K</fr:addr><fr:route>nst-000K.xml</fr:route><fr:title
text="Powerset">Powerset</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.5</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/zfmisc_1.html#K1">zfmisc_1:def 1</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Powerset</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[\mathcal {P}(X)]]></fr:tex> such that for any set <fr:tex
display="inline"><![CDATA[Z]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[Z\in \mathcal {P}(X)]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[Z\subseteq  X]]></fr:tex>. That is to say, the powerset of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is the set of all subsets of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p><fr:p>For finite sets (especially small sets we can write out by hand), we can see this is a sensible thing to define. But for infinite sets, some Mathematicians historically were nervous about this being well-defined. The important thing is that we assert (either axiomatically or dogmatically) this is indeed a set.</fr:p><fr:p>(In ZFC, this is given as an axiom.)</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>966</fr:anchor><fr:addr
type="user">nst-000L</fr:addr><fr:route>nst-000L.xml</fr:route><fr:title
text="Specification for ordered pairs">Specification for ordered pairs</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> be objects. Let <fr:tex
display="inline"><![CDATA[a]]></fr:tex> and <fr:tex
display="inline"><![CDATA[b]]></fr:tex> be objects. We expect the ordered pair <fr:tex
display="inline"><![CDATA[(x,y)]]></fr:tex> to be such that: <fr:tex
display="inline"><![CDATA[(x,y)=(a,b)]]></fr:tex> if and only if <fr:tex
display="inline"><![CDATA[x=a]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y=b]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>968</fr:anchor><fr:addr
type="user">nst-000M</fr:addr><fr:route>nst-000M.xml</fr:route><fr:title
text="Ordered pairs">Ordered pairs</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.6</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/tarski.html#K4">tarski:def 5</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> be objects. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Ordered Pair</html:dfn> to be the object <fr:tex
display="inline"><![CDATA[(x,y) = \{\{x\},\{x,y\}\}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>970</fr:anchor><fr:addr
type="user">nst-000N</fr:addr><fr:route>nst-000N.xml</fr:route><fr:title
text="Ordered pairs implement their specification">Ordered pairs implement their specification</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.6</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xtuple_0.html#T1">xtuple_0:1</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[a]]></fr:tex>, <fr:tex
display="inline"><![CDATA[b]]></fr:tex>, <fr:tex
display="inline"><![CDATA[c]]></fr:tex>, <fr:tex
display="inline"><![CDATA[d]]></fr:tex> be objects. If <fr:tex
display="inline"><![CDATA[(a,b)=(c,d)]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[a=c]]></fr:tex> and <fr:tex
display="inline"><![CDATA[b=d]]></fr:tex>.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>972</fr:anchor><fr:addr
type="machine">#262</fr:addr><fr:route>unstable-262.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We boild this proof down to two cases: either <fr:tex
display="inline"><![CDATA[c=d]]></fr:tex> or not. We assume <fr:tex
display="inline"><![CDATA[(a,b)=(c,d)]]></fr:tex>.</fr:p>
<fr:p><fr:strong>Case 1:</fr:strong> <fr:tex
display="inline"><![CDATA[c=d]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[(c,d)=(c,c)=\{\{c,c\},\{c\}\}=\{\{c\}\}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(a,b)=\{\{a,b\},\{a\}\}=\{\{c\}\}]]></fr:tex> requires <fr:tex
display="inline"><![CDATA[\{a,b\}=\{c\}]]></fr:tex> which implies <fr:tex
display="inline"><![CDATA[a=b=c]]></fr:tex>. Hence <fr:tex
display="inline"><![CDATA[a=b=c=d]]></fr:tex> which implies <fr:tex
display="inline"><![CDATA[a=c]]></fr:tex> and <fr:tex
display="inline"><![CDATA[b=d]]></fr:tex> as desired.</fr:p>
<fr:p><fr:strong>Case 2:</fr:strong> <fr:tex
display="inline"><![CDATA[c\neq  d]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[\{a\}\neq \{c,d\}]]></fr:tex>, so <fr:tex
display="inline"><![CDATA[\{a\}=\{c\}]]></fr:tex>, which means <fr:tex
display="inline"><![CDATA[a=c]]></fr:tex>. Then we see <fr:tex
display="inline"><![CDATA[(a,b)=(c,b)=(c,d)]]></fr:tex> which implies <fr:tex
display="inline"><![CDATA[\{c,b\}=\{c,d\}]]></fr:tex> which means <fr:tex
display="inline"><![CDATA[b=d]]></fr:tex>. Hence <fr:tex
display="inline"><![CDATA[a=c]]></fr:tex> and <fr:tex
display="inline"><![CDATA[b=d]]></fr:tex>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>974</fr:anchor><fr:addr
type="user">nst-000O</fr:addr><fr:route>nst-000O.xml</fr:route><fr:title
text="Cartesian product of two sets">Cartesian product of two sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.6</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/zfmisc_1.html#K2">zfmisc_1:def 2</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define their <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Cartesian product</html:dfn> to be the set <fr:tex
display="inline"><![CDATA[X\times  Y]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[z]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[z\in  X\times  Y]]></fr:tex> if and only if there exists objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y\in  Y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[z=(x,y)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>976</fr:anchor><fr:addr
type="user">nst-000Q</fr:addr><fr:route>nst-000Q.xml</fr:route><fr:title
text="Properties of Cartesian product">Properties of Cartesian product</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, <fr:tex
display="inline"><![CDATA[Z]]></fr:tex> be sets. Then the following all hold:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[X\times  Y\subseteq \mathcal {P}(\mathcal {P}(X\cup  Y))]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[X\times  Y=\emptyset ]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[X=\emptyset ]]></fr:tex> or <fr:tex
display="inline"><![CDATA[Y=\emptyset ]]></fr:tex></fr:li> <fr:li>If <fr:tex
display="inline"><![CDATA[X\times  Y=Y\times  X]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[X=Y]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[(X\cup  Y)\times  Z=(X\times  Z)\cup (Y\times  Z)]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[X\times (Y\cup  Z)=(X\times  Y)\cup (X\times  Z)]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[(X\cap  Y)\times  Z=(X\times  Z)\cap (Y\times  Z)]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[X\times (Y\cap  Z)=(X\times  Y)\cap (X\times  Z)]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[(X\setminus  Y)\times  Z=(X\times  Z)\setminus (Y\times  Z)]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[X\times (Y\setminus  Z)=(X\times  Y)\setminus (X\times  Z)]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="References">References</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3323</fr:anchor><fr:addr
type="user">halmos-1974-naive</fr:addr><fr:route>halmos-1974-naive.xml</fr:route><fr:title
text="Naive Set Theory">Naive Set Theory</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>1974</fr:year></fr:date><fr:authors><fr:author><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@book{halmos1974naive,
  author={Halmos, Paul},
  title={Naive Set Theory},
  year={1974},
  publisher={D. Van Nostrand Company Inc.}
}]]></fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3325</fr:anchor><fr:addr
type="user">bourbaki-1968-theory</fr:addr><fr:route>bourbaki-1968-theory.xml</fr:route><fr:title
text="Theory of Sets">Theory of Sets</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>1968</fr:year></fr:date><fr:authors><fr:author><fr:link
type="local"
href="nicolas-bourbaki.xml"
addr="nicolas-bourbaki"
title="Nicolas Bourbaki">Nicolas Bourbaki</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@book{bourbaki1968theory,
  author={Bourbaki, Nicolas},
  title={Theory of Sets},
  year={1968},
  publisher={Springer}
}]]></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>This actually describes an axiomatic set theory roughly as strong as Z (not ZF), but uses Hilbert's epsilon calculus which is much stronger than first-order logic. It gives Bourbaki something <fr:em>even stronger</fr:em> than the global choice operator "for free".</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Context">Context</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>3327</fr:anchor><fr:addr
type="user">nst</fr:addr><fr:route>nst.xml</fr:route><fr:title
text="Naive set theory">Naive set theory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>908</fr:anchor><fr:addr
type="user">nst-000P</fr:addr><fr:route>nst-000P.xml</fr:route><fr:title
text="Basic concepts and constructions of naive set theory">Basic concepts and constructions of naive set theory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>910</fr:anchor><fr:addr
type="user">nst-000R</fr:addr><fr:route>nst-000R.xml</fr:route><fr:title
text="Ontology of Mathematics">Ontology of Mathematics</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>What are the basic "things" we work with in Mathematics? It may seem that we have numbers, functions, and quite possibly other objects.</fr:p><fr:p>Broadly speaking, we could describe Mathematics as working with "sets" (unordered collections of stuff) and "objects" (any generic term or object).</fr:p><fr:p>In practice, there are compelling reasons to stipulate that <fr:em>everything</fr:em> in Mathematics consists of sets. This should be understood as saying that sets form the "machine code" of Mathematics. This is explicitly stated in Bourbaki's <fr:link
type="local"
href="bourbaki-1968-theory.xml"
addr="bourbaki-1968-theory"
title="Theory of Sets">Theory of Sets</fr:link>, II §1.1 (bottom of page 65 of English edition):</fr:p>
  <html:blockquote
xmlns:html="http://www.w3.org/1999/xhtml"><fr:p>From a "naive" point of view, many mathematical entities can be formalized as collections or "sets" of objects. We do not seek to formalize this notion, and in the formalistic interpretation of what follows, the word "set" is to be considered as strictly synonymous with "term".</fr:p></html:blockquote>
<fr:p>We will just stipulate that everything in Mathematics may be considered as an instance of some abstract type we call an "object". We extend this with a subtype called a "set". All sets are objects.</fr:p><fr:p>But some Mathematicians want to discuss the collection of all sets. This can't possibly be a set (otherwise we run into Russell's paradox), so we need to either modify our ontology (and work with "classes" instead of "sets", and call a class a "set" when it's a member of a class) or extend our ontology (to include a "class" as a third species of object). We will discuss this when the time comes, but the ontology is mildly flexible.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>912</fr:anchor><fr:addr
type="user">nst-0001</fr:addr><fr:route>nst-0001.xml</fr:route><fr:title
text="Set">Set</fr:title><fr:taxon>Provisional definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We [pretend to] define a [naive] <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Set</html:dfn> to be a well-defined unordered collection of objects.</fr:p><fr:p>If <fr:tex
display="inline"><![CDATA[x]]></fr:tex> is an object and <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a set, then we write <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> if <fr:tex
display="inline"><![CDATA[x]]></fr:tex> is an element (or member) of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>. If <fr:tex
display="inline"><![CDATA[x]]></fr:tex> is not an element of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, then we write <fr:tex
display="inline"><![CDATA[x\notin  X]]></fr:tex>.</fr:p><fr:p>We will also write <fr:tex
display="inline"><![CDATA[X\ni  x]]></fr:tex> as a synonym for <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>. We also write <fr:tex
display="inline"><![CDATA[X\not \ni  x]]></fr:tex>.</fr:p><fr:p>This isn't really a definition, because set theory is given axiomatically. We usually give axioms to specify the behaviour of the binary infixed predicate <fr:tex
display="inline"><![CDATA[\in ]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>914</fr:anchor><fr:addr
type="user">nst-000C</fr:addr><fr:route>nst-000C.xml</fr:route><fr:title
text="Proving well-definedness of terms">Proving well-definedness of terms</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>When we define a new term in Mathematics, we should prove it is well-defined. What this proof requires depends on what we're defining.</fr:p><fr:ul><fr:li>A new constant (possibly parametrized by other objects) <fr:tex
display="inline"><![CDATA[C]]></fr:tex> defined as satisfying some condition <fr:tex
display="inline"><![CDATA[\Phi [C]]]></fr:tex> requires proving (1) its existence (i.e, proving <fr:tex
display="inline"><![CDATA[\exists  x\ldotp \Phi [x]]]></fr:tex>), and (2) its uniqueness (i.e., <fr:tex
display="inline"><![CDATA[\forall  x,y\ldotp \Phi [x]\land \Phi [y]\implies  x=y]]></fr:tex>).</fr:li>
<fr:li>A new constant <fr:tex
display="inline"><![CDATA[C]]></fr:tex> which is defined as abbreviating some complicated expression is usually well-defined, sometimes we need to prove it has the "correct type".</fr:li>
<fr:li>A new species of thing (like a vector space or a <fr:link
type="local"
href="field-0001.xml"
addr="field-0001"
title="Field">Field</fr:link>) should require proving the existence of at least one such gadget.</fr:li>
<fr:li>All other types of definitions (predicates, adjectives, etc.) are well-defined.</fr:li></fr:ul><fr:p>One of the reasons why the <fr:link
type="local"
href="nst-0001.xml"
addr="nst-0001"
title="Set">"definition" of a set</fr:link> is not really a definition is because we should prove the existence of a set, but that's not possible. It's also why Mathematicians invented <fr:em>axiomatic</fr:em> set theory: presumably there are mathematical objects called "sets" which already exist, and we're trying to specify their behaviour (or some reasonable approximation) using axioms.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>916</fr:anchor><fr:addr
type="user">nst-000U</fr:addr><fr:route>nst-000U.xml</fr:route><fr:title
text="Examples of common sets">Examples of common sets</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We have some very common sets encountered in Mathematics, so we have special notation for them:</fr:p><fr:ul><fr:li><fr:tex
display="inline"><![CDATA[\mathbb {N}_{0}=\{0,1,2,3,…\}]]></fr:tex> the set of all non-negative integers</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[\mathbb {N}=\{1,2,3,4,…\}]]></fr:tex> the set of all positive integers</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[\mathbb {Z}=\{…,-3,-2,-1,0,1,2,3,…\}]]></fr:tex> the set of all integers</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[\mathbb {Q}=\{\frac {m}{n}\mid  m\in \mathbb {Z},n\in \mathbb {N}]]></fr:tex> the set of all rational numbers</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[\mathbb {R}]]></fr:tex> the set of real numbers</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[\mathbb {C}=\{x+\mathrm {i} y\mid  x,y\in \mathbb {R}\}]]></fr:tex> the set of complex numbers</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>918</fr:anchor><fr:addr
type="user">nst-0002</fr:addr><fr:route>nst-0002.xml</fr:route><fr:title
text="Finite sets">Finite sets</fr:title><fr:taxon>Notation</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If we have a set consisting of finitely many elements, we write it out as a comma-separated list delimited by <fr:tex
display="inline"><![CDATA[\{…\}]]></fr:tex>.</fr:p><fr:p>For example, the set of prime numbers less than 10 is <fr:tex
display="inline"><![CDATA[\{2,3,5,7\}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>920</fr:anchor><fr:addr
type="user">nst-0003</fr:addr><fr:route>nst-0003.xml</fr:route><fr:title
text="Empty set">Empty set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We say <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Empty</html:dfn> if there is no object <fr:tex
display="inline"><![CDATA[x]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>922</fr:anchor><fr:addr
type="user">nst-0004</fr:addr><fr:route>nst-0004.xml</fr:route><fr:title
text="Set equality">Set equality</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the predicate <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Set Equality</html:dfn> (or just <fr:em>equality</fr:em>) of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, denoted <fr:tex
display="inline"><![CDATA[X=Y]]></fr:tex>, to mean they have the same elements; i.e., for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> if and only if <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>.</fr:p><fr:p>When <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are not equal, we write <fr:tex
display="inline"><![CDATA[X\neq  Y]]></fr:tex>.</fr:p><fr:p>(This is technically an axiom of ZFC called the "axiom of extensionality".)</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>924</fr:anchor><fr:addr
type="user">nst-0005</fr:addr><fr:route>nst-0005.xml</fr:route><fr:title
text="The empty set">The empty set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We define <fr:em>the</fr:em> empty set to be the constant denoted <fr:tex
display="inline"><![CDATA[\emptyset ]]></fr:tex> (or sometimes <fr:tex
display="inline"><![CDATA[\{\}]]></fr:tex>).</fr:p><fr:p>We need to prove this is well-defined. For constants, this means proving it exists and is unique.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>926</fr:anchor><fr:addr
type="machine">#265</fr:addr><fr:route>unstable-265.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Existence:</fr:strong> Take the empty list as a set <fr:tex
display="inline"><![CDATA[\{\}]]></fr:tex>. This is clearly empty.</fr:p>

<fr:p><fr:strong>Uniqueness:</fr:strong> Suppose we have <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> both be empty sets. We want to prove <fr:tex
display="inline"><![CDATA[X=Y]]></fr:tex>. Then for any object <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, we want to prove (1) if <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> then <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>, and (2) if <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex> then <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>.</fr:p>

<fr:p>(1) Assume <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>. But <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is <fr:link
type="local"
href="nst-0004.xml"
addr="nst-0004"
title="Set equality">empty</fr:link>, so <fr:tex
display="inline"><![CDATA[X]]></fr:tex> cannot have any members. Then we have a contradiction. Hence we can conclude whatever we want, in particular <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>.</fr:p>

<fr:p>(2) The argument is the same but switching <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>928</fr:anchor><fr:addr
type="user">nst-0006</fr:addr><fr:route>nst-0006.xml</fr:route><fr:title
text="Subset">Subset</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the predicate <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex> to mean: for any object <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> then <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>. In other words, all elements of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> are also elements of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>. (This is very different than <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is an element of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>!)</fr:p><fr:p>We write <fr:tex
display="inline"><![CDATA[Y\supseteq  X]]></fr:tex> as a synonym for <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>.</fr:p><fr:p>We also write <fr:tex
display="inline"><![CDATA[X\nsubseteq  Y]]></fr:tex> as the antonym for <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[Y\nsupseteq  X]]></fr:tex> for the antonym of <fr:tex
display="inline"><![CDATA[Y\supseteq  X]]></fr:tex>.</fr:p><fr:p>Observe that <fr:tex
display="inline"><![CDATA[X\subseteq  X]]></fr:tex> for any set <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>930</fr:anchor><fr:addr
type="user">nst-0007</fr:addr><fr:route>nst-0007.xml</fr:route><fr:title
text="Proper subset">Proper subset</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the predicate <fr:tex
display="inline"><![CDATA[X\subset  Y]]></fr:tex> to mean <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[X\neq  Y]]></fr:tex>.</fr:p><fr:p>We also have the synonym <fr:tex
display="inline"><![CDATA[Y\supset  X]]></fr:tex> for <fr:tex
display="inline"><![CDATA[X\subset  Y]]></fr:tex>.</fr:p><fr:p>The choice of notation varies wildly. Some authors do not even distinguish proper subsets from "improper" subsets. Worse, some use <fr:tex
display="inline"><![CDATA[\subset ]]></fr:tex> for improper subsets. We have chosen to use notation analogous to <fr:tex
display="inline"><![CDATA[\leq ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\lt ]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>932</fr:anchor><fr:addr
type="user">nst-0008</fr:addr><fr:route>nst-0008.xml</fr:route><fr:title
text="Proving two sets are equal">Proving two sets are equal</fr:title><fr:taxon>Strategy</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Generically, when we want to prove <fr:link
type="local"
href="nst-0004.xml"
addr="nst-0004"
title="Set equality">Set equality</fr:link> like proving <fr:tex
display="inline"><![CDATA[X=Y]]></fr:tex>, we can use the <fr:link
type="local"
href="nst-0006.xml"
addr="nst-0006"
title="Subset">Subset</fr:link> predicate to prove two claims: (1) <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>, (2) <fr:tex
display="inline"><![CDATA[Y\subseteq  X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>934</fr:anchor><fr:addr
type="user">nst-0009</fr:addr><fr:route>nst-0009.xml</fr:route><fr:title
text="Set builder notation">Set builder notation</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.2</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>There are times when the notation for <fr:link
type="local"
href="nst-0002.xml"
addr="nst-0002"
title="Finite sets">Finite sets</fr:link> is clunky or impractical (e.g., write out the first <fr:tex
display="inline"><![CDATA[10^{120}]]></fr:tex> prime numbers). We have another notation for describing a set: if <fr:tex
display="inline"><![CDATA[P[x]]]></fr:tex> is a unary predicate and <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a set, then we write
<fr:tex
display="block"><![CDATA[\{x\in  X\mid  P[x]\}]]></fr:tex>
which describes "The set of <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[P[x]]]></fr:tex> holds". The vertical bar ("|") is read "such that". The allowable predicates <fr:tex
display="inline"><![CDATA[P[-]]]></fr:tex> must form a valid <fr:link
type="local"
href="nst-000A.xml"
addr="nst-000A"
title="Sentences in set theory">sentence</fr:link>. (This form of set builder notation is called "the axiom scheme of specification" in ZFC set theory.)</fr:p><fr:p>The other form of set builder notation which appears frequently: if <fr:tex
display="inline"><![CDATA[F(-)]]></fr:tex> is some construction, and <fr:tex
display="inline"><![CDATA[P[-]]]></fr:tex> is a unary predicate, and <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a set, then
<fr:tex
display="block"><![CDATA[\{F(x)\mid  x\in  X,P[x]\}]]></fr:tex>
describes the set obtained by applying <fr:tex
display="inline"><![CDATA[F]]></fr:tex> to each element of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> which satisfies the predicate <fr:tex
display="inline"><![CDATA[P]]></fr:tex>.</fr:p><fr:p>The Working Mathematician usually "suppresses" (omits) the <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> clause when it is understood.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>936</fr:anchor><fr:addr
type="user">nst-000A</fr:addr><fr:route>nst-000A.xml</fr:route><fr:title
text="Sentences in set theory">Sentences in set theory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.2</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>The allowed sentences or predicates appearing in set builder notation may be described recursively.</fr:p><fr:p>We can describe what possible formulas appear using the following:</fr:p><fr:ul><fr:li><fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[X=Y]]></fr:tex> are the atomic formulas</fr:li>
<fr:li>"not &lt;formula&gt;"</fr:li>
<fr:li>"&lt;formula&gt; and &lt;formula&gt;" or just a comma-separated list of formulas, all of which are expected to hold</fr:li>
<fr:li>"&lt;formula&gt; or &lt;formula&gt;" for the disjunction of formulas (in the sense of "either &lt;formula&gt; or &lt;formula&gt; or both")</fr:li>
<fr:li>"if &lt;formula&gt; then &lt;formula&gt;" (or "&lt;formula&gt; implies &lt;formula&gt;")</fr:li>
<fr:li>"&lt;formula&gt; iff &lt;formula&gt;"</fr:li>
<fr:li>"for all …"</fr:li>
<fr:li>"for some …" (or "exists …")</fr:li></fr:ul><fr:p>… as well as using any predicates we've defined (like the <fr:link
type="local"
href="nst-0006.xml"
addr="nst-0006"
title="Subset">Subset</fr:link> predicate).</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>938</fr:anchor><fr:addr
type="user">nst-001N</fr:addr><fr:route>nst-001N.xml</fr:route><fr:title
text="Russell's paradox">Russell's paradox</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose we try defining the set
<fr:tex
display="block"><![CDATA[R=\{S\hbox { is a set}\mid  S\notin  S\}.]]></fr:tex>
Then we obtain a contradiction if such a set exists. (The solution is to restrict what set-builder notation.)</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>652</fr:anchor><fr:addr
type="machine">#261</fr:addr><fr:route>unstable-261.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Well, assume <fr:tex
display="inline"><![CDATA[R]]></fr:tex> exists. We will prove we obtain a contradiction. Our proof is by cases: either <fr:tex
display="inline"><![CDATA[R\in  R]]></fr:tex> or <fr:tex
display="inline"><![CDATA[R\notin  R]]></fr:tex>.</fr:p>
<fr:p><fr:strong>Case 1:</fr:strong> Assume <fr:tex
display="inline"><![CDATA[R\in  R]]></fr:tex>. Then this means <fr:tex
display="inline"><![CDATA[R\notin  R]]></fr:tex>. But we have both <fr:tex
display="inline"><![CDATA[R\in  R]]></fr:tex> and <fr:tex
display="inline"><![CDATA[R\notin  R]]></fr:tex> which is a contradiction.</fr:p>
<fr:p><fr:strong>Case 2:</fr:strong> Assume <fr:tex
display="inline"><![CDATA[R\notin  R]]></fr:tex>. But this is the defining property for members of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>. This implies <fr:tex
display="inline"><![CDATA[R\in  R]]></fr:tex>. Again, we have both <fr:tex
display="inline"><![CDATA[R\in  R]]></fr:tex> and <fr:tex
display="inline"><![CDATA[R\notin  R]]></fr:tex> which is a contradiction.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>940</fr:anchor><fr:addr
type="user">nst-001O</fr:addr><fr:route>nst-001O.xml</fr:route><fr:title
text="There is no set of all sets">There is no set of all sets</fr:title><fr:taxon>Corollary</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An immediate consequence of <fr:link
type="local"
href="nst-001N.xml"
addr="nst-001N"
title="Russell's paradox">Russell's paradox</fr:link> is that there is no set of all sets. If there were a set <fr:tex
display="inline"><![CDATA[V]]></fr:tex> of all sets, then <fr:tex
display="inline"><![CDATA[V\in  V]]></fr:tex> which leads to problems.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>942</fr:anchor><fr:addr
type="user">nst-001P</fr:addr><fr:route>nst-001P.xml</fr:route><fr:title
text="Classes">Classes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We will often informally refer to a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">(Proper) Class</html:dfn> as an unordered collection which is "too big" to be a set.</fr:p><fr:p>For example, the von Neumann universe <fr:tex
display="inline"><![CDATA[\mathbf {V}]]></fr:tex> is the proper class of all sets.</fr:p><fr:p>In practice, we seldom need to work with proper classes directly. The Working Mathematician needs only sets (until we get to Category Theory, but we'll revisit this as needed).</fr:p><fr:p>The <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Axiom of limitation of size</html:dfn> asserts a collection <fr:tex
display="inline"><![CDATA[C]]></fr:tex> is a proper class if and only if there exists a surjective function from <fr:tex
display="inline"><![CDATA[C]]></fr:tex> to the von Neumann universe <fr:tex
display="inline"><![CDATA[\mathbf {V}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>944</fr:anchor><fr:addr
type="user">nst-000B</fr:addr><fr:route>nst-000B.xml</fr:route><fr:title
text="Union of a family of sets">Union of a family of sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/tarski.html#K3">tarski:def 4</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[F]]></fr:tex> be a family of sets (i.e., set whose elements are sets). We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Union</html:dfn> of <fr:tex
display="inline"><![CDATA[F]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[\bigcup  F]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in \bigcup  F]]></fr:tex> iff there is some set <fr:tex
display="inline"><![CDATA[X\in  F]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>.</fr:p><fr:p>This defines a new constant and we should set about to <fr:link
type="local"
href="nst-000C.xml"
addr="nst-000C"
title="Proving well-definedness of terms">proving it is well-defined</fr:link>, but proving its existence is impossible because it is just stipulated to exist ("axiom of union").</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>946</fr:anchor><fr:addr
type="user">nst-000D</fr:addr><fr:route>nst-000D.xml</fr:route><fr:title
text="Union of two sets">Union of two sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_0.html#K2">xboole_0:def 3</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Union</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[X\cup  Y]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  X\cup  Y]]></fr:tex> iff either <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> or <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>.</fr:p><fr:p>We see that this is commutative <fr:tex
display="inline"><![CDATA[X\cup  Y=Y\cup  X]]></fr:tex> and idempotent <fr:tex
display="inline"><![CDATA[X\cup  X=X]]></fr:tex>.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>948</fr:anchor><fr:addr
type="machine">#264</fr:addr><fr:route>unstable-264.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Existence:</fr:strong> take <fr:tex
display="inline"><![CDATA[X\cup  Y=\bigcup \{X,Y\}]]></fr:tex>. We need to prove <fr:tex
display="inline"><![CDATA[x\in  X\cup  Y\implies  x\in \bigcup \{X,Y\}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x\in \bigcup \{X,Y\}\implies  x\in  X\cup  Y]]></fr:tex>, but these follow immediately.</fr:p>

<fr:p><fr:strong>Uniqueness:</fr:strong> Suppose <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is such that for all <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  A]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> or <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is such that for all <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  B]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> or <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>. We will prove for all <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  A]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[x\in  B]]></fr:tex>: let <fr:tex
display="inline"><![CDATA[x]]></fr:tex> be an arbitrary object. Then
<fr:tex
display="block"><![CDATA[x\in  A\iff  x\in  A\hbox { or }x\in  A\iff  x\in  B]]></fr:tex>
which implies <fr:tex
display="inline"><![CDATA[x\in  A\iff  x\in  B]]></fr:tex>. Hence <fr:tex
display="inline"><![CDATA[A=B]]></fr:tex> by <fr:link
type="local"
href="nst-0004.xml"
addr="nst-0004"
title="Set equality">Set equality</fr:link>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>950</fr:anchor><fr:addr
type="user">nst-000E</fr:addr><fr:route>nst-000E.xml</fr:route><fr:title
text="Basic properties of union of two sets">Basic properties of union of two sets</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/boole.html#T1">boole:th1</fr:link></fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T4">xboole_1:th4</fr:link></fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T12">xboole_1:th12</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, <fr:tex
display="inline"><![CDATA[B]]></fr:tex>, <fr:tex
display="inline"><![CDATA[C]]></fr:tex> be arbitrary sets. Then the following all hold:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[A\cup \emptyset =A]]></fr:tex></fr:li>
<fr:li>Associativity: <fr:tex
display="inline"><![CDATA[A\cup (B\cup  C)=(A\cup  B)\cup  C]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[A\subseteq  B]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[A\cup  B=B]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>952</fr:anchor><fr:addr
type="user">nst-000F</fr:addr><fr:route>nst-000F.xml</fr:route><fr:title
text="Intersection of two sets">Intersection of two sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_0.html#K3">xboole_0:def 4</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define their <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Intersection</html:dfn> to be the set denoted <fr:tex
display="inline"><![CDATA[X\cap  Y]]></fr:tex> such that: for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  X\cap  Y]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>.</fr:p><fr:p>We see this is commutative <fr:tex
display="inline"><![CDATA[X\cap  Y=Y\cap  X]]></fr:tex> and idempotent <fr:tex
display="inline"><![CDATA[X\cap  X=X]]></fr:tex>.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>954</fr:anchor><fr:addr
type="machine">#263</fr:addr><fr:route>unstable-263.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Existence:</fr:strong> We see this exists using <fr:link
type="local"
href="nst-0009.xml"
addr="nst-0009"
title="Set builder notation">set-builder notation</fr:link>  <fr:tex
display="inline"><![CDATA[\{x\in  X\mid  x\in  Y\}]]></fr:tex>.</fr:p>
<fr:p><fr:strong>Uniqueness:</fr:strong> let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[B]]></fr:tex> be two possible candidates for the definition. We see <fr:tex
display="inline"><![CDATA[x\in  A\iff  x\in  X\hbox { and }x\in  Y\iff  x\in  B]]></fr:tex>, which implies <fr:tex
display="inline"><![CDATA[A=B]]></fr:tex> by <fr:link
type="local"
href="nst-0004.xml"
addr="nst-0004"
title="Set equality">Set equality</fr:link>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>956</fr:anchor><fr:addr
type="user">nst-000G</fr:addr><fr:route>nst-000G.xml</fr:route><fr:title
text="Basic properties of intersection of two sets">Basic properties of intersection of two sets</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/boole.html#T2">boole:2</fr:link></fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T17">xboole_1:17</fr:link></fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T28">xboole_1:28</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, <fr:tex
display="inline"><![CDATA[B]]></fr:tex>, <fr:tex
display="inline"><![CDATA[C]]></fr:tex> be any three sets. Then the following all hold:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[A\cap \emptyset =\emptyset ]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[A\cap (B\cap  C)=(A\cap  B)\cap  C]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[A\subseteq  B]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[A\cap  B=A]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>958</fr:anchor><fr:addr
type="user">nst-000H</fr:addr><fr:route>nst-000H.xml</fr:route><fr:title
text="Intersection of family of sets">Intersection of family of sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/setfam_1.html#K1">setfam_1:def 1</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[F]]></fr:tex> be a family of sets (i.e., a set whose members are all sets). We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Intersection</html:dfn> of <fr:tex
display="inline"><![CDATA[F]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[\bigcap  F]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in \bigcap  F]]></fr:tex> iff for each set <fr:tex
display="inline"><![CDATA[Y\in  F]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>960</fr:anchor><fr:addr
type="user">nst-000I</fr:addr><fr:route>nst-000I.xml</fr:route><fr:title
text="Relative complement of a set">Relative complement of a set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.5</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_0.html#K4">xboole_0:def 5</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Relative complement</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> with respect to <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[Y\setminus  X]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  Y\setminus  X]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x\notin  X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>962</fr:anchor><fr:addr
type="user">nst-000J</fr:addr><fr:route>nst-000J.xml</fr:route><fr:title
text="Complement of a subset">Complement of a subset</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.5</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/subset_1.html#K3">subset_1:def 4</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a subset of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Complement</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to be the subset <fr:tex
display="inline"><![CDATA[X^{\complement }]]></fr:tex> of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> equal to <fr:tex
display="inline"><![CDATA[Y\setminus  X]]></fr:tex>.</fr:p><fr:p>Some texts use <fr:tex
display="inline"><![CDATA[\complement  X]]></fr:tex> or <fr:tex
display="inline"><![CDATA[X']]></fr:tex> for the complement of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>964</fr:anchor><fr:addr
type="user">nst-000K</fr:addr><fr:route>nst-000K.xml</fr:route><fr:title
text="Powerset">Powerset</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.5</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/zfmisc_1.html#K1">zfmisc_1:def 1</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Powerset</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[\mathcal {P}(X)]]></fr:tex> such that for any set <fr:tex
display="inline"><![CDATA[Z]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[Z\in \mathcal {P}(X)]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[Z\subseteq  X]]></fr:tex>. That is to say, the powerset of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is the set of all subsets of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p><fr:p>For finite sets (especially small sets we can write out by hand), we can see this is a sensible thing to define. But for infinite sets, some Mathematicians historically were nervous about this being well-defined. The important thing is that we assert (either axiomatically or dogmatically) this is indeed a set.</fr:p><fr:p>(In ZFC, this is given as an axiom.)</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>966</fr:anchor><fr:addr
type="user">nst-000L</fr:addr><fr:route>nst-000L.xml</fr:route><fr:title
text="Specification for ordered pairs">Specification for ordered pairs</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> be objects. Let <fr:tex
display="inline"><![CDATA[a]]></fr:tex> and <fr:tex
display="inline"><![CDATA[b]]></fr:tex> be objects. We expect the ordered pair <fr:tex
display="inline"><![CDATA[(x,y)]]></fr:tex> to be such that: <fr:tex
display="inline"><![CDATA[(x,y)=(a,b)]]></fr:tex> if and only if <fr:tex
display="inline"><![CDATA[x=a]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y=b]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>968</fr:anchor><fr:addr
type="user">nst-000M</fr:addr><fr:route>nst-000M.xml</fr:route><fr:title
text="Ordered pairs">Ordered pairs</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.6</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/tarski.html#K4">tarski:def 5</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> be objects. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Ordered Pair</html:dfn> to be the object <fr:tex
display="inline"><![CDATA[(x,y) = \{\{x\},\{x,y\}\}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>970</fr:anchor><fr:addr
type="user">nst-000N</fr:addr><fr:route>nst-000N.xml</fr:route><fr:title
text="Ordered pairs implement their specification">Ordered pairs implement their specification</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.6</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xtuple_0.html#T1">xtuple_0:1</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[a]]></fr:tex>, <fr:tex
display="inline"><![CDATA[b]]></fr:tex>, <fr:tex
display="inline"><![CDATA[c]]></fr:tex>, <fr:tex
display="inline"><![CDATA[d]]></fr:tex> be objects. If <fr:tex
display="inline"><![CDATA[(a,b)=(c,d)]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[a=c]]></fr:tex> and <fr:tex
display="inline"><![CDATA[b=d]]></fr:tex>.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>972</fr:anchor><fr:addr
type="machine">#262</fr:addr><fr:route>unstable-262.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We boild this proof down to two cases: either <fr:tex
display="inline"><![CDATA[c=d]]></fr:tex> or not. We assume <fr:tex
display="inline"><![CDATA[(a,b)=(c,d)]]></fr:tex>.</fr:p>
<fr:p><fr:strong>Case 1:</fr:strong> <fr:tex
display="inline"><![CDATA[c=d]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[(c,d)=(c,c)=\{\{c,c\},\{c\}\}=\{\{c\}\}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(a,b)=\{\{a,b\},\{a\}\}=\{\{c\}\}]]></fr:tex> requires <fr:tex
display="inline"><![CDATA[\{a,b\}=\{c\}]]></fr:tex> which implies <fr:tex
display="inline"><![CDATA[a=b=c]]></fr:tex>. Hence <fr:tex
display="inline"><![CDATA[a=b=c=d]]></fr:tex> which implies <fr:tex
display="inline"><![CDATA[a=c]]></fr:tex> and <fr:tex
display="inline"><![CDATA[b=d]]></fr:tex> as desired.</fr:p>
<fr:p><fr:strong>Case 2:</fr:strong> <fr:tex
display="inline"><![CDATA[c\neq  d]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[\{a\}\neq \{c,d\}]]></fr:tex>, so <fr:tex
display="inline"><![CDATA[\{a\}=\{c\}]]></fr:tex>, which means <fr:tex
display="inline"><![CDATA[a=c]]></fr:tex>. Then we see <fr:tex
display="inline"><![CDATA[(a,b)=(c,b)=(c,d)]]></fr:tex> which implies <fr:tex
display="inline"><![CDATA[\{c,b\}=\{c,d\}]]></fr:tex> which means <fr:tex
display="inline"><![CDATA[b=d]]></fr:tex>. Hence <fr:tex
display="inline"><![CDATA[a=c]]></fr:tex> and <fr:tex
display="inline"><![CDATA[b=d]]></fr:tex>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>974</fr:anchor><fr:addr
type="user">nst-000O</fr:addr><fr:route>nst-000O.xml</fr:route><fr:title
text="Cartesian product of two sets">Cartesian product of two sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.6</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/zfmisc_1.html#K2">zfmisc_1:def 2</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define their <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Cartesian product</html:dfn> to be the set <fr:tex
display="inline"><![CDATA[X\times  Y]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[z]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[z\in  X\times  Y]]></fr:tex> if and only if there exists objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y\in  Y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[z=(x,y)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>976</fr:anchor><fr:addr
type="user">nst-000Q</fr:addr><fr:route>nst-000Q.xml</fr:route><fr:title
text="Properties of Cartesian product">Properties of Cartesian product</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, <fr:tex
display="inline"><![CDATA[Z]]></fr:tex> be sets. Then the following all hold:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[X\times  Y\subseteq \mathcal {P}(\mathcal {P}(X\cup  Y))]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[X\times  Y=\emptyset ]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[X=\emptyset ]]></fr:tex> or <fr:tex
display="inline"><![CDATA[Y=\emptyset ]]></fr:tex></fr:li> <fr:li>If <fr:tex
display="inline"><![CDATA[X\times  Y=Y\times  X]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[X=Y]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[(X\cup  Y)\times  Z=(X\times  Z)\cup (Y\times  Z)]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[X\times (Y\cup  Z)=(X\times  Y)\cup (X\times  Z)]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[(X\cap  Y)\times  Z=(X\times  Z)\cap (Y\times  Z)]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[X\times (Y\cap  Z)=(X\times  Y)\cap (X\times  Z)]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[(X\setminus  Y)\times  Z=(X\times  Z)\setminus (Y\times  Z)]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[X\times (Y\setminus  Z)=(X\times  Y)\setminus (X\times  Z)]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>978</fr:anchor><fr:addr
type="user">nst-000S</fr:addr><fr:route>nst-000S.xml</fr:route><fr:title
text="Relations and functions in naive set theory">Relations and functions in naive set theory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>980</fr:anchor><fr:addr
type="user">nst-000T</fr:addr><fr:route>nst-000T.xml</fr:route><fr:title
text="Relation">Relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>We can define a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Relation</html:dfn> broadly is a set <fr:tex
display="inline"><![CDATA[R]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[r\in  R]]></fr:tex> there exists objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[r=(x,y)]]></fr:tex>. In other words, a relation is a set which consists of ordered pairs.</fr:p><fr:p>When <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are sets, a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Relation</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is a subset <fr:tex
display="inline"><![CDATA[R\subseteq  X\times  Y]]></fr:tex>.</fr:p><fr:p>We will speak of a "Relation of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>" when referring to a subset <fr:tex
display="inline"><![CDATA[R\subseteq  X\times  X]]></fr:tex>.</fr:p><fr:p>If <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is a relation and <fr:tex
display="inline"><![CDATA[(x,y)\in  R]]></fr:tex>, then we will frequently abuse notation and write <fr:tex
display="inline"><![CDATA[x\;R\;y]]></fr:tex>. Usually instead of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, for particular relations we use <fr:tex
display="inline"><![CDATA[\sim ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\approx ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\cong ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\equiv ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\lt ]]></fr:tex>, or other notation which is more aesthetically pleasing.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>982</fr:anchor><fr:addr
type="user">nst-000V</fr:addr><fr:route>nst-000V.xml</fr:route><fr:title
text="Domain of a relation">Domain of a relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be a relation. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Domain</html:dfn> of <fr:tex
display="inline"><![CDATA[R]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[\mathop {\textrm {dom}}\nolimits (R)=\{x\mid  \exists  y\ldotp  (x,y)\in  R\}]]></fr:tex>.</fr:p><fr:p>When <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is a relation of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, we see <fr:tex
display="inline"><![CDATA[\mathop {\textrm {dom}}\nolimits (R)\subseteq  X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>984</fr:anchor><fr:addr
type="user">nst-000W</fr:addr><fr:route>nst-000W.xml</fr:route><fr:title
text="Range of a relation">Range of a relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be a relation. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Range</html:dfn> of <fr:tex
display="inline"><![CDATA[R]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[\mathop {\textrm {ran}}\nolimits (R)=\{y\mid \exists  x\ldotp (x,y)\in  R\}]]></fr:tex>.</fr:p><fr:p>When <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is a relation of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, we see <fr:tex
display="inline"><![CDATA[\mathop {\textrm {ran}}\nolimits (R)\subseteq  Y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>986</fr:anchor><fr:addr
type="user">nst-000X</fr:addr><fr:route>nst-000X.xml</fr:route><fr:title
text="Field of a relation">Field of a relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/relat_1.html#K1">relat_1:def 6</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be a relation. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Field</html:dfn> of <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is just <fr:tex
display="inline"><![CDATA[\mathop {\textrm {dom}}\nolimits (R)\cup \mathop {\textrm {ran}}\nolimits (R)]]></fr:tex>.</fr:p><fr:p>Observe when <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is a relation of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, the field <fr:tex
display="inline"><![CDATA[F]]></fr:tex> of <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is a subset <fr:tex
display="inline"><![CDATA[F\subseteq  X\cup  Y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>988</fr:anchor><fr:addr
type="user">nst-001F</fr:addr><fr:route>nst-001F.xml</fr:route><fr:title
text="Inverse relation">Inverse relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be a relation. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Inverse</html:dfn> of <fr:tex
display="inline"><![CDATA[R]]></fr:tex> to be the relation <fr:tex
display="inline"><![CDATA[R^{-1}=\{(y,x)\mid (x,y)\in  R\}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>990</fr:anchor><fr:addr
type="user">nst-000Y</fr:addr><fr:route>nst-000Y.xml</fr:route><fr:title
text="Reflexive relation">Reflexive relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/relat_2.html#V1">relat_2:def 9</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be a relation, let <fr:tex
display="inline"><![CDATA[F]]></fr:tex> be its <fr:link
type="local"
href="nst-000X.xml"
addr="nst-000X"
title="Field of a relation">field</fr:link>. We say <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Reflexive</html:dfn> if for each <fr:tex
display="inline"><![CDATA[x\in  F]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[(x,x)\in  R]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>992</fr:anchor><fr:addr
type="user">nst-000Z</fr:addr><fr:route>nst-000Z.xml</fr:route><fr:title
text="Symmetric relation">Symmetric relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/relat_2.html#V3">relat_2:def 11</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be a relation, let <fr:tex
display="inline"><![CDATA[F]]></fr:tex> be its <fr:link
type="local"
href="nst-000X.xml"
addr="nst-000X"
title="Field of a relation">field</fr:link>. We say <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Symmetric</html:dfn> if for all <fr:tex
display="inline"><![CDATA[x\in  F]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y\in  F]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[(x,y)\in  R]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[(y,x)\in  R]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>994</fr:anchor><fr:addr
type="user">nst-0010</fr:addr><fr:route>nst-0010.xml</fr:route><fr:title
text="Transitive relation">Transitive relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/relat_2.html#V8">relat_2:def 16</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be a relation, let <fr:tex
display="inline"><![CDATA[F]]></fr:tex> be its <fr:link
type="local"
href="nst-000X.xml"
addr="nst-000X"
title="Field of a relation">field</fr:link>. We say <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Transitive</html:dfn> if for all <fr:tex
display="inline"><![CDATA[x\in  F]]></fr:tex>, <fr:tex
display="inline"><![CDATA[y\in  F]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[z\in  F]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[(x,y)\in  R]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(y,z)\in  R]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[(x,z)\in  R]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>996</fr:anchor><fr:addr
type="user">nst-0011</fr:addr><fr:route>nst-0011.xml</fr:route><fr:title
text="Equivalence relation">Equivalence relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/eqrel_1.html#NM2">eqrel_1:def</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We define an <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Equivalence Relation</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to be a <fr:link
type="local"
href="nst-000Y.xml"
addr="nst-000Y"
title="Reflexive relation">reflexive</fr:link> <fr:link
type="local"
href="nst-000Z.xml"
addr="nst-000Z"
title="Symmetric relation">symmetric</fr:link> <fr:link
type="local"
href="nst-0010.xml"
addr="nst-0010"
title="Transitive relation">transitive</fr:link> relation of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p><fr:p>For example, <fr:tex
display="inline"><![CDATA[R=\{(x,x)\mid  x\in  X\}]]></fr:tex> is always an equivalence relation of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> which describes equality of elements of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p><fr:p>More generally, an equivalence relation is a generalization of equality. Consequently, it is common to use notation like <fr:tex
display="inline"><![CDATA[\sim ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\approx ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\equiv ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\cong ]]></fr:tex> for equivalence relations.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>998</fr:anchor><fr:addr
type="user">nst-0012</fr:addr><fr:route>nst-0012.xml</fr:route><fr:title
text="Equivalence class">Equivalence class</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/eqrel_1.html#K6">eqrel_1:def</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set, let <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>, and let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be an equivalence relation of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Equivalence Class</html:dfn> of <fr:tex
display="inline"><![CDATA[x]]></fr:tex> with respect to <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is the set <fr:tex
display="inline"><![CDATA[[x]_{R}=\{y\in  X\mid  (x,y)\in  R\}]]></fr:tex> consisting of all elements equivalent to <fr:tex
display="inline"><![CDATA[x]]></fr:tex> under <fr:tex
display="inline"><![CDATA[R]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1000</fr:anchor><fr:addr
type="user">nst-0013</fr:addr><fr:route>nst-0013.xml</fr:route><fr:title
text="Composing relations">Composing relations</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/relat_1.html#K3">relat_1:def 8</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[P]]></fr:tex> and <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be relations. We define their <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Composition</html:dfn> to be the relation denoted <fr:tex
display="inline"><![CDATA[PR]]></fr:tex> or <fr:tex
display="inline"><![CDATA[R\circ  P]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[z]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[(x,z)\in  PR]]></fr:tex> iff there exists an object <fr:tex
display="inline"><![CDATA[y]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[(x,y)\in  P]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(y,z)\in  R]]></fr:tex>.</fr:p><fr:p>The <fr:tex
display="inline"><![CDATA[PR]]></fr:tex> notation means <fr:tex
display="inline"><![CDATA[xPRz]]></fr:tex> iff there exists a <fr:tex
display="inline"><![CDATA[y]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[xPyRz]]></fr:tex>.</fr:p><fr:p>The <fr:tex
display="inline"><![CDATA[R\circ  P]]></fr:tex> notation is useful for working with functions.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1002</fr:anchor><fr:addr
type="user">nst-001B</fr:addr><fr:route>nst-001B.xml</fr:route><fr:title
text="Composing relations is associative">Composing relations is associative</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/relat_1.html#T36">relat_1:th36</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R_{1}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[R_{2}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[R_{3}]]></fr:tex> be relations. Then <fr:tex
display="inline"><![CDATA[(R_{1}\circ  R_{2})\circ  R_{3}=R_{1}\circ (R_{2}\circ  R_{3})]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1004</fr:anchor><fr:addr
type="user">nst-0014</fr:addr><fr:route>nst-0014.xml</fr:route><fr:title
text="Function">Function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.8</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Function</html:dfn> from <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> to be a <fr:link
type="local"
href="nst-000T.xml"
addr="nst-000T"
title="Relation">relation</fr:link> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> denoted <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> such that:
<fr:ol><fr:li><fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/partfun1.html#V1">Total</fr:link>: <fr:tex
display="inline"><![CDATA[\mathop {\textrm {dom}}\nolimits (f)=X]]></fr:tex>, and</fr:li>
<fr:li><fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/funct_1.html#V1">Function-like</fr:link>: for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, <fr:tex
display="inline"><![CDATA[y]]></fr:tex>, <fr:tex
display="inline"><![CDATA[z]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[(x,y)\in  f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(x,z)\in  f]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[y=z]]></fr:tex>.</fr:li></fr:ol>
Instead of <fr:tex
display="inline"><![CDATA[(x,y)\in  f]]></fr:tex>, we write <fr:tex
display="inline"><![CDATA[f(x)=y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1006</fr:anchor><fr:addr
type="user">nst-0015</fr:addr><fr:route>nst-0015.xml</fr:route><fr:title
text="Set of all functions">Set of all functions</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.8</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/funct_2.html#K1">funct_2:def 2</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We denote the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Set of all functions</html:dfn> from <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> as either <fr:tex
display="inline"><![CDATA[Y^{X}]]></fr:tex> or <fr:tex
display="inline"><![CDATA[\hom (X,Y)]]></fr:tex>.</fr:p><fr:p>We see this really is a set, since a function is a subset of <fr:tex
display="inline"><![CDATA[X\times  Y]]></fr:tex>, so the set of all functions is a subset of <fr:tex
display="inline"><![CDATA[\mathcal {P}(X\times  Y)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1008</fr:anchor><fr:addr
type="user">nst-0016</fr:addr><fr:route>nst-0016.xml</fr:route><fr:title
text="Inclusion">Inclusion</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.8</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/funct_3.html#K6">funct_3:def</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a subset of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>. Then the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Inclusion</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> into <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is the function <fr:tex
display="inline"><![CDATA[i\colon  X\to  Y]]></fr:tex> defined by <fr:tex
display="inline"><![CDATA[i(x)=x]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1010</fr:anchor><fr:addr
type="user">nst-0017</fr:addr><fr:route>nst-0017.xml</fr:route><fr:title
text="Identity function">Identity function</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/relat_1.html#K4">relat_1:def 10</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Identity Function</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to be the function <fr:tex
display="inline"><![CDATA[\mathop {\textrm {id}}\nolimits _{X}\colon  X\to  X]]></fr:tex> such that for all <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\mathop {\textrm {id}}\nolimits _{X}(x)=x]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1012</fr:anchor><fr:addr
type="user">nst-0018</fr:addr><fr:route>nst-0018.xml</fr:route><fr:title
text="Restriction of a function">Restriction of a function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.8</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/relat_1.html#K5">relat_1:def 11</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[g\colon  Y\to  Z]]></fr:tex> be a function, let <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Restriction</html:dfn> of <fr:tex
display="inline"><![CDATA[g]]></fr:tex> to <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to be the function <fr:tex
display="inline"><![CDATA[g|_{X}\colon  X\to  Z]]></fr:tex> such that for all <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>, <fr:tex
display="inline"><![CDATA[g|_{X}(x)=g(x)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1014</fr:anchor><fr:addr
type="user">nst-0019</fr:addr><fr:route>nst-0019.xml</fr:route><fr:title
text="Projection of Cartesian product">Projection of Cartesian product</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.8</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Projection Functions</html:dfn> <fr:tex
display="inline"><![CDATA[\pi _{1}\colon  X\times  Y\to  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\pi _{2}\colon  X\times  Y\to  Y]]></fr:tex> by <fr:tex
display="inline"><![CDATA[\pi _{1}(x,y)=x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\pi _{2}(x,y)=y]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y\in  Y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1016</fr:anchor><fr:addr
type="user">nst-001M</fr:addr><fr:route>nst-001M.xml</fr:route><fr:title
text="Composition of functions">Composition of functions</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g\colon  Y\to  Z]]></fr:tex> be functions. Then the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Composition</html:dfn> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> followed by <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is the function <fr:tex
display="inline"><![CDATA[g\circ  f\colon  X\to  Z]]></fr:tex> defined by <fr:tex
display="inline"><![CDATA[(g\circ  f)(x)=g(f(x))]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>.</fr:p><fr:p>Observe this is just the <fr:link
type="local"
href="nst-0013.xml"
addr="nst-0013"
title="Composing relations">Composing relations</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1018</fr:anchor><fr:addr
type="user">nst-001A</fr:addr><fr:route>nst-001A.xml</fr:route><fr:title
text="Composing functions is associative">Composing functions is associative</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  W\to  X]]></fr:tex>, <fr:tex
display="inline"><![CDATA[g\colon  X\to  Y]]></fr:tex>, <fr:tex
display="inline"><![CDATA[h\colon  Y\to  Z]]></fr:tex> be functions. Then <fr:tex
display="inline"><![CDATA[h\circ (g\circ  f)=(h\circ  g)\circ  f]]></fr:tex>.</fr:p><fr:p>This follows from <fr:link
type="local"
href="nst-001B.xml"
addr="nst-001B"
title="Composing relations is associative">composing relations is associative</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1020</fr:anchor><fr:addr
type="user">nst-001C</fr:addr><fr:route>nst-001C.xml</fr:route><fr:title
text="Preimage of a function">Preimage of a function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.10</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function, let <fr:tex
display="inline"><![CDATA[B\subseteq  Y]]></fr:tex>. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Preimage</html:dfn> of <fr:tex
display="inline"><![CDATA[B]]></fr:tex> under <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[f^{-1}(A)=\{x\in  X\mid  f(x)\in  B\}]]></fr:tex>.</fr:p><fr:p>This is sometimes denoted <fr:tex
display="inline"><![CDATA[f^{*}(B)]]></fr:tex> to avoid confusing the preimage with the inverse function of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. This allows us to interpret <fr:tex
display="inline"><![CDATA[f^{*}\colon \mathcal {P}(Y)\to \mathcal {P}(X)]]></fr:tex> without ambiguity.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1022</fr:anchor><fr:addr
type="user">ela-001B</fr:addr><fr:route>ela-001B.xml</fr:route><fr:title
text="Image of a function">Image of a function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets, let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Image</html:dfn> (or <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Range</html:dfn>) of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to be the subset <fr:tex
display="inline"><![CDATA[\mathop {\textrm {ran}}\nolimits (f)=f(X)=\{f(x)\in  Y\mid  x\in  X\}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1024</fr:anchor><fr:addr
type="user">nst-001D</fr:addr><fr:route>nst-001D.xml</fr:route><fr:title
text="Direct image of a function">Direct image of a function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.10</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function. Let <fr:tex
display="inline"><![CDATA[A\subseteq  X]]></fr:tex>. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Direct Image</html:dfn> of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> under <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[f(A)=\{f(x)\in  Y\mid  x\in  A\}]]></fr:tex>.</fr:p><fr:p>We sometimes use the notation <fr:tex
display="inline"><![CDATA[f_{*}(A)]]></fr:tex> for the direct image of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> under <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, so we can describe a function <fr:tex
display="inline"><![CDATA[f_{*}\colon \mathcal {P}(X)\to \mathcal {P}(Y)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1026</fr:anchor><fr:addr
type="user">nst-001E</fr:addr><fr:route>nst-001E.xml</fr:route><fr:title
text="Properties of image and preimage of a function">Properties of image and preimage of a function</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.10</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function, let <fr:tex
display="inline"><![CDATA[A\subseteq  X]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[B\subseteq  Y]]></fr:tex>. Then the following all hold:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[f(f^{-1}(B))\subseteq  B]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[A\subseteq  f^{-1}(f(A))]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1028</fr:anchor><fr:addr
type="user">nst-001J</fr:addr><fr:route>nst-001J.xml</fr:route><fr:title
text="Preimages preserve everything">Preimages preserve everything</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="nicolas-bourbaki.xml"
addr="nicolas-bourbaki"
title="Nicolas Bourbaki">Nicolas Bourbaki</fr:link> <fr:link
type="local"
href="bourbaki-1968-theory.xml"
addr="bourbaki-1968-theory"
title="Theory of Sets">Theory of Sets</fr:link> R §2.10</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function, let <fr:tex
display="inline"><![CDATA[L\subseteq  Y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[R\subseteq  Y]]></fr:tex> be subsets. Then the following all hold:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[f^{-1}(L\cup  R)=f^{-1}(L)\cup  f^{-1}(R)]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[f^{-1}(L\cap  R)=f^{-1}(L)\cap  f^{-1}(R)]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[f^{-1}(L\setminus  R)=f^{-1}(L)\setminus  f^{-1}(R)]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1030</fr:anchor><fr:addr
type="user">nst-001K</fr:addr><fr:route>nst-001K.xml</fr:route><fr:title
text="Direct image preserves only union">Direct image preserves only union</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="nicolas-bourbaki.xml"
addr="nicolas-bourbaki"
title="Nicolas Bourbaki">Nicolas Bourbaki</fr:link> <fr:link
type="local"
href="bourbaki-1968-theory.xml"
addr="bourbaki-1968-theory"
title="Theory of Sets">Theory of Sets</fr:link> R§2.5</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function, let <fr:tex
display="inline"><![CDATA[L\subseteq  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[R\subseteq  X]]></fr:tex> be subsets. Then the following all hold:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[f(L\cup  R)=f(L)\cup  f(R)]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[f(L\cap  R)\subseteq  f(L)\cap  f(R)]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[f(L\setminus  R)\supseteq  f(L)\setminus  f(R)]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1032</fr:anchor><fr:addr
type="user">ela-001I</fr:addr><fr:route>ela-001I.xml</fr:route><fr:title
text="Surjective function">Surjective function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function. We say <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Surjective</html:dfn> (or that it's a <fr:em>surjection</fr:em>) if for each <fr:tex
display="inline"><![CDATA[y\in  Y]]></fr:tex> there is at least one <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[f(x)=y]]></fr:tex>.</fr:p><fr:p>In other words, the <fr:link
type="local"
href="ela-001B.xml"
addr="ela-001B"
title="Image of a function">image</fr:link> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is the <fr:link
type="local"
href="ela-001C.xml"
addr="ela-001C"
title="Domain and codomain of a function">codomain</fr:link> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. Or more vividly, <fr:tex
display="inline"><![CDATA[f]]></fr:tex> "covers" all of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1034</fr:anchor><fr:addr
type="user">nst-001H</fr:addr><fr:route>nst-001H.xml</fr:route><fr:title
text="Surjective functions have right inverse">Surjective functions have right inverse</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be an <fr:link
type="local"
href="ela-001I.xml"
addr="ela-001I"
title="Surjective function">Surjective function</fr:link>. Then there exists a function <fr:tex
display="inline"><![CDATA[g\colon  Y\to  X]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[f\circ  g=\mathop {\textrm {id}}\nolimits _{Y}]]></fr:tex>.</fr:p><fr:p>We call such a <fr:tex
display="inline"><![CDATA[g]]></fr:tex> a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Right Inverse</html:dfn> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1036</fr:anchor><fr:addr
type="user">ela-001J</fr:addr><fr:route>ela-001J.xml</fr:route><fr:title
text="Injective function">Injective function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function. We say <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">injective</html:dfn> (or that it's a <fr:em>injection</fr:em>) if for all <fr:tex
display="inline"><![CDATA[x_{1},x_{2}\in  X]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[f(x_{1})=f(x_{2})]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x_{1}=x_{2}]]></fr:tex>.</fr:p><fr:p>Equivalently, if <fr:tex
display="inline"><![CDATA[f(x_{1})\neq  f(x_{2})]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[x_{1}\neq  x_{2}]]></fr:tex>.</fr:p><fr:p>So no two distinct elements of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> are mapped to the same element under <fr:tex
display="inline"><![CDATA[f]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1038</fr:anchor><fr:addr
type="user">nst-001G</fr:addr><fr:route>nst-001G.xml</fr:route><fr:title
text="Injective functions have a left inverse function">Injective functions have a left inverse function</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be an <fr:link
type="local"
href="ela-001J.xml"
addr="ela-001J"
title="Injective function">Injective function</fr:link>. Then there exists a function <fr:tex
display="inline"><![CDATA[g\colon  Y\to  X]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[g\circ  f=\mathop {\textrm {id}}\nolimits _{X}]]></fr:tex>.</fr:p><fr:p>We call such a <fr:tex
display="inline"><![CDATA[g]]></fr:tex> a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Left Inverse</html:dfn> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1040</fr:anchor><fr:addr
type="user">ela-001K</fr:addr><fr:route>ela-001K.xml</fr:route><fr:title
text="Bijective function">Bijective function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We say a function <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Bijective</html:dfn> (or say <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is a <fr:em>bijection</fr:em>) if <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is both <fr:link
type="local"
href="ela-001J.xml"
addr="ela-001J"
title="Injective function">injective</fr:link> and <fr:link
type="local"
href="ela-001I.xml"
addr="ela-001I"
title="Surjective function">surjective</fr:link>.</fr:p><fr:p>This means for each <fr:tex
display="inline"><![CDATA[y\in  Y]]></fr:tex>, there exists a unique <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[f(x)=y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1042</fr:anchor><fr:addr
type="user">nst-001L</fr:addr><fr:route>nst-001L.xml</fr:route><fr:title
text="Inverse function">Inverse function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function. We call a function <fr:tex
display="inline"><![CDATA[g\colon  Y\to  X]]></fr:tex> the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Inverse</html:dfn> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> if <fr:tex
display="inline"><![CDATA[f\circ  g=\mathop {\textrm {id}}\nolimits _{Y}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g\circ  f=\mathop {\textrm {id}}\nolimits _{X}]]></fr:tex>. When such a <fr:tex
display="inline"><![CDATA[g]]></fr:tex> exists, we denote it by <fr:tex
display="inline"><![CDATA[f^{-1}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1044</fr:anchor><fr:addr
type="user">nst-001I</fr:addr><fr:route>nst-001I.xml</fr:route><fr:title
text="Bijective functions have unique inverse">Bijective functions have unique inverse</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/funct_1.html#K2">funct_1:def 5</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be an <fr:link
type="local"
href="ela-001K.xml"
addr="ela-001K"
title="Bijective function">Bijective function</fr:link>. Then there exists a function <fr:tex
display="inline"><![CDATA[g\colon  Y\to  X]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[f\circ  g=\mathop {\textrm {id}}\nolimits _{Y}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g\circ  f=\mathop {\textrm {id}}\nolimits _{X}]]></fr:tex>. Moreover this function <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is unique.</fr:p><fr:p>We call such a <fr:tex
display="inline"><![CDATA[g]]></fr:tex> the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Inverse</html:dfn> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, and we usually denote it by <fr:tex
display="inline"><![CDATA[f^{-1}=g]]></fr:tex>.</fr:p><fr:p>We see that if <fr:tex
display="inline"><![CDATA[(x,y)\in  f]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[(y,x)\in  g]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1046</fr:anchor><fr:addr
type="user">nst-001R</fr:addr><fr:route>nst-001R.xml</fr:route><fr:title
text="Cardinality and Ordinality">Cardinality and Ordinality</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>472</fr:anchor><fr:addr
type="user">nst-001Q</fr:addr><fr:route>nst-001Q.xml</fr:route><fr:title
text="Finite set">Finite set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Definition 2.4</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>We call a set <fr:tex
display="inline"><![CDATA[A]]></fr:tex> <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Finite</html:dfn> if there exists a non-negative integer <fr:tex
display="inline"><![CDATA[n\in \mathbb {N}_{0}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\{k\in \mathbb {N}\mid  k\leq  n\}]]></fr:tex> is bijective with <fr:tex
display="inline"><![CDATA[A]]></fr:tex>.</fr:p><fr:p>Otherwise, we call <fr:tex
display="inline"><![CDATA[A]]></fr:tex> <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Infinite</html:dfn>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>474</fr:anchor><fr:addr
type="user">nst-001S</fr:addr><fr:route>nst-001S.xml</fr:route><fr:title
text="Countable set">Countable set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Definition 2.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/card_3.html#V4">card_3:def 14</fr:link></fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/card_3.html#V5">card_3:def 15</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>We call a set <fr:tex
display="inline"><![CDATA[A]]></fr:tex> <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Countable</html:dfn> if there is an injective map <fr:tex
display="inline"><![CDATA[A\to \mathbb {N}]]></fr:tex>.</fr:p><fr:p>Otherwise we call <fr:tex
display="inline"><![CDATA[A]]></fr:tex> <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Uncountable</html:dfn>.</fr:p><fr:p>When <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is infinite, <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is countable iff there is a bijection <fr:tex
display="inline"><![CDATA[A\to \mathbb {N}]]></fr:tex> (or a bijection <fr:tex
display="inline"><![CDATA[\mathbb {N}\to  A]]></fr:tex>). In this case, we will call <fr:tex
display="inline"><![CDATA[A]]></fr:tex> <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Countably Infinite</html:dfn> (or <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Denumerable</html:dfn>).</fr:p><fr:p><fr:strong>Caution:</fr:strong> some authors say <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is countable if there is an bijective function <fr:tex
display="inline"><![CDATA[A\to \mathbb {N}]]></fr:tex>. This seems to be the case among analysts, but I don't think I could live with myself if I were to follow their example.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>476</fr:anchor><fr:addr
type="user">nst-001T</fr:addr><fr:route>nst-001T.xml</fr:route><fr:title
text="Integers are countable">Integers are countable</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Example 2.5</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>The integers <fr:tex
display="inline"><![CDATA[\mathbb {Z}]]></fr:tex> are countable. Consider <fr:tex
display="inline"><![CDATA[f\colon \mathbb {N}_{0}\to \mathbb {Z}]]></fr:tex> such that
<fr:tex
display="block"><![CDATA[f(n)=\begin {cases}(n+1)/2 & n\hbox { is odd}\\ -n/2 & n\hbox { is even}\end {cases}]]></fr:tex>
Then <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is a bijection.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>478</fr:anchor><fr:addr
type="user">nst-001U</fr:addr><fr:route>nst-001U.xml</fr:route><fr:title
text="A set bijective with a countably infinite set is countably infinite">A set bijective with a countably infinite set is countably infinite</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> be a set, let <fr:tex
display="inline"><![CDATA[B]]></fr:tex> be a countably infinite set. Then <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is countably infinite iff there is a bijection <fr:tex
display="inline"><![CDATA[f\colon  A\to  B]]></fr:tex>.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>480</fr:anchor><fr:addr
type="machine">#260</fr:addr><fr:route>unstable-260.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[g\colon  B\to \mathbb {N}]]></fr:tex> be an injective function (since <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is countable). If <fr:tex
display="inline"><![CDATA[f\colon  A\to  B]]></fr:tex> is bijective, then <fr:tex
display="inline"><![CDATA[g\circ  f]]></fr:tex> is injective, hence <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is countable.</fr:p>
<fr:p>If <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is countably infinite, then there is a bijection <fr:tex
display="inline"><![CDATA[g\colon  A\to \mathbb {N}]]></fr:tex>. We have <fr:tex
display="inline"><![CDATA[h\colon  B\to \mathbb {N}]]></fr:tex> be bijective (since <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is countable). Then <fr:tex
display="inline"><![CDATA[h^{-1}\circ  g\colon  A\to  B]]></fr:tex> is bijective.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>482</fr:anchor><fr:addr
type="user">nst-001W</fr:addr><fr:route>nst-001W.xml</fr:route><fr:title
text="Sequence">Sequence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Definition 2.7</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> be a set. A <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Sequence</html:dfn> of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is a function <fr:tex
display="inline"><![CDATA[f\colon \mathbb {N}\to  A]]></fr:tex>, where we usually write <fr:tex
display="inline"><![CDATA[f_{n}]]></fr:tex> instead of <fr:tex
display="inline"><![CDATA[f(n)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>484</fr:anchor><fr:addr
type="user">nst-001X</fr:addr><fr:route>nst-001X.xml</fr:route><fr:title
text="Enumerating elements of a set">Enumerating elements of a set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Definition 2.7</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> be a countably infinite set. We <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Enumerate</html:dfn> the elements of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> by producing an bijection <fr:tex
display="inline"><![CDATA[\mathbb {N}\to  A]]></fr:tex> as a sequence.</fr:p><fr:p>Conversely, if there is a sequence of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> which is bijective, then we call that sequence an <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Enumeration</html:dfn> of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>486</fr:anchor><fr:addr
type="user">nst-001V</fr:addr><fr:route>nst-001V.xml</fr:route><fr:title
text="Every infinite subset of a countably infinite set is countable">Every infinite subset of a countably infinite set is countable</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Theorem 2.8</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> be a countably infinite set, let <fr:tex
display="inline"><![CDATA[E\subseteq  A]]></fr:tex> be infinite. Then <fr:tex
display="inline"><![CDATA[E]]></fr:tex> is countable.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>488</fr:anchor><fr:addr
type="machine">#259</fr:addr><fr:route>unstable-259.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is countably infinite, we can enumerate its elements as a sequence <fr:tex
display="inline"><![CDATA[x_{n}]]></fr:tex>.</fr:p>
<fr:p>We can construct a sequence <fr:tex
display="inline"><![CDATA[(n_{k})]]></fr:tex> of positive integers such that <fr:tex
display="inline"><![CDATA[x_{n_{k}}\in  E]]></fr:tex>.</fr:p>
<fr:p>Then we have the sequence <fr:tex
display="inline"><![CDATA[f(k)=x_{n_{k}}]]></fr:tex> which enumerates the elements of <fr:tex
display="inline"><![CDATA[E]]></fr:tex>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>490</fr:anchor><fr:addr
type="user">nst-001Y</fr:addr><fr:route>nst-001Y.xml</fr:route><fr:title
text="Cantor's diagonal argument">Cantor's diagonal argument</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Theorem 2.12</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[E_{n}]]></fr:tex> be a countable collection of countably infinite sets. Then
<fr:tex
display="block"><![CDATA[S=\bigcup ^{\infty }_{n=1}E_{n}]]></fr:tex>
is countably infinite.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>492</fr:anchor><fr:addr
type="machine">#258</fr:addr><fr:route>unstable-258.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For each <fr:tex
display="inline"><![CDATA[n\in \mathbb {N}]]></fr:tex>, let us form a sequence <fr:tex
display="inline"><![CDATA[(x_{n,k})]]></fr:tex> of elements of <fr:tex
display="inline"><![CDATA[E_{n}]]></fr:tex>. Then we arrange these sequences into an infinite table
<fr:tex
display="block"><![CDATA[\begin {matrix} x_{1,1} & x_{1,2} & x_{1,3} & x_{1,4} & \ldots \\ x_{2,1} & x_{2,2} & x_{2,3} & x_{2,4} & \ldots \\ x_{3,1} & x_{3,2} & x_{3,3} & x_{3,4} & \ldots \\ x_{4,1} & x_{4,2} & x_{4,3} & x_{4,4} & \ldots \\ \vdots  & \vdots  & \vdots  & \vdots  & \ddots  \end {matrix}]]></fr:tex>
Then we form a sequence by ordering the table as <fr:tex
display="inline"><![CDATA[x_{1,1}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{2,1}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{1,2}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{3,1}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{2,2}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{1,3}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{4,1}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{3,2}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{2,3}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{1,4}]]></fr:tex>, …, where we remove duplicate entries as they are encountered. This gives us a countably infinite sequence of <fr:tex
display="inline"><![CDATA[S]]></fr:tex>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>494</fr:anchor><fr:addr
type="user">nst-001Z</fr:addr><fr:route>nst-001Z.xml</fr:route><fr:title
text="{Q} is countable"><fr:tex
display="inline"><![CDATA[\mathbb {Q}]]></fr:tex> is countable</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Corollary to Theorem 2.13</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>The set of rational numbers is countably infinite.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>466</fr:anchor><fr:addr
type="machine">#257</fr:addr><fr:route>unstable-257.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We form the countably infinite family <fr:tex
display="inline"><![CDATA[E_{n}=\{z/n\in \mathbb {Q}\mid  z\in \mathbb {Z},\gcd (z,n)=1\}]]></fr:tex> where <fr:tex
display="inline"><![CDATA[n\in \mathbb {N}]]></fr:tex> is a positive integer. Each member is bijective with the integers, which is countably infinite. Then
<fr:tex
display="block"><![CDATA[S=\bigcup ^{\infty }_{n=1}E_{n}]]></fr:tex>
is countably infinite by <fr:link
type="local"
href="nst-001Y.xml"
addr="nst-001Y"
title="Cantor's diagonal argument">Cantor's diagonal argument</fr:link>, and <fr:tex
display="inline"><![CDATA[S]]></fr:tex> bijective to the set <fr:tex
display="inline"><![CDATA[\mathbb {Q}]]></fr:tex>. Hence <fr:tex
display="inline"><![CDATA[\mathbb {Q}]]></fr:tex> is countably infinite.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>496</fr:anchor><fr:addr
type="user">nst-0020</fr:addr><fr:route>nst-0020.xml</fr:route><fr:title
text="Set of all sequences of 0,1 is uncountable">Set of all sequences of <fr:tex
display="inline"><![CDATA[\{0,1\}]]></fr:tex> is uncountable</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Theorem 2.14</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> be the set of all sequences of <fr:tex
display="inline"><![CDATA[\{0,1\}]]></fr:tex>. Then the set <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is uncountable.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>498</fr:anchor><fr:addr
type="machine">#255</fr:addr><fr:route>unstable-255.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[E]]></fr:tex> be any countable subset of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>. Let us enumerate the elements of <fr:tex
display="inline"><![CDATA[E]]></fr:tex> into a sequence <fr:tex
display="inline"><![CDATA[x_{n}]]></fr:tex>. We can construct the sequence <fr:tex
display="inline"><![CDATA[x]]></fr:tex> as follows:
<fr:tex
display="block"><![CDATA[x(n) = \begin {cases}1 & \hbox {if }x_{n}(n)=0\\ 0 & \hbox {if }x_{n}(n)=1\end {cases}]]></fr:tex>
Then <fr:tex
display="inline"><![CDATA[x(n)\neq  x_{n}(n)]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[n\in \mathbb {N}]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[x]]></fr:tex> differs from every element of <fr:tex
display="inline"><![CDATA[E]]></fr:tex>, so <fr:tex
display="inline"><![CDATA[x\in  A\setminus  E]]></fr:tex>.</fr:p>
<fr:p>This means every countably infinite subset of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is a proper subset. This means <fr:tex
display="inline"><![CDATA[A]]></fr:tex> must be uncountable since otherwise it would be a proper subset of itself, which is impossible.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 

 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>500</fr:anchor><fr:addr
type="machine">#256</fr:addr><fr:route>unstable-256.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>This implies <fr:tex
display="inline"><![CDATA[\mathbb {R}]]></fr:tex> is uncountable since <fr:tex
display="inline"><![CDATA[A]]></fr:tex> contains the binary expansion of all real numbers between 0 and 1.</fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>502</fr:anchor><fr:addr
type="user">nst-0021</fr:addr><fr:route>nst-0021.xml</fr:route><fr:title
text="Transitive set">Transitive set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#V1">ordinal1:def 2</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We say <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Transitive</html:dfn> if for all sets <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\subseteq  X]]></fr:tex>. In other words, if <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y\in  X]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[y\in  X]]></fr:tex>. So <fr:tex
display="inline"><![CDATA[\in ]]></fr:tex> forms a transitive relation on <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>504</fr:anchor><fr:addr
type="user">nst-0022</fr:addr><fr:route>nst-0022.xml</fr:route><fr:title
text="Connected set">Connected set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#V2">ordinal1:def 3</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We say <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Connected</html:dfn> if for all sets <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y\in  X]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[x\notin  y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x\neq  y]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[y\in  x]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>506</fr:anchor><fr:addr
type="user">nst-0023</fr:addr><fr:route>nst-0023.xml</fr:route><fr:title
text="Ordinal number">Ordinal number</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#V3">ordinal1:def 4</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>We say a set <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is an <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Ordinal</html:dfn> if <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is <fr:link
type="local"
href="nst-0021.xml"
addr="nst-0021"
title="Transitive set">Transitive set</fr:link> and also <fr:link
type="local"
href="nst-0022.xml"
addr="nst-0022"
title="Connected set">Connected set</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>508</fr:anchor><fr:addr
type="user">nst-0024</fr:addr><fr:route>nst-0024.xml</fr:route><fr:title
text="Successor">Successor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#K1">ordinal1:def 1</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Successor</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to be the set <fr:tex
display="block"><![CDATA[\mathop {\textrm {S}}\nolimits (X):=X\cup \{X\}.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>510</fr:anchor><fr:addr
type="user">nst-0025</fr:addr><fr:route>nst-0025.xml</fr:route><fr:title
text="Successor of ordinal is an ordinal">Successor of ordinal is an ordinal</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#T17">ordinal1:17</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be an <fr:link
type="local"
href="nst-0023.xml"
addr="nst-0023"
title="Ordinal number">Ordinal number</fr:link>. Then <fr:tex
display="inline"><![CDATA[\mathop {\textrm {S}}\nolimits (X)]]></fr:tex> is an <fr:link
type="local"
href="nst-0023.xml"
addr="nst-0023"
title="Ordinal number">Ordinal number</fr:link>, too.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>512</fr:anchor><fr:addr
type="user">nst-0026</fr:addr><fr:route>nst-0026.xml</fr:route><fr:title
text="Union of ordinal is an ordinal">Union of ordinal is an ordinal</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#T18">ordinal1:18</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be an <fr:link
type="local"
href="nst-0023.xml"
addr="nst-0023"
title="Ordinal number">Ordinal number</fr:link>. Then <fr:tex
display="inline"><![CDATA[\bigcup  X]]></fr:tex> is an <fr:link
type="local"
href="nst-0023.xml"
addr="nst-0023"
title="Ordinal number">Ordinal number</fr:link>, too.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>514</fr:anchor><fr:addr
type="user">nst-0027</fr:addr><fr:route>nst-0027.xml</fr:route><fr:title
text="Limit ordinal">Limit ordinal</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#V4">ordinal1:def 6</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> be a set. We say <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Limit Ordinal</html:dfn> if <fr:tex
display="inline"><![CDATA[A=\bigcup  A]]></fr:tex>.</fr:p><fr:p>Note: this means that <fr:tex
display="inline"><![CDATA[\emptyset ]]></fr:tex> is a limit ordinal.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>516</fr:anchor><fr:addr
type="user">nst-0028</fr:addr><fr:route>nst-0028.xml</fr:route><fr:title
text="Criteria for limit ordinal">Criteria for limit ordinal</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#T28">ordinal1:28</fr:link></fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#T29">ordinal1:29</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> be an ordinal number. Then the following are equivalent:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[A]]></fr:tex> is a <fr:link
type="local"
href="nst-0027.xml"
addr="nst-0027"
title="Limit ordinal">Limit ordinal</fr:link></fr:li>
<fr:li>for each ordinal <fr:tex
display="inline"><![CDATA[C\in  A]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[\mathop {\textrm {S}}\nolimits (C)\in  A]]></fr:tex></fr:li>
<fr:li>there is no ordinal <fr:tex
display="inline"><![CDATA[B]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[A=\mathop {\textrm {S}}\nolimits (B)]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>518</fr:anchor><fr:addr
type="user">nst-0029</fr:addr><fr:route>nst-0029.xml</fr:route><fr:title
text=" (the set of all finite ordinals)"><fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> (the set of all finite ordinals)</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#K4">ordinal1:def 11</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>We define <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> to be the ordinal such that:
<fr:ol><fr:li>contains zero: <fr:tex
display="inline"><![CDATA[\emptyset \in \omega ]]></fr:tex>, and</fr:li>
<fr:li>limit: <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> is a <fr:link
type="local"
href="nst-0027.xml"
addr="nst-0027"
title="Limit ordinal">Limit ordinal</fr:link></fr:li>
<fr:li>smallest such ordinal: for any other ordinal <fr:tex
display="inline"><![CDATA[A]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\emptyset \in  A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is a <fr:link
type="local"
href="nst-0027.xml"
addr="nst-0027"
title="Limit ordinal">Limit ordinal</fr:link>, we have <fr:tex
display="inline"><![CDATA[\omega \subseteq  A]]></fr:tex>.</fr:li></fr:ol></fr:p><fr:p>This is the set theoretic construction of the natural numbers, where <fr:tex
display="inline"><![CDATA[0]]></fr:tex> is identified as <fr:tex
display="inline"><![CDATA[\emptyset ]]></fr:tex>, and for any <fr:tex
display="inline"><![CDATA[n\in \omega ]]></fr:tex> we identify <fr:tex
display="inline"><![CDATA[n+1]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\mathop {\textrm {S}}\nolimits (n)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>520</fr:anchor><fr:addr
type="user">nst-002C</fr:addr><fr:route>nst-002C.xml</fr:route><fr:title
text="There is no set of all ordinals">There is no set of all ordinals</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/card_1.html#T25">card_1:25</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>There is no set <fr:tex
display="inline"><![CDATA[X]]></fr:tex> such that for all ordinals <fr:tex
display="inline"><![CDATA[A]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[A\in  X]]></fr:tex>. In other words, there is no set of all ordinal numbers.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>522</fr:anchor><fr:addr
type="machine">#253</fr:addr><fr:route>unstable-253.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Assume for contradiction that <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a set such that for all ordinals <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[A\in  X]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is <fr:link
type="local"
href="nst-0021.xml"
addr="nst-0021"
title="Transitive set">Transitive set</fr:link> and <fr:link
type="local"
href="nst-0022.xml"
addr="nst-0022"
title="Connected set">Connected set</fr:link>, which implies <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is an <fr:link
type="local"
href="nst-0023.xml"
addr="nst-0023"
title="Ordinal number">Ordinal number</fr:link>. Then <fr:tex
display="inline"><![CDATA[X\in  X]]></fr:tex>, which is impossible.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 

 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>524</fr:anchor><fr:addr
type="machine">#254</fr:addr><fr:route>unstable-254.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>"The collection of all ordinal numbers" is another example of a <fr:link
type="local"
href="nst-001P.xml"
addr="nst-001P"
title="Classes">proper class</fr:link>.</fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>526</fr:anchor><fr:addr
type="user">nst-002A</fr:addr><fr:route>nst-002A.xml</fr:route><fr:title
text="Cardinal number">Cardinal number</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/card_1.html#V1">card_1:def 1</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> be an <fr:link
type="local"
href="nst-0023.xml"
addr="nst-0023"
title="Ordinal number">Ordinal number</fr:link>. We say <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Cardinal number</html:dfn> if for every ordinal <fr:tex
display="inline"><![CDATA[B]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is bijective to <fr:tex
display="inline"><![CDATA[B]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[A\subseteq  B]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>528</fr:anchor><fr:addr
type="user">nst-002B</fr:addr><fr:route>nst-002B.xml</fr:route><fr:title
text="Cardinality of a set">Cardinality of a set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/card_1.html#K1">card_1:def 2</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Cardinality</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to be the <fr:link
type="local"
href="nst-002A.xml"
addr="nst-002A"
title="Cardinal number">Cardinal number</fr:link> <fr:tex
display="inline"><![CDATA[|X|]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is equipotent with <fr:tex
display="inline"><![CDATA[|X|]]></fr:tex>.</fr:p><fr:p>So the cardinality of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is the smallest <fr:link
type="local"
href="nst-0023.xml"
addr="nst-0023"
title="Ordinal number">Ordinal number</fr:link> bijective with <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p><fr:p>Usually, we only care if <fr:tex
display="inline"><![CDATA[|X|]]></fr:tex> is finite or not.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>