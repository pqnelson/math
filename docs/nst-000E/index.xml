<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>12</fr:month>
      <fr:day>9</fr:day>
    </fr:date>
    <fr:uri>http://localhost:8000/nst-000E/</fr:uri>
    <fr:display-uri>nst-000E</fr:display-uri>
    <fr:route>/nst-000E/</fr:route>
    <fr:title text="Basic properties of union of two sets">Basic properties of union of two sets</fr:title>
    <fr:taxon>theorem</fr:taxon>
    <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.4</fr:meta>
    <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/boole.html#T1" type="external">boole:th1</fr:link></fr:meta>
    <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T4" type="external">xboole_1:th4</fr:link></fr:meta>
    <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T12" type="external">xboole_1:th12</fr:link></fr:meta>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex>, <fr:tex display="inline"><![CDATA[B]]></fr:tex>, <fr:tex display="inline"><![CDATA[C]]></fr:tex> be arbitrary sets. Then the following all hold:</html:p>
    <html:ol><html:li><fr:tex display="inline"><![CDATA[A\cup \emptyset =A]]></fr:tex></html:li>
<html:li>Associativity: <fr:tex display="inline"><![CDATA[A\cup (B\cup  C)=(A\cup  B)\cup  C]]></fr:tex></html:li>
<html:li><fr:tex display="inline"><![CDATA[A\subseteq  B]]></fr:tex> iff <fr:tex display="inline"><![CDATA[A\cup  B=B]]></fr:tex></html:li></html:ol>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000P/</fr:uri>
            <fr:display-uri>nst-000P</fr:display-uri>
            <fr:route>/nst-000P/</fr:route>
            <fr:title text="Basic concepts and constructions of naive set theory">Basic concepts and constructions of naive set theory</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-002H/</fr:uri>
                <fr:display-uri>nst-002H</fr:display-uri>
                <fr:route>/nst-002H/</fr:route>
                <fr:title text="Proof strategies">Proof strategies</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>There are various common "strategies" for proving various claims in Mathematics. We will review the basic strategies here.</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>http://localhost:8000/nst-002G/</fr:uri>
                    <fr:display-uri>nst-002G</fr:display-uri>
                    <fr:route>/nst-002G/</fr:route>
                    <fr:title text="Direct proof">Direct proof</fr:title>
                    <fr:taxon>proof strategy</fr:taxon>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>When trying to prove a claim of the form "If <fr:tex display="inline"><![CDATA[P]]></fr:tex>, then <fr:tex display="inline"><![CDATA[Q]]></fr:tex>", a direct proof has the following skeleton:</html:p>
  <html:blockquote>Assume <fr:tex display="inline"><![CDATA[P]]></fr:tex>. [Intermediate proof steps] Thus <fr:tex display="inline"><![CDATA[Q]]></fr:tex>.</html:blockquote>
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>http://localhost:8000/nst-002I/</fr:uri>
                    <fr:display-uri>nst-002I</fr:display-uri>
                    <fr:route>/nst-002I/</fr:route>
                    <fr:title text="Proof by contrapositive">Proof by contrapositive</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter><html:p>We can take advantage of the fact that "If <fr:tex display="inline"><![CDATA[P]]></fr:tex> then <fr:tex display="inline"><![CDATA[Q]]></fr:tex>" has the same truth table as "If not <fr:tex display="inline"><![CDATA[Q]]></fr:tex>, then not <fr:tex display="inline"><![CDATA[P]]></fr:tex>". This "Not <fr:tex display="inline"><![CDATA[Q]]></fr:tex> implies not <fr:tex display="inline"><![CDATA[P]]></fr:tex>" is called the <html:dfn>Contrapositive</html:dfn> of "<fr:tex display="inline"><![CDATA[P]]></fr:tex> implies <fr:tex display="inline"><![CDATA[Q]]></fr:tex>". Usually we embark on a <fr:link href="/nst-002G/" title="Direct proof" uri="http://localhost:8000/nst-002G/" display-uri="nst-002G" type="local">Direct proof</fr:link> and so the proof looks like:</html:p>
  <html:blockquote>Assume not <fr:tex display="inline"><![CDATA[Q]]></fr:tex>. [Intermediate proof steps.] Hence not <fr:tex display="inline"><![CDATA[P]]></fr:tex>.</html:blockquote>
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>http://localhost:8000/nst-002J/</fr:uri>
                    <fr:display-uri>nst-002J</fr:display-uri>
                    <fr:route>/nst-002J/</fr:route>
                    <fr:title text="Proof by contradiction">Proof by contradiction</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>When trying to prove the claim <fr:tex display="inline"><![CDATA[P]]></fr:tex>, it is useful to use the fact that its double negation "Not (not <fr:tex display="inline"><![CDATA[P]]></fr:tex>)" is logically equivalent to <fr:tex display="inline"><![CDATA[P]]></fr:tex>, and then use the fact  that "Not <fr:tex display="inline"><![CDATA[Q]]></fr:tex>" is logically equivalent to "If <fr:tex display="inline"><![CDATA[Q]]></fr:tex> then contradiction". Taken together, <fr:tex display="inline"><![CDATA[P]]></fr:tex> is logically equivalent to "If not <fr:tex display="inline"><![CDATA[P]]></fr:tex>, then contradiction." This is a proof by contradiction.</html:p>
                    <html:p>When <fr:tex display="inline"><![CDATA[P]]></fr:tex> is an implication "If <fr:tex display="inline"><![CDATA[H]]></fr:tex> then <fr:tex display="inline"><![CDATA[R]]></fr:tex>", a proof by contradiction looks like "If <fr:tex display="inline"><![CDATA[H]]></fr:tex> and not <fr:tex display="inline"><![CDATA[R]]></fr:tex>, then contradiction".</html:p>
                  </fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>12</fr:month>
                      <fr:day>15</fr:day>
                    </fr:date>
                    <fr:uri>http://localhost:8000/nst-002K/</fr:uri>
                    <fr:display-uri>nst-002K</fr:display-uri>
                    <fr:route>/nst-002K/</fr:route>
                    <fr:title text="Proof by induction">Proof by induction</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
                    <html:p>If we have a claim which is a formula indexed by natural numbers <fr:tex display="inline"><![CDATA[P[n]]]></fr:tex>, then a proof by induction on <fr:tex display="inline"><![CDATA[n]]></fr:tex> looks like:</html:p>
                    <html:ol><html:li><html:strong>Base case:</html:strong> For <fr:tex display="inline"><![CDATA[n=0]]></fr:tex> (or <fr:tex display="inline"><![CDATA[n=1]]></fr:tex>), prove <fr:tex display="inline"><![CDATA[P[0]]]></fr:tex> (resp., <fr:tex display="inline"><![CDATA[P[1]]]></fr:tex>).</html:li>
<html:li><html:strong>Inductive argument:</html:strong> For arbitrary <fr:tex display="inline"><![CDATA[n]]></fr:tex>, prove the claim "If <fr:tex display="inline"><![CDATA[P[n]]]></fr:tex> then <fr:tex display="inline"><![CDATA[P[n+1]]]></fr:tex>". Usually this is done by a <fr:link href="/nst-002G/" title="Direct proof" uri="http://localhost:8000/nst-002G/" display-uri="nst-002G" type="local">Direct proof</fr:link> and we call the statement "Assume <fr:tex display="inline"><![CDATA[P[n]]]></fr:tex>" the <html:dfn>Inductive Hypothesis</html:dfn>.</html:li></html:ol>
                  </fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000R/</fr:uri>
                <fr:display-uri>nst-000R</fr:display-uri>
                <fr:route>/nst-000R/</fr:route>
                <fr:title text="Ontology of Mathematics">Ontology of Mathematics</fr:title>
                <fr:taxon>remark</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>What are the basic "things" we work with in Mathematics? It may seem that we have numbers, functions, and quite possibly other objects.</html:p><html:p>Broadly speaking, we could describe Mathematics as working with "sets" (unordered collections of stuff) and "objects" (any generic term or object).</html:p><html:p>In practice, there are compelling reasons to stipulate that <html:em>everything</html:em> in Mathematics consists of sets. This should be understood as saying that sets form the "machine code" of Mathematics. This is explicitly stated in Bourbaki's <fr:link href="/bourbaki-1968-theory/" title="Theory of Sets" uri="http://localhost:8000/bourbaki-1968-theory/" display-uri="bourbaki-1968-theory" type="local">Theory of Sets</fr:link>, II §1.1 (bottom of page 65 of English edition):</html:p>
  <html:blockquote><html:p>From a "naive" point of view, many mathematical entities can be formalized as collections or "sets" of objects. We do not seek to formalize this notion, and in the formalistic interpretation of what follows, the word "set" is to be considered as strictly synonymous with "term".</html:p></html:blockquote>
<html:p>We will just stipulate that everything in Mathematics may be considered as an instance of some abstract type we call an "object". We extend this with a subtype called a "set". All sets are objects.</html:p><html:p>But some Mathematicians want to discuss the collection of all sets. This can't possibly be a set (otherwise we run into Russell's paradox), so we need to either modify our ontology (and work with "classes" instead of "sets", and call a class a "set" when it's a member of a class) or extend our ontology (to include a "class" as a third species of object). We will discuss this when the time comes, but the ontology is mildly flexible.</html:p></fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-0001/</fr:uri>
                <fr:display-uri>nst-0001</fr:display-uri>
                <fr:route>/nst-0001/</fr:route>
                <fr:title text="Set">Set</fr:title>
                <fr:taxon>provisional definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>We [pretend to] define a [naive] <html:dfn>Set</html:dfn> to be a well-defined unordered collection of objects.</html:p>
                <html:p>If <fr:tex display="inline"><![CDATA[x]]></fr:tex> is an object and <fr:tex display="inline"><![CDATA[X]]></fr:tex> is a set, then we write <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> if <fr:tex display="inline"><![CDATA[x]]></fr:tex> is an element (or member) of <fr:tex display="inline"><![CDATA[X]]></fr:tex>. If <fr:tex display="inline"><![CDATA[x]]></fr:tex> is not an element of <fr:tex display="inline"><![CDATA[X]]></fr:tex>, then we write <fr:tex display="inline"><![CDATA[x\notin  X]]></fr:tex>.</html:p>
                <html:p>We will also write <fr:tex display="inline"><![CDATA[X\ni  x]]></fr:tex> as a synonym for <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex>. We also write <fr:tex display="inline"><![CDATA[X\not \ni  x]]></fr:tex>.</html:p>
                <html:p>This isn't really a definition, because set theory is given axiomatically. We usually give axioms to specify the behaviour of the binary infixed predicate <fr:tex display="inline"><![CDATA[\in ]]></fr:tex>.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000C/</fr:uri>
                <fr:display-uri>nst-000C</fr:display-uri>
                <fr:route>/nst-000C/</fr:route>
                <fr:title text="Proving well-definedness of terms">Proving well-definedness of terms</fr:title>
                <fr:taxon>remark</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>When we define a new term in Mathematics, we should prove it is well-defined. What this proof requires depends on what we're defining.</html:p>
                <html:ul><html:li>A new constant (possibly parametrized by other objects) <fr:tex display="inline"><![CDATA[C]]></fr:tex> defined as satisfying some condition <fr:tex display="inline"><![CDATA[\Phi [C]]]></fr:tex> requires proving (1) its existence (i.e, proving <fr:tex display="inline"><![CDATA[\exists  x\ldotp \Phi [x]]]></fr:tex>), and (2) its uniqueness (i.e., <fr:tex display="inline"><![CDATA[\forall  x,y\ldotp \Phi [x]\land \Phi [y]\implies  x=y]]></fr:tex>).</html:li>
<html:li>A new constant <fr:tex display="inline"><![CDATA[C]]></fr:tex> which is defined as abbreviating some complicated expression is usually well-defined, sometimes we need to prove it has the "correct type".</html:li>
<html:li>A new species of thing (like a vector space or a <fr:link href="/field-0001/" title="Field" uri="http://localhost:8000/field-0001/" display-uri="field-0001" type="local">Field</fr:link>) should require proving the existence of at least one such gadget.</html:li>
<html:li>All other types of definitions (predicates, adjectives, etc.) are well-defined.</html:li></html:ul>
                <html:p>One of the reasons why the <fr:link href="/nst-0001/" title="Set" uri="http://localhost:8000/nst-0001/" display-uri="nst-0001" type="local">"definition" of a set</fr:link> is not really a definition is because we should prove the existence of a set, but that's not possible. It's also why Mathematicians invented <html:em>axiomatic</html:em> set theory: presumably there are mathematical objects called "sets" which already exist, and we're trying to specify their behaviour (or some reasonable approximation) using axioms.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000U/</fr:uri>
                <fr:display-uri>nst-000U</fr:display-uri>
                <fr:route>/nst-000U/</fr:route>
                <fr:title text="Examples of common sets">Examples of common sets</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>We have some very common sets encountered in Mathematics, so we have special notation for them:</html:p>
                <html:ul><html:li><fr:tex display="inline"><![CDATA[\mathbb {N}_{0}=\{0,1,2,3,…\}]]></fr:tex> the set of all non-negative integers</html:li>
<html:li><fr:tex display="inline"><![CDATA[\mathbb {N}=\{1,2,3,4,…\}]]></fr:tex> the set of all positive integers</html:li>
<html:li><fr:tex display="inline"><![CDATA[\mathbb {Z}=\{…,-3,-2,-1,0,1,2,3,…\}]]></fr:tex> the set of all integers</html:li>
<html:li><fr:tex display="inline"><![CDATA[\mathbb {Q}=\{\frac {m}{n}\mid  m\in \mathbb {Z},n\in \mathbb {N}]]></fr:tex> the set of all rational numbers</html:li>
<html:li><fr:tex display="inline"><![CDATA[\mathbb {R}]]></fr:tex> the set of real numbers</html:li>
<html:li><fr:tex display="inline"><![CDATA[\mathbb {C}=\{x+\mathrm {i} y\mid  x,y\in \mathbb {R}\}]]></fr:tex> the set of complex numbers</html:li></html:ul>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-0002/</fr:uri>
                <fr:display-uri>nst-0002</fr:display-uri>
                <fr:route>/nst-0002/</fr:route>
                <fr:title text="Finite sets">Finite sets</fr:title>
                <fr:taxon>notation</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>If we have a set consisting of finitely many elements, we write it out as a comma-separated list delimited by <fr:tex display="inline"><![CDATA[\{…\}]]></fr:tex>.</html:p>
                <html:p>For example, the set of prime numbers less than 10 is <fr:tex display="inline"><![CDATA[\{2,3,5,7\}]]></fr:tex>.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-0003/</fr:uri>
                <fr:display-uri>nst-0003</fr:display-uri>
                <fr:route>/nst-0003/</fr:route>
                <fr:title text="Empty set">Empty set</fr:title>
                <fr:taxon>definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be a set. We say <fr:tex display="inline"><![CDATA[X]]></fr:tex> is <html:dfn>Empty</html:dfn> if there is no object <fr:tex display="inline"><![CDATA[x]]></fr:tex> such that <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex>.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-0004/</fr:uri>
                <fr:display-uri>nst-0004</fr:display-uri>
                <fr:route>/nst-0004/</fr:route>
                <fr:title text="Set equality">Set equality</fr:title>
                <fr:taxon>definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the predicate <html:dfn>Set Equality</html:dfn> (or just <html:em>equality</html:em>) of <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex>, denoted <fr:tex display="inline"><![CDATA[X=Y]]></fr:tex>, to mean they have the same elements; i.e., for all objects <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> if and only if <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>.</html:p>
                <html:p>When <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> are not equal, we write <fr:tex display="inline"><![CDATA[X\neq  Y]]></fr:tex>.</html:p>
                <html:p>(This is technically an axiom of ZFC called the "axiom of extensionality".)</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-0005/</fr:uri>
                <fr:display-uri>nst-0005</fr:display-uri>
                <fr:route>/nst-0005/</fr:route>
                <fr:title text="The empty set">The empty set</fr:title>
                <fr:taxon>definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>We define <html:em>the</html:em> empty set to be the constant denoted <fr:tex display="inline"><![CDATA[\emptyset ]]></fr:tex> (or sometimes <fr:tex display="inline"><![CDATA[\{\}]]></fr:tex>).</html:p><html:p>We need to prove this is well-defined. For constants, this means proving it exists and is unique.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><html:strong>Existence:</html:strong> Take the empty list as a set <fr:tex display="inline"><![CDATA[\{\}]]></fr:tex>. This is clearly empty.</html:p>

<html:p><html:strong>Uniqueness:</html:strong> Suppose we have <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> both be empty sets. We want to prove <fr:tex display="inline"><![CDATA[X=Y]]></fr:tex>. Then for any object <fr:tex display="inline"><![CDATA[x]]></fr:tex>, we want to prove (1) if <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> then <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>, and (2) if <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex> then <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex>.</html:p>

<html:p>(1) <fr:link href="/nst-002J/" title="Proof by contradiction" uri="http://localhost:8000/nst-002J/" display-uri="nst-002J" type="local">Proof by contradiction</fr:link>. Assume <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex>. But <fr:tex display="inline"><![CDATA[X]]></fr:tex> is <fr:link href="/nst-0004/" title="Set equality" uri="http://localhost:8000/nst-0004/" display-uri="nst-0004" type="local">empty</fr:link>, so <fr:tex display="inline"><![CDATA[X]]></fr:tex> cannot have any members. Then we have a contradiction. Hence we can conclude whatever we want, in particular <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>.</html:p>

<html:p>(2) The argument is the same but switching <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex>.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-0006/</fr:uri>
                <fr:display-uri>nst-0006</fr:display-uri>
                <fr:route>/nst-0006/</fr:route>
                <fr:title text="Subset">Subset</fr:title>
                <fr:taxon>definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the predicate <fr:tex display="inline"><![CDATA[X\subseteq  Y]]></fr:tex> to mean: for any object <fr:tex display="inline"><![CDATA[x]]></fr:tex>, if <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> then <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>. In other words, all elements of <fr:tex display="inline"><![CDATA[X]]></fr:tex> are also elements of <fr:tex display="inline"><![CDATA[Y]]></fr:tex>. (This is very different than <fr:tex display="inline"><![CDATA[X]]></fr:tex> is an element of <fr:tex display="inline"><![CDATA[Y]]></fr:tex>!)</html:p>
                <html:p>We write <fr:tex display="inline"><![CDATA[Y\supseteq  X]]></fr:tex> as a synonym for <fr:tex display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>.</html:p>
                <html:p>We also write <fr:tex display="inline"><![CDATA[X\nsubseteq  Y]]></fr:tex> as the antonym for <fr:tex display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>, and <fr:tex display="inline"><![CDATA[Y\nsupseteq  X]]></fr:tex> for the antonym of <fr:tex display="inline"><![CDATA[Y\supseteq  X]]></fr:tex>.</html:p>
                <html:p>Observe that <fr:tex display="inline"><![CDATA[X\subseteq  X]]></fr:tex> for any set <fr:tex display="inline"><![CDATA[X]]></fr:tex>.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-0007/</fr:uri>
                <fr:display-uri>nst-0007</fr:display-uri>
                <fr:route>/nst-0007/</fr:route>
                <fr:title text="Proper subset">Proper subset</fr:title>
                <fr:taxon>definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the predicate <fr:tex display="inline"><![CDATA[X\subset  Y]]></fr:tex> to mean <fr:tex display="inline"><![CDATA[X\subseteq  Y]]></fr:tex> and <fr:tex display="inline"><![CDATA[X\neq  Y]]></fr:tex>.</html:p>
                <html:p>We also have the synonym <fr:tex display="inline"><![CDATA[Y\supset  X]]></fr:tex> for <fr:tex display="inline"><![CDATA[X\subset  Y]]></fr:tex>.</html:p>
                <html:p>The choice of notation varies wildly. Some authors do not even distinguish proper subsets from "improper" subsets. Worse, some use <fr:tex display="inline"><![CDATA[\subset ]]></fr:tex> for improper subsets. We have chosen to use notation analogous to <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\lt ]]></fr:tex>.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-0008/</fr:uri>
                <fr:display-uri>nst-0008</fr:display-uri>
                <fr:route>/nst-0008/</fr:route>
                <fr:title text="Proving two sets are equal">Proving two sets are equal</fr:title>
                <fr:taxon>strategy</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Generically, when we want to prove <fr:link href="/nst-0004/" title="Set equality" uri="http://localhost:8000/nst-0004/" display-uri="nst-0004" type="local">Set equality</fr:link> like proving <fr:tex display="inline"><![CDATA[X=Y]]></fr:tex>, we can use the <fr:link href="/nst-0006/" title="Subset" uri="http://localhost:8000/nst-0006/" display-uri="nst-0006" type="local">Subset</fr:link> predicate to prove two claims: (1) <fr:tex display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>, (2) <fr:tex display="inline"><![CDATA[Y\subseteq  X]]></fr:tex>.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-0009/</fr:uri>
                <fr:display-uri>nst-0009</fr:display-uri>
                <fr:route>/nst-0009/</fr:route>
                <fr:title text="Set builder notation">Set builder notation</fr:title>
                <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.2</fr:meta>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>There are times when the notation for <fr:link href="/nst-0002/" title="Finite sets" uri="http://localhost:8000/nst-0002/" display-uri="nst-0002" type="local">Finite sets</fr:link> is clunky or impractical (e.g., write out the first <fr:tex display="inline"><![CDATA[10^{120}]]></fr:tex> prime numbers). We have another notation for describing a set: if <fr:tex display="inline"><![CDATA[P[x]]]></fr:tex> is a unary predicate and <fr:tex display="inline"><![CDATA[X]]></fr:tex> is a set, then we write
<fr:tex display="block"><![CDATA[\{x\in  X\mid  P[x]\}]]></fr:tex>
which describes "The set of <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> such that <fr:tex display="inline"><![CDATA[P[x]]]></fr:tex> holds". The vertical bar ("|") is read "such that". The allowable predicates <fr:tex display="inline"><![CDATA[P[-]]]></fr:tex> must form a valid <fr:link href="/nst-000A/" title="Sentences in set theory" uri="http://localhost:8000/nst-000A/" display-uri="nst-000A" type="local">sentence</fr:link>. (This form of set builder notation is called "the axiom scheme of specification" in ZFC set theory.)</html:p>
                <html:p>The other form of set builder notation which appears frequently: if <fr:tex display="inline"><![CDATA[F(-)]]></fr:tex> is some construction, and <fr:tex display="inline"><![CDATA[P[-]]]></fr:tex> is a unary predicate, and <fr:tex display="inline"><![CDATA[X]]></fr:tex> is a set, then
<fr:tex display="block"><![CDATA[\{F(x)\mid  x\in  X,P[x]\}]]></fr:tex>
describes the set obtained by applying <fr:tex display="inline"><![CDATA[F]]></fr:tex> to each element of <fr:tex display="inline"><![CDATA[X]]></fr:tex> which satisfies the predicate <fr:tex display="inline"><![CDATA[P]]></fr:tex>.</html:p>
                <html:p>The Working Mathematician usually "suppresses" (omits) the <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> clause when it is understood.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000A/</fr:uri>
                <fr:display-uri>nst-000A</fr:display-uri>
                <fr:route>/nst-000A/</fr:route>
                <fr:title text="Sentences in set theory">Sentences in set theory</fr:title>
                <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.2</fr:meta>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>The allowed sentences or predicates appearing in set builder notation may be described recursively.</html:p>
                <html:p>We can describe what possible formulas appear using the following:</html:p>
                <html:ul><html:li><fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex display="inline"><![CDATA[X=Y]]></fr:tex> are the atomic formulas</html:li>
<html:li>"not &lt;formula&gt;"</html:li>
<html:li>"&lt;formula&gt; and &lt;formula&gt;" or just a comma-separated list of formulas, all of which are expected to hold</html:li>
<html:li>"&lt;formula&gt; or &lt;formula&gt;" for the disjunction of formulas (in the sense of "either &lt;formula&gt; or &lt;formula&gt; or both")</html:li>
<html:li>"if &lt;formula&gt; then &lt;formula&gt;" (or "&lt;formula&gt; implies &lt;formula&gt;")</html:li>
<html:li>"&lt;formula&gt; iff &lt;formula&gt;"</html:li>
<html:li>"for all …"</html:li>
<html:li>"for some …" (or "exists …")</html:li></html:ul>
                <html:p>… as well as using any predicates we've defined (like the <fr:link href="/nst-0006/" title="Subset" uri="http://localhost:8000/nst-0006/" display-uri="nst-0006" type="local">Subset</fr:link> predicate).</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-001N/</fr:uri>
                <fr:display-uri>nst-001N</fr:display-uri>
                <fr:route>/nst-001N/</fr:route>
                <fr:title text="Russell's paradox">Russell's paradox</fr:title>
                <fr:taxon>theorem</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Suppose we try defining the set
<fr:tex display="block"><![CDATA[R=\{S\hbox { is a set}\mid  S\notin  S\}.]]></fr:tex>
Then we obtain a contradiction if such a set exists. (The solution is to restrict what set-builder notation.)</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Well, assume <fr:tex display="inline"><![CDATA[R]]></fr:tex> exists. We will prove we obtain a contradiction. Our proof is by cases: either <fr:tex display="inline"><![CDATA[R\in  R]]></fr:tex> or <fr:tex display="inline"><![CDATA[R\notin  R]]></fr:tex>.</html:p>
<html:p><html:strong>Case 1:</html:strong> Assume <fr:tex display="inline"><![CDATA[R\in  R]]></fr:tex>. Then this means <fr:tex display="inline"><![CDATA[R\notin  R]]></fr:tex>. But we have both <fr:tex display="inline"><![CDATA[R\in  R]]></fr:tex> and <fr:tex display="inline"><![CDATA[R\notin  R]]></fr:tex> which is a contradiction.</html:p>
<html:p><html:strong>Case 2:</html:strong> Assume <fr:tex display="inline"><![CDATA[R\notin  R]]></fr:tex>. But this is the defining property for members of <fr:tex display="inline"><![CDATA[R]]></fr:tex>. This implies <fr:tex display="inline"><![CDATA[R\in  R]]></fr:tex>. Again, we have both <fr:tex display="inline"><![CDATA[R\in  R]]></fr:tex> and <fr:tex display="inline"><![CDATA[R\notin  R]]></fr:tex> which is a contradiction.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-001O/</fr:uri>
                <fr:display-uri>nst-001O</fr:display-uri>
                <fr:route>/nst-001O/</fr:route>
                <fr:title text="There is no set of all sets">There is no set of all sets</fr:title>
                <fr:taxon>corollary</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>An immediate consequence of <fr:link href="/nst-001N/" title="Russell's paradox" uri="http://localhost:8000/nst-001N/" display-uri="nst-001N" type="local">Russell's paradox</fr:link> is that there is no set of all sets. If there were a set <fr:tex display="inline"><![CDATA[V]]></fr:tex> of all sets, then <fr:tex display="inline"><![CDATA[V\in  V]]></fr:tex> which leads to problems.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>11</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-001P/</fr:uri>
                <fr:display-uri>nst-001P</fr:display-uri>
                <fr:route>/nst-001P/</fr:route>
                <fr:title text="Classes">Classes</fr:title>
                <fr:taxon>definition</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>We will often informally refer to a <html:dfn>(Proper) Class</html:dfn> as an unordered collection which is "too big" to be a set.</html:p><html:p>For example, the von Neumann universe <fr:tex display="inline"><![CDATA[\mathbf {V}]]></fr:tex> is the proper class of all sets.</html:p><html:p>In practice, we seldom need to work with proper classes directly. The Working Mathematician needs only sets (until we get to Category Theory, but we'll revisit this as needed).</html:p><html:p>The <html:dfn>Axiom of limitation of size</html:dfn> asserts a collection <fr:tex display="inline"><![CDATA[C]]></fr:tex> is a proper class if and only if there exists a surjective function from <fr:tex display="inline"><![CDATA[C]]></fr:tex> to the von Neumann universe <fr:tex display="inline"><![CDATA[\mathbf {V}]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:taxon>remark</fr:taxon></fr:frontmatter><fr:mainmatter>We're playing "fast and loose" with things here, but for a discussion of axiomatic set theory based on classes (using the NBG axioms), see <fr:link href="/taras-banakh/" title="Taras Banakh" uri="http://localhost:8000/taras-banakh/" display-uri="taras-banakh" type="local">Taras Banakh</fr:link>'s <fr:link href="/banakh-2020-classical/" title="Classical Set Theory: Theory of Sets and Classes" uri="http://localhost:8000/banakh-2020-classical/" display-uri="banakh-2020-classical" type="local">Classical Set Theory: Theory of Sets and Classes</fr:link>.</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000B/</fr:uri>
                <fr:display-uri>nst-000B</fr:display-uri>
                <fr:route>/nst-000B/</fr:route>
                <fr:title text="Union of a family of sets">Union of a family of sets</fr:title>
                <fr:taxon>definition</fr:taxon>
                <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.4</fr:meta>
                <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/tarski.html#K3" type="external">tarski:def 4</fr:link></fr:meta>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[F]]></fr:tex> be a family of sets (i.e., set whose elements are sets). We define the <html:dfn>Union</html:dfn> of <fr:tex display="inline"><![CDATA[F]]></fr:tex> to be the set <fr:tex display="inline"><![CDATA[\bigcup  F]]></fr:tex> such that for all objects <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in \bigcup  F]]></fr:tex> iff there is some set <fr:tex display="inline"><![CDATA[X\in  F]]></fr:tex> such that <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex>.</html:p>
                <html:p>This defines a new constant and we should set about to <fr:link href="/nst-000C/" title="Proving well-definedness of terms" uri="http://localhost:8000/nst-000C/" display-uri="nst-000C" type="local">proving it is well-defined</fr:link>, but proving its existence is impossible because it is just stipulated to exist ("axiom of union").</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000D/</fr:uri>
                <fr:display-uri>nst-000D</fr:display-uri>
                <fr:route>/nst-000D/</fr:route>
                <fr:title text="Union of two sets">Union of two sets</fr:title>
                <fr:taxon>definition</fr:taxon>
                <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.4</fr:meta>
                <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xboole_0.html#K2" type="external">xboole_0:def 3</fr:link></fr:meta>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the <html:dfn>Union</html:dfn> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> to be the set <fr:tex display="inline"><![CDATA[X\cup  Y]]></fr:tex> such that for all objects <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in  X\cup  Y]]></fr:tex> iff either <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> or <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>.</html:p><html:p>We see that this is commutative <fr:tex display="inline"><![CDATA[X\cup  Y=Y\cup  X]]></fr:tex> and idempotent <fr:tex display="inline"><![CDATA[X\cup  X=X]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><html:strong>Existence:</html:strong> take <fr:tex display="inline"><![CDATA[X\cup  Y=\bigcup \{X,Y\}]]></fr:tex>. We need to prove <fr:tex display="inline"><![CDATA[x\in  X\cup  Y\implies  x\in \bigcup \{X,Y\}]]></fr:tex> and <fr:tex display="inline"><![CDATA[x\in \bigcup \{X,Y\}\implies  x\in  X\cup  Y]]></fr:tex>, but these follow immediately.</html:p>

<html:p><html:strong>Uniqueness:</html:strong> Suppose <fr:tex display="inline"><![CDATA[A]]></fr:tex> is such that for all <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in  A]]></fr:tex> iff <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> or <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>, and <fr:tex display="inline"><![CDATA[B]]></fr:tex> is such that for all <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in  B]]></fr:tex> iff <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> or <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>. We will prove for all <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in  A]]></fr:tex> iff <fr:tex display="inline"><![CDATA[x\in  B]]></fr:tex>: let <fr:tex display="inline"><![CDATA[x]]></fr:tex> be an arbitrary object. Then
<fr:tex display="block"><![CDATA[x\in  A\iff  x\in  A\hbox { or }x\in  A\iff  x\in  B]]></fr:tex>
which implies <fr:tex display="inline"><![CDATA[x\in  A\iff  x\in  B]]></fr:tex>. Hence <fr:tex display="inline"><![CDATA[A=B]]></fr:tex> by <fr:link href="/nst-0004/" title="Set equality" uri="http://localhost:8000/nst-0004/" display-uri="nst-0004" type="local">Set equality</fr:link>.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000E/</fr:uri>
                <fr:display-uri>nst-000E</fr:display-uri>
                <fr:route>/nst-000E/</fr:route>
                <fr:title text="Basic properties of union of two sets">Basic properties of union of two sets</fr:title>
                <fr:taxon>theorem</fr:taxon>
                <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.4</fr:meta>
                <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/boole.html#T1" type="external">boole:th1</fr:link></fr:meta>
                <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T4" type="external">xboole_1:th4</fr:link></fr:meta>
                <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T12" type="external">xboole_1:th12</fr:link></fr:meta>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex>, <fr:tex display="inline"><![CDATA[B]]></fr:tex>, <fr:tex display="inline"><![CDATA[C]]></fr:tex> be arbitrary sets. Then the following all hold:</html:p>
                <html:ol><html:li><fr:tex display="inline"><![CDATA[A\cup \emptyset =A]]></fr:tex></html:li>
<html:li>Associativity: <fr:tex display="inline"><![CDATA[A\cup (B\cup  C)=(A\cup  B)\cup  C]]></fr:tex></html:li>
<html:li><fr:tex display="inline"><![CDATA[A\subseteq  B]]></fr:tex> iff <fr:tex display="inline"><![CDATA[A\cup  B=B]]></fr:tex></html:li></html:ol>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000F/</fr:uri>
                <fr:display-uri>nst-000F</fr:display-uri>
                <fr:route>/nst-000F/</fr:route>
                <fr:title text="Intersection of two sets">Intersection of two sets</fr:title>
                <fr:taxon>definition</fr:taxon>
                <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.4</fr:meta>
                <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xboole_0.html#K3" type="external">xboole_0:def 4</fr:link></fr:meta>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We define their <html:dfn>Intersection</html:dfn> to be the set denoted <fr:tex display="inline"><![CDATA[X\cap  Y]]></fr:tex> such that: for all objects <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in  X\cap  Y]]></fr:tex> iff <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>.</html:p><html:p>We see this is commutative <fr:tex display="inline"><![CDATA[X\cap  Y=Y\cap  X]]></fr:tex> and idempotent <fr:tex display="inline"><![CDATA[X\cap  X=X]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><html:strong>Existence:</html:strong> We see this exists using <fr:link href="/nst-0009/" title="Set builder notation" uri="http://localhost:8000/nst-0009/" display-uri="nst-0009" type="local">set-builder notation</fr:link>  <fr:tex display="inline"><![CDATA[\{x\in  X\mid  x\in  Y\}]]></fr:tex>.</html:p>
<html:p><html:strong>Uniqueness:</html:strong> let <fr:tex display="inline"><![CDATA[A]]></fr:tex> and <fr:tex display="inline"><![CDATA[B]]></fr:tex> be two possible candidates for the definition. We see <fr:tex display="inline"><![CDATA[x\in  A\iff  x\in  X\hbox { and }x\in  Y\iff  x\in  B]]></fr:tex>, which implies <fr:tex display="inline"><![CDATA[A=B]]></fr:tex> by <fr:link href="/nst-0004/" title="Set equality" uri="http://localhost:8000/nst-0004/" display-uri="nst-0004" type="local">Set equality</fr:link>.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000G/</fr:uri>
                <fr:display-uri>nst-000G</fr:display-uri>
                <fr:route>/nst-000G/</fr:route>
                <fr:title text="Basic properties of intersection of two sets">Basic properties of intersection of two sets</fr:title>
                <fr:taxon>theorem</fr:taxon>
                <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.4</fr:meta>
                <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/boole.html#T2" type="external">boole:2</fr:link></fr:meta>
                <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T17" type="external">xboole_1:17</fr:link></fr:meta>
                <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T28" type="external">xboole_1:28</fr:link></fr:meta>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex>, <fr:tex display="inline"><![CDATA[B]]></fr:tex>, <fr:tex display="inline"><![CDATA[C]]></fr:tex> be any three sets. Then the following all hold:</html:p>
                <html:ol><html:li><fr:tex display="inline"><![CDATA[A\cap \emptyset =\emptyset ]]></fr:tex></html:li>
<html:li><fr:tex display="inline"><![CDATA[A\cap (B\cap  C)=(A\cap  B)\cap  C]]></fr:tex></html:li>
<html:li><fr:tex display="inline"><![CDATA[A\subseteq  B]]></fr:tex> iff <fr:tex display="inline"><![CDATA[A\cap  B=A]]></fr:tex></html:li></html:ol>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000H/</fr:uri>
                <fr:display-uri>nst-000H</fr:display-uri>
                <fr:route>/nst-000H/</fr:route>
                <fr:title text="Intersection of family of sets">Intersection of family of sets</fr:title>
                <fr:taxon>definition</fr:taxon>
                <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.4</fr:meta>
                <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/setfam_1.html#K1" type="external">setfam_1:def 1</fr:link></fr:meta>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[F]]></fr:tex> be a family of sets (i.e., a set whose members are all sets). We define the <html:dfn>Intersection</html:dfn> of <fr:tex display="inline"><![CDATA[F]]></fr:tex> to be the set <fr:tex display="inline"><![CDATA[\bigcap  F]]></fr:tex> such that for all objects <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in \bigcap  F]]></fr:tex> iff for each set <fr:tex display="inline"><![CDATA[Y\in  F]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000I/</fr:uri>
                <fr:display-uri>nst-000I</fr:display-uri>
                <fr:route>/nst-000I/</fr:route>
                <fr:title text="Relative complement of a set">Relative complement of a set</fr:title>
                <fr:taxon>definition</fr:taxon>
                <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.5</fr:meta>
                <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xboole_0.html#K4" type="external">xboole_0:def 5</fr:link></fr:meta>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the <html:dfn>Relative complement</html:dfn> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> with respect to <fr:tex display="inline"><![CDATA[Y]]></fr:tex> to be the set <fr:tex display="inline"><![CDATA[Y\setminus  X]]></fr:tex> such that for all objects <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in  Y\setminus  X]]></fr:tex> iff <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex> and <fr:tex display="inline"><![CDATA[x\notin  X]]></fr:tex>.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000J/</fr:uri>
                <fr:display-uri>nst-000J</fr:display-uri>
                <fr:route>/nst-000J/</fr:route>
                <fr:title text="Complement of a subset">Complement of a subset</fr:title>
                <fr:taxon>definition</fr:taxon>
                <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.5</fr:meta>
                <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/subset_1.html#K3" type="external">subset_1:def 4</fr:link></fr:meta>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be a subset of <fr:tex display="inline"><![CDATA[Y]]></fr:tex>. We define the <html:dfn>Complement</html:dfn> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> to be the subset <fr:tex display="inline"><![CDATA[X^{\complement }]]></fr:tex> of <fr:tex display="inline"><![CDATA[Y]]></fr:tex> equal to <fr:tex display="inline"><![CDATA[Y\setminus  X]]></fr:tex>.</html:p>
                <html:p>Some texts use <fr:tex display="inline"><![CDATA[\complement  X]]></fr:tex> or <fr:tex display="inline"><![CDATA[X']]></fr:tex> for the complement of <fr:tex display="inline"><![CDATA[X]]></fr:tex>.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000K/</fr:uri>
                <fr:display-uri>nst-000K</fr:display-uri>
                <fr:route>/nst-000K/</fr:route>
                <fr:title text="Powerset">Powerset</fr:title>
                <fr:taxon>definition</fr:taxon>
                <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.5</fr:meta>
                <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/zfmisc_1.html#K1" type="external">zfmisc_1:def 1</fr:link></fr:meta>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be a set. We define the <html:dfn>Powerset</html:dfn> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> to be the set <fr:tex display="inline"><![CDATA[\mathcal {P}(X)]]></fr:tex> such that for any set <fr:tex display="inline"><![CDATA[Z]]></fr:tex> we have <fr:tex display="inline"><![CDATA[Z\in \mathcal {P}(X)]]></fr:tex> iff <fr:tex display="inline"><![CDATA[Z\subseteq  X]]></fr:tex>. That is to say, the powerset of <fr:tex display="inline"><![CDATA[X]]></fr:tex> is the set of all subsets of <fr:tex display="inline"><![CDATA[X]]></fr:tex>.</html:p>
                <html:p>For finite sets (especially small sets we can write out by hand), we can see this is a sensible thing to define. But for infinite sets, some Mathematicians historically were nervous about this being well-defined. The important thing is that we assert (either axiomatically or dogmatically) this is indeed a set.</html:p>
                <html:p>(In ZFC, this is given as an axiom.)</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000L/</fr:uri>
                <fr:display-uri>nst-000L</fr:display-uri>
                <fr:route>/nst-000L/</fr:route>
                <fr:title text="Specification for ordered pairs">Specification for ordered pairs</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[x]]></fr:tex> and <fr:tex display="inline"><![CDATA[y]]></fr:tex> be objects. Let <fr:tex display="inline"><![CDATA[a]]></fr:tex> and <fr:tex display="inline"><![CDATA[b]]></fr:tex> be objects. We expect the ordered pair <fr:tex display="inline"><![CDATA[(x,y)]]></fr:tex> to be such that: <fr:tex display="inline"><![CDATA[(x,y)=(a,b)]]></fr:tex> if and only if <fr:tex display="inline"><![CDATA[x=a]]></fr:tex> and <fr:tex display="inline"><![CDATA[y=b]]></fr:tex>.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000M/</fr:uri>
                <fr:display-uri>nst-000M</fr:display-uri>
                <fr:route>/nst-000M/</fr:route>
                <fr:title text="Ordered pairs">Ordered pairs</fr:title>
                <fr:taxon>definition</fr:taxon>
                <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.6</fr:meta>
                <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/tarski.html#K4" type="external">tarski:def 5</fr:link></fr:meta>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[x]]></fr:tex> and <fr:tex display="inline"><![CDATA[y]]></fr:tex> be objects. We define the <html:dfn>Ordered Pair</html:dfn> to be the object <fr:tex display="inline"><![CDATA[(x,y) = \{\{x\},\{x,y\}\}]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:taxon>remark</fr:taxon></fr:frontmatter><fr:mainmatter>A better definition would be <fr:tex display="inline"><![CDATA[(x,y)=\{\{0,x\},\{1,y\}\}]]></fr:tex> because then the <fr:link href="/nst-000O/" title="Cartesian product of two sets" uri="http://localhost:8000/nst-000O/" display-uri="nst-000O" type="local">Cartesian product of two sets</fr:link> coincides with the <fr:link href="/nst-002E/" title="Product of family of sets" uri="http://localhost:8000/nst-002E/" display-uri="nst-002E" type="local">Product of family of sets</fr:link> when <fr:tex display="inline"><![CDATA[I=\{0,1\}]]></fr:tex> is the indexing set.</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000N/</fr:uri>
                <fr:display-uri>nst-000N</fr:display-uri>
                <fr:route>/nst-000N/</fr:route>
                <fr:title text="Ordered pairs implement their specification">Ordered pairs implement their specification</fr:title>
                <fr:taxon>theorem</fr:taxon>
                <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.6</fr:meta>
                <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xtuple_0.html#T1" type="external">xtuple_0:1</fr:link></fr:meta>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[a]]></fr:tex>, <fr:tex display="inline"><![CDATA[b]]></fr:tex>, <fr:tex display="inline"><![CDATA[c]]></fr:tex>, <fr:tex display="inline"><![CDATA[d]]></fr:tex> be objects. If <fr:tex display="inline"><![CDATA[(a,b)=(c,d)]]></fr:tex>, then <fr:tex display="inline"><![CDATA[a=c]]></fr:tex> and <fr:tex display="inline"><![CDATA[b=d]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>We boild this proof down to two cases: either <fr:tex display="inline"><![CDATA[c=d]]></fr:tex> or not. We assume <fr:tex display="inline"><![CDATA[(a,b)=(c,d)]]></fr:tex>.</html:p>
<html:p><html:strong>Case 1:</html:strong> <fr:tex display="inline"><![CDATA[c=d]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[(c,d)=(c,c)=\{\{c,c\},\{c\}\}=\{\{c\}\}]]></fr:tex> and <fr:tex display="inline"><![CDATA[(a,b)=\{\{a,b\},\{a\}\}=\{\{c\}\}]]></fr:tex> requires <fr:tex display="inline"><![CDATA[\{a,b\}=\{c\}]]></fr:tex> which implies <fr:tex display="inline"><![CDATA[a=b=c]]></fr:tex>. Hence <fr:tex display="inline"><![CDATA[a=b=c=d]]></fr:tex> which implies <fr:tex display="inline"><![CDATA[a=c]]></fr:tex> and <fr:tex display="inline"><![CDATA[b=d]]></fr:tex> as desired.</html:p>
<html:p><html:strong>Case 2:</html:strong> <fr:tex display="inline"><![CDATA[c\neq  d]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[\{a\}\neq \{c,d\}]]></fr:tex>, so <fr:tex display="inline"><![CDATA[\{a\}=\{c\}]]></fr:tex>, which means <fr:tex display="inline"><![CDATA[a=c]]></fr:tex>. Then we see <fr:tex display="inline"><![CDATA[(a,b)=(c,b)=(c,d)]]></fr:tex> which implies <fr:tex display="inline"><![CDATA[\{c,b\}=\{c,d\}]]></fr:tex> which means <fr:tex display="inline"><![CDATA[b=d]]></fr:tex>. Hence <fr:tex display="inline"><![CDATA[a=c]]></fr:tex> and <fr:tex display="inline"><![CDATA[b=d]]></fr:tex>.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000O/</fr:uri>
                <fr:display-uri>nst-000O</fr:display-uri>
                <fr:route>/nst-000O/</fr:route>
                <fr:title text="Cartesian product of two sets">Cartesian product of two sets</fr:title>
                <fr:taxon>definition</fr:taxon>
                <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.6</fr:meta>
                <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/zfmisc_1.html#K2" type="external">zfmisc_1:def 2</fr:link></fr:meta>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We define their <html:dfn>Cartesian product</html:dfn> to be the set <fr:tex display="inline"><![CDATA[X\times  Y]]></fr:tex> such that for all objects <fr:tex display="inline"><![CDATA[z]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[z\in  X\times  Y]]></fr:tex> if and only if there exists objects <fr:tex display="inline"><![CDATA[x]]></fr:tex> and <fr:tex display="inline"><![CDATA[y]]></fr:tex> such that <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex display="inline"><![CDATA[y\in  Y]]></fr:tex> and <fr:tex display="inline"><![CDATA[z=(x,y)]]></fr:tex>.</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>9</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-000Q/</fr:uri>
                <fr:display-uri>nst-000Q</fr:display-uri>
                <fr:route>/nst-000Q/</fr:route>
                <fr:title text="Properties of Cartesian product">Properties of Cartesian product</fr:title>
                <fr:taxon>theorem</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex>, <fr:tex display="inline"><![CDATA[Y]]></fr:tex>, <fr:tex display="inline"><![CDATA[Z]]></fr:tex> be sets. Then the following all hold:</html:p>
                <html:ol><html:li><fr:tex display="inline"><![CDATA[X\times  Y\subseteq \mathcal {P}(\mathcal {P}(X\cup  Y))]]></fr:tex></html:li>
<html:li><fr:tex display="inline"><![CDATA[X\times  Y=\emptyset ]]></fr:tex> iff <fr:tex display="inline"><![CDATA[X=\emptyset ]]></fr:tex> or <fr:tex display="inline"><![CDATA[Y=\emptyset ]]></fr:tex></html:li> <html:li>If <fr:tex display="inline"><![CDATA[X\times  Y=Y\times  X]]></fr:tex>, then <fr:tex display="inline"><![CDATA[X=Y]]></fr:tex></html:li> <html:li><fr:tex display="inline"><![CDATA[(X\cup  Y)\times  Z=(X\times  Z)\cup (Y\times  Z)]]></fr:tex></html:li> <html:li><fr:tex display="inline"><![CDATA[X\times (Y\cup  Z)=(X\times  Y)\cup (X\times  Z)]]></fr:tex></html:li> <html:li><fr:tex display="inline"><![CDATA[(X\cap  Y)\times  Z=(X\times  Z)\cap (Y\times  Z)]]></fr:tex></html:li> <html:li><fr:tex display="inline"><![CDATA[X\times (Y\cap  Z)=(X\times  Y)\cap (X\times  Z)]]></fr:tex></html:li> <html:li><fr:tex display="inline"><![CDATA[(X\setminus  Y)\times  Z=(X\times  Z)\setminus (Y\times  Z)]]></fr:tex></html:li> <html:li><fr:tex display="inline"><![CDATA[X\times (Y\setminus  Z)=(X\times  Y)\setminus (X\times  Z)]]></fr:tex></html:li></html:ol>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>1974</fr:year>
            </fr:date>
            <fr:uri>http://localhost:8000/halmos-1974-naive/</fr:uri>
            <fr:display-uri>halmos-1974-naive</fr:display-uri>
            <fr:route>/halmos-1974-naive/</fr:route>
            <fr:title text="Naive Set Theory">Naive Set Theory</fr:title>
            <fr:taxon>reference</fr:taxon>
            <fr:meta name="bibtex"><![CDATA[@book{halmos1974naive,
  author={Halmos, Paul},
  title={Naive Set Theory},
  year={1974},
  publisher={D. Van Nostrand Company Inc.}
}]]></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>http://localhost:8000/paul-r-halmos/</fr:uri>
            <fr:display-uri>paul-r-halmos</fr:display-uri>
            <fr:route>/paul-r-halmos/</fr:route>
            <fr:title text="Paul R. Halmos">Paul R. Halmos</fr:title>
            <fr:taxon>person</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
