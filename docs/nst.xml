<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="default.xsl"?>
<fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="true"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>15413</fr:anchor><fr:addr
type="user">nst</fr:addr><fr:route>nst.xml</fr:route><fr:title
text="Naive set theory">Naive set theory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5604</fr:anchor><fr:addr
type="user">nst-000P</fr:addr><fr:route>nst-000P.xml</fr:route><fr:title
text="Basic concepts and constructions of naive set theory">Basic concepts and constructions of naive set theory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1485</fr:anchor><fr:addr
type="user">nst-002T</fr:addr><fr:route>nst-002T.xml</fr:route><fr:title
text="Types of nodes in Mathematics">Types of nodes in Mathematics</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>24</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We should explain there are roughly four or five different types of "nodes" in Mathematics:</fr:p><fr:ol><fr:li><fr:strong>Definitions:</fr:strong> these introduce new words and phrases. Loosely speaking, these may be "terms" (constants, possibly parametrized by other terms), "predicates" (propositions parametrized by terms), "types" (species of mathematical objects), or "attributes" (modifiers of types). We need to prove definitions of terms are well-defined (specifically, its existence and uniqueness).</fr:li>
<fr:li><fr:strong>Propositions:</fr:strong> these are claims which need to be proven. Propositions come in a variety of flavors, usually:
<fr:ul><fr:li>"Theorems" for important results</fr:li>
<fr:li>"Lemmas" for "helper propositions" used for proving other propositions within a subject, but usually not applicable anywhere else. Sometimes propositions are labeled "lemmas" for historic reasons (like Gauss's lemma, Nakayama's lemma, or Yoneda's lemma) but really they are later realized to be so significant, they should have been theorems.</fr:li>
<fr:li>"Corollary" for results which immediately follow from a proposition.</fr:li></fr:ul></fr:li>
<fr:li><fr:strong>Examples:</fr:strong> Working through a calculation, or giving an instance of a definition. Arguably these are "extraordinarily specialized propositions". Applied Mathematics (and related fields like Physics) may be viewed as a sequence of examples.
<fr:ul><fr:li><fr:strong>Non-example:</fr:strong> a deceptive situation where a claim is false, or an object does not satisfy a property or predicate</fr:li></fr:ul></fr:li>
<fr:li><fr:strong>Proofs:</fr:strong> Propositions, examples, and some kinds of definitions require logical proofs.</fr:li>
<fr:li><fr:strong>Remarks:</fr:strong> "informal" discussion about Mathematics, applications, or whatever. For example, the history of a definition, or useful future applications. Some common species of remarks includes:
<fr:ul><fr:li><fr:strong>Caution:</fr:strong> common errors to avoid</fr:li>
<fr:li><fr:strong>Motivation:</fr:strong> some reason we care about a field, a problem, a result</fr:li>
<fr:li><fr:strong>Notation:</fr:strong> discussing the notation used for a definition</fr:li>
<fr:li><fr:strong>Roadmap:</fr:strong> to give the reader some idea where we're heading</fr:li>
<fr:li><fr:strong>Strategy:</fr:strong> to discuss a specific proof strategy</fr:li></fr:ul></fr:li></fr:ol><fr:p>We try to adhere to this taxonomy, but there may be other useful types of "nodes" we use, like:</fr:p><fr:ul><fr:li><fr:strong>Application:</fr:strong> An example or proposition showing how to use a result or definition</fr:li>
<fr:li><fr:strong>Conjecture:</fr:strong> a proposition lacking a proof, which may or may not be true</fr:li>
<fr:li><fr:strong>Caution:</fr:strong> a remark to warn the reader about possible mistakes or errors</fr:li>
<fr:li><fr:strong>Convention:</fr:strong> a remark about the practices "Working Mathematicians" adhere to, usually an idiosyncratic change of notation or terminology</fr:li>
<fr:li><fr:strong>Exercises:</fr:strong> to make the reader work through some problems</fr:li>
<fr:li><fr:strong>Fact:</fr:strong> a proposition which is true and either (a) we proved it, (b) its proof is too distracting and long to discuss, or (c) we proved a more general version of it.</fr:li>
<fr:li><fr:strong>Provisional Definition:</fr:strong> An attempted definition, which is either (a) a "straw man" (i.e., a failed attempt which we will improve), or (b) not well-defined because it is a primitive notion (e.g., <fr:link
type="local"
href="nst-0001.xml"
addr="nst-0001"
title="Set">Set</fr:link>).</fr:li>
<fr:li><fr:strong>Puzzles:</fr:strong> to guide discussion, sometimes to mention an open research problem.</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1487</fr:anchor><fr:addr
type="user">nst-002H</fr:addr><fr:route>nst-002H.xml</fr:route><fr:title
text="Proof strategies">Proof strategies</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>There are various common "strategies" for proving various claims in Mathematics. We will review the basic strategies here.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1489</fr:anchor><fr:addr
type="user">nst-002G</fr:addr><fr:route>nst-002G.xml</fr:route><fr:title
text="Direct proof">Direct proof</fr:title><fr:taxon>Proof strategy</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>When trying to prove a claim of the form "If <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>", a direct proof has the following skeleton:</fr:p>
  <html:blockquote
xmlns:html="http://www.w3.org/1999/xhtml">Assume <fr:tex
display="inline"><![CDATA[P]]></fr:tex>. [Intermediate proof steps] Thus <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>.</html:blockquote>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1491</fr:anchor><fr:addr
type="user">nst-002I</fr:addr><fr:route>nst-002I.xml</fr:route><fr:title
text="Proof by contrapositive">Proof by contrapositive</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We can take advantage of the fact that "If <fr:tex
display="inline"><![CDATA[P]]></fr:tex> then <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>" has the same truth table as "If not <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>, then not <fr:tex
display="inline"><![CDATA[P]]></fr:tex>". This "Not <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> implies not <fr:tex
display="inline"><![CDATA[P]]></fr:tex>" is called the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Contrapositive</html:dfn> of "<fr:tex
display="inline"><![CDATA[P]]></fr:tex> implies <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>". Usually we embark on a <fr:link
type="local"
href="nst-002G.xml"
addr="nst-002G"
title="Direct proof">Direct proof</fr:link> and so the proof looks like:</fr:p>
  <html:blockquote
xmlns:html="http://www.w3.org/1999/xhtml">Assume not <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>. [Intermediate proof steps.] Hence not <fr:tex
display="inline"><![CDATA[P]]></fr:tex>.</html:blockquote>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1493</fr:anchor><fr:addr
type="user">nst-002J</fr:addr><fr:route>nst-002J.xml</fr:route><fr:title
text="Proof by contradiction">Proof by contradiction</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>When trying to prove the claim <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, it is useful to use the fact that its double negation "Not (not <fr:tex
display="inline"><![CDATA[P]]></fr:tex>)" is logically equivalent to <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, and then use the fact  that "Not <fr:tex
display="inline"><![CDATA[Q]]></fr:tex>" is logically equivalent to "If <fr:tex
display="inline"><![CDATA[Q]]></fr:tex> then contradiction". Taken together, <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is logically equivalent to "If not <fr:tex
display="inline"><![CDATA[P]]></fr:tex>, then contradiction." This is a proof by contradiction.</fr:p><fr:p>When <fr:tex
display="inline"><![CDATA[P]]></fr:tex> is an implication "If <fr:tex
display="inline"><![CDATA[H]]></fr:tex> then <fr:tex
display="inline"><![CDATA[R]]></fr:tex>", a proof by contradiction looks like "If <fr:tex
display="inline"><![CDATA[H]]></fr:tex> and not <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, then contradiction".</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1495</fr:anchor><fr:addr
type="user">nst-002K</fr:addr><fr:route>nst-002K.xml</fr:route><fr:title
text="Proof by induction">Proof by induction</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If we have a claim which is a formula indexed by natural numbers <fr:tex
display="inline"><![CDATA[P[n]]]></fr:tex>, then a proof by induction on <fr:tex
display="inline"><![CDATA[n]]></fr:tex> looks like:</fr:p><fr:ol><fr:li><fr:strong>Base case:</fr:strong> For <fr:tex
display="inline"><![CDATA[n=0]]></fr:tex> (or <fr:tex
display="inline"><![CDATA[n=1]]></fr:tex>), prove <fr:tex
display="inline"><![CDATA[P[0]]]></fr:tex> (resp., <fr:tex
display="inline"><![CDATA[P[1]]]></fr:tex>).</fr:li>
<fr:li><fr:strong>Inductive argument:</fr:strong> For arbitrary <fr:tex
display="inline"><![CDATA[n]]></fr:tex>, prove the claim "If <fr:tex
display="inline"><![CDATA[P[n]]]></fr:tex> then <fr:tex
display="inline"><![CDATA[P[n+1]]]></fr:tex>". Usually this is done by a <fr:link
type="local"
href="nst-002G.xml"
addr="nst-002G"
title="Direct proof">Direct proof</fr:link> and we call the statement "Assume <fr:tex
display="inline"><![CDATA[P[n]]]></fr:tex>" the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Inductive Hypothesis</html:dfn>.</fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1497</fr:anchor><fr:addr
type="user">nst-000R</fr:addr><fr:route>nst-000R.xml</fr:route><fr:title
text="Ontology of Mathematics">Ontology of Mathematics</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>What are the basic "things" we work with in Mathematics? It may seem that we have numbers, functions, and quite possibly other objects.</fr:p><fr:p>Broadly speaking, we could describe Mathematics as working with "sets" (unordered collections of stuff) and "objects" (any generic term or object).</fr:p><fr:p>In practice, there are compelling reasons to stipulate that <fr:em>everything</fr:em> in Mathematics consists of sets. This should be understood as saying that sets form the "machine code" of Mathematics. This is explicitly stated in Bourbaki's <fr:link
type="local"
href="bourbaki-1968-theory.xml"
addr="bourbaki-1968-theory"
title="Theory of Sets">Theory of Sets</fr:link>, II §1.1 (bottom of page 65 of English edition):</fr:p>
  <html:blockquote
xmlns:html="http://www.w3.org/1999/xhtml"><fr:p>From a "naive" point of view, many mathematical entities can be formalized as collections or "sets" of objects. We do not seek to formalize this notion, and in the formalistic interpretation of what follows, the word "set" is to be considered as strictly synonymous with "term".</fr:p></html:blockquote>
<fr:p>We will just stipulate that everything in Mathematics may be considered as an instance of some abstract type we call an "object". We extend this with a subtype called a "set". All sets are objects.</fr:p><fr:p>But some Mathematicians want to discuss the collection of all sets. This can't possibly be a set (otherwise we run into Russell's paradox), so we need to either modify our ontology (and work with "classes" instead of "sets", and call a class a "set" when it's a member of a class) or extend our ontology (to include a "class" as a third species of object). We will discuss this when the time comes, but the ontology is mildly flexible.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1499</fr:anchor><fr:addr
type="user">nst-0001</fr:addr><fr:route>nst-0001.xml</fr:route><fr:title
text="Set">Set</fr:title><fr:taxon>Provisional definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We [pretend to] define a [naive] <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Set</html:dfn> to be a well-defined unordered collection of objects.</fr:p><fr:p>If <fr:tex
display="inline"><![CDATA[x]]></fr:tex> is an object and <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a set, then we write <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> if <fr:tex
display="inline"><![CDATA[x]]></fr:tex> is an element (or member) of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>. If <fr:tex
display="inline"><![CDATA[x]]></fr:tex> is not an element of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, then we write <fr:tex
display="inline"><![CDATA[x\notin  X]]></fr:tex>.</fr:p><fr:p>We will also write <fr:tex
display="inline"><![CDATA[X\ni  x]]></fr:tex> as a synonym for <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>. We also write <fr:tex
display="inline"><![CDATA[X\not \ni  x]]></fr:tex>.</fr:p><fr:p>This isn't really a definition, because set theory is given axiomatically. We usually give axioms to specify the behaviour of the binary infixed predicate <fr:tex
display="inline"><![CDATA[\in ]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1501</fr:anchor><fr:addr
type="user">nst-000C</fr:addr><fr:route>nst-000C.xml</fr:route><fr:title
text="Proving well-definedness of terms">Proving well-definedness of terms</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>When we define a new term in Mathematics, we should prove it is well-defined. What this proof requires depends on what we're defining.</fr:p><fr:ul><fr:li>A new constant (possibly parametrized by other objects) <fr:tex
display="inline"><![CDATA[C]]></fr:tex> defined as satisfying some condition <fr:tex
display="inline"><![CDATA[\Phi [C]]]></fr:tex> requires proving (1) its existence (i.e, proving <fr:tex
display="inline"><![CDATA[\exists  x\ldotp \Phi [x]]]></fr:tex>), and (2) its uniqueness (i.e., <fr:tex
display="inline"><![CDATA[\forall  x,y\ldotp \Phi [x]\land \Phi [y]\implies  x=y]]></fr:tex>).</fr:li>
<fr:li>A new constant <fr:tex
display="inline"><![CDATA[C]]></fr:tex> which is defined as abbreviating some complicated expression is usually well-defined, sometimes we need to prove it has the "correct type".</fr:li>
<fr:li>A new species of thing (like a vector space or a <fr:link
type="local"
href="field-0001.xml"
addr="field-0001"
title="Field">Field</fr:link>) should require proving the existence of at least one such gadget.</fr:li>
<fr:li>All other types of definitions (predicates, adjectives, etc.) are well-defined.</fr:li></fr:ul><fr:p>One of the reasons why the <fr:link
type="local"
href="nst-0001.xml"
addr="nst-0001"
title="Set">"definition" of a set</fr:link> is not really a definition is because we should prove the existence of a set, but that's not possible. It's also why Mathematicians invented <fr:em>axiomatic</fr:em> set theory: presumably there are mathematical objects called "sets" which already exist, and we're trying to specify their behaviour (or some reasonable approximation) using axioms.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1503</fr:anchor><fr:addr
type="user">nst-000U</fr:addr><fr:route>nst-000U.xml</fr:route><fr:title
text="Examples of common sets">Examples of common sets</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We have some very common sets encountered in Mathematics, so we have special notation for them:</fr:p><fr:ul><fr:li><fr:tex
display="inline"><![CDATA[\mathbb {N}_{0}=\{0,1,2,3,…\}]]></fr:tex> the set of all non-negative integers</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[\mathbb {N}=\{1,2,3,4,…\}]]></fr:tex> the set of all positive integers</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[\mathbb {Z}=\{…,-3,-2,-1,0,1,2,3,…\}]]></fr:tex> the set of all integers</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[\mathbb {Q}=\{\frac {m}{n}\mid  m\in \mathbb {Z},n\in \mathbb {N}]]></fr:tex> the set of all rational numbers</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[\mathbb {R}]]></fr:tex> the set of real numbers</fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[\mathbb {C}=\{x+\mathrm {i} y\mid  x,y\in \mathbb {R}\}]]></fr:tex> the set of complex numbers</fr:li></fr:ul></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1505</fr:anchor><fr:addr
type="user">nst-0002</fr:addr><fr:route>nst-0002.xml</fr:route><fr:title
text="Finite sets">Finite sets</fr:title><fr:taxon>Notation</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>If we have a set consisting of finitely many elements, we write it out as a comma-separated list delimited by <fr:tex
display="inline"><![CDATA[\{…\}]]></fr:tex>.</fr:p><fr:p>For example, the set of prime numbers less than 10 is <fr:tex
display="inline"><![CDATA[\{2,3,5,7\}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1507</fr:anchor><fr:addr
type="user">nst-0003</fr:addr><fr:route>nst-0003.xml</fr:route><fr:title
text="Empty set">Empty set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We say <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Empty</html:dfn> if there is no object <fr:tex
display="inline"><![CDATA[x]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1509</fr:anchor><fr:addr
type="user">nst-0004</fr:addr><fr:route>nst-0004.xml</fr:route><fr:title
text="Set equality">Set equality</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the predicate <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Set Equality</html:dfn> (or just <fr:em>equality</fr:em>) of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, denoted <fr:tex
display="inline"><![CDATA[X=Y]]></fr:tex>, to mean they have the same elements; i.e., for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> if and only if <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>.</fr:p><fr:p>When <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are not equal, we write <fr:tex
display="inline"><![CDATA[X\neq  Y]]></fr:tex>.</fr:p><fr:p>(This is technically an axiom of ZFC called the "axiom of extensionality".)</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1511</fr:anchor><fr:addr
type="user">nst-0005</fr:addr><fr:route>nst-0005.xml</fr:route><fr:title
text="The empty set">The empty set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We define <fr:em>the</fr:em> empty set to be the constant denoted <fr:tex
display="inline"><![CDATA[\emptyset ]]></fr:tex> (or sometimes <fr:tex
display="inline"><![CDATA[\{\}]]></fr:tex>).</fr:p><fr:p>We need to prove this is well-defined. For constants, this means proving it exists and is unique.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1513</fr:anchor><fr:addr
type="machine">#466</fr:addr><fr:route>unstable-466.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Existence:</fr:strong> Take the empty list as a set <fr:tex
display="inline"><![CDATA[\{\}]]></fr:tex>. This is clearly empty.</fr:p>

<fr:p><fr:strong>Uniqueness:</fr:strong> Suppose we have <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> both be empty sets. We want to prove <fr:tex
display="inline"><![CDATA[X=Y]]></fr:tex>. Then for any object <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, we want to prove (1) if <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> then <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>, and (2) if <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex> then <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>.</fr:p>

<fr:p>(1) <fr:link
type="local"
href="nst-002J.xml"
addr="nst-002J"
title="Proof by contradiction">Proof by contradiction</fr:link>. Assume <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>. But <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is <fr:link
type="local"
href="nst-0004.xml"
addr="nst-0004"
title="Set equality">empty</fr:link>, so <fr:tex
display="inline"><![CDATA[X]]></fr:tex> cannot have any members. Then we have a contradiction. Hence we can conclude whatever we want, in particular <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>.</fr:p>

<fr:p>(2) The argument is the same but switching <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1515</fr:anchor><fr:addr
type="user">nst-0006</fr:addr><fr:route>nst-0006.xml</fr:route><fr:title
text="Subset">Subset</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the predicate <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex> to mean: for any object <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> then <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>. In other words, all elements of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> are also elements of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>. (This is very different than <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is an element of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>!)</fr:p><fr:p>We write <fr:tex
display="inline"><![CDATA[Y\supseteq  X]]></fr:tex> as a synonym for <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>.</fr:p><fr:p>We also write <fr:tex
display="inline"><![CDATA[X\nsubseteq  Y]]></fr:tex> as the antonym for <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[Y\nsupseteq  X]]></fr:tex> for the antonym of <fr:tex
display="inline"><![CDATA[Y\supseteq  X]]></fr:tex>.</fr:p><fr:p>Observe that <fr:tex
display="inline"><![CDATA[X\subseteq  X]]></fr:tex> for any set <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1517</fr:anchor><fr:addr
type="user">nst-0007</fr:addr><fr:route>nst-0007.xml</fr:route><fr:title
text="Proper subset">Proper subset</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the predicate <fr:tex
display="inline"><![CDATA[X\subset  Y]]></fr:tex> to mean <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[X\neq  Y]]></fr:tex>.</fr:p><fr:p>We also have the synonym <fr:tex
display="inline"><![CDATA[Y\supset  X]]></fr:tex> for <fr:tex
display="inline"><![CDATA[X\subset  Y]]></fr:tex>.</fr:p><fr:p>The choice of notation varies wildly. Some authors do not even distinguish proper subsets from "improper" subsets. Worse, some use <fr:tex
display="inline"><![CDATA[\subset ]]></fr:tex> for improper subsets. We have chosen to use notation analogous to <fr:tex
display="inline"><![CDATA[\leq ]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\lt ]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1519</fr:anchor><fr:addr
type="user">nst-0008</fr:addr><fr:route>nst-0008.xml</fr:route><fr:title
text="Proving two sets are equal">Proving two sets are equal</fr:title><fr:taxon>Strategy</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Generically, when we want to prove <fr:link
type="local"
href="nst-0004.xml"
addr="nst-0004"
title="Set equality">Set equality</fr:link> like proving <fr:tex
display="inline"><![CDATA[X=Y]]></fr:tex>, we can use the <fr:link
type="local"
href="nst-0006.xml"
addr="nst-0006"
title="Subset">Subset</fr:link> predicate to prove two claims: (1) <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>, (2) <fr:tex
display="inline"><![CDATA[Y\subseteq  X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1521</fr:anchor><fr:addr
type="user">nst-0009</fr:addr><fr:route>nst-0009.xml</fr:route><fr:title
text="Set builder notation">Set builder notation</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.2</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>There are times when the notation for <fr:link
type="local"
href="nst-0002.xml"
addr="nst-0002"
title="Finite sets">Finite sets</fr:link> is clunky or impractical (e.g., write out the first <fr:tex
display="inline"><![CDATA[10^{120}]]></fr:tex> prime numbers). We have another notation for describing a set: if <fr:tex
display="inline"><![CDATA[P[x]]]></fr:tex> is a unary predicate and <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a set, then we write
<fr:tex
display="block"><![CDATA[\{x\in  X\mid  P[x]\}]]></fr:tex>
which describes "The set of <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[P[x]]]></fr:tex> holds". The vertical bar ("|") is read "such that". The allowable predicates <fr:tex
display="inline"><![CDATA[P[-]]]></fr:tex> must form a valid <fr:link
type="local"
href="nst-000A.xml"
addr="nst-000A"
title="Sentences in set theory">sentence</fr:link>. (This form of set builder notation is called "the axiom scheme of specification" in ZFC set theory.)</fr:p><fr:p>The other form of set builder notation which appears frequently: if <fr:tex
display="inline"><![CDATA[F(-)]]></fr:tex> is some construction, and <fr:tex
display="inline"><![CDATA[P[-]]]></fr:tex> is a unary predicate, and <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a set, then
<fr:tex
display="block"><![CDATA[\{F(x)\mid  x\in  X,P[x]\}]]></fr:tex>
describes the set obtained by applying <fr:tex
display="inline"><![CDATA[F]]></fr:tex> to each element of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> which satisfies the predicate <fr:tex
display="inline"><![CDATA[P]]></fr:tex>.</fr:p><fr:p>The Working Mathematician usually "suppresses" (omits) the <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> clause when it is understood.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1523</fr:anchor><fr:addr
type="user">nst-000A</fr:addr><fr:route>nst-000A.xml</fr:route><fr:title
text="Sentences in set theory">Sentences in set theory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.2</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>The allowed sentences or predicates appearing in set builder notation may be described recursively.</fr:p><fr:p>We can describe what possible formulas appear using the following:</fr:p><fr:ul><fr:li><fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[X=Y]]></fr:tex> are the atomic formulas</fr:li>
<fr:li>"not &lt;formula&gt;"</fr:li>
<fr:li>"&lt;formula&gt; and &lt;formula&gt;" or just a comma-separated list of formulas, all of which are expected to hold</fr:li>
<fr:li>"&lt;formula&gt; or &lt;formula&gt;" for the disjunction of formulas (in the sense of "either &lt;formula&gt; or &lt;formula&gt; or both")</fr:li>
<fr:li>"if &lt;formula&gt; then &lt;formula&gt;" (or "&lt;formula&gt; implies &lt;formula&gt;")</fr:li>
<fr:li>"&lt;formula&gt; iff &lt;formula&gt;"</fr:li>
<fr:li>"for all …"</fr:li>
<fr:li>"for some …" (or "exists …")</fr:li></fr:ul><fr:p>… as well as using any predicates we've defined (like the <fr:link
type="local"
href="nst-0006.xml"
addr="nst-0006"
title="Subset">Subset</fr:link> predicate).</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1525</fr:anchor><fr:addr
type="user">nst-001N</fr:addr><fr:route>nst-001N.xml</fr:route><fr:title
text="Russell's paradox">Russell's paradox</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Suppose we try defining the set
<fr:tex
display="block"><![CDATA[R=\{S\hbox { is a set}\mid  S\notin  S\}.]]></fr:tex>
Then we obtain a contradiction if such a set exists. (The solution is to restrict what set-builder notation.)</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1527</fr:anchor><fr:addr
type="machine">#461</fr:addr><fr:route>unstable-461.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Well, assume <fr:tex
display="inline"><![CDATA[R]]></fr:tex> exists. We will prove we obtain a contradiction. Our proof is by cases: either <fr:tex
display="inline"><![CDATA[R\in  R]]></fr:tex> or <fr:tex
display="inline"><![CDATA[R\notin  R]]></fr:tex>.</fr:p>
<fr:p><fr:strong>Case 1:</fr:strong> Assume <fr:tex
display="inline"><![CDATA[R\in  R]]></fr:tex>. Then this means <fr:tex
display="inline"><![CDATA[R\notin  R]]></fr:tex>. But we have both <fr:tex
display="inline"><![CDATA[R\in  R]]></fr:tex> and <fr:tex
display="inline"><![CDATA[R\notin  R]]></fr:tex> which is a contradiction.</fr:p>
<fr:p><fr:strong>Case 2:</fr:strong> Assume <fr:tex
display="inline"><![CDATA[R\notin  R]]></fr:tex>. But this is the defining property for members of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>. This implies <fr:tex
display="inline"><![CDATA[R\in  R]]></fr:tex>. Again, we have both <fr:tex
display="inline"><![CDATA[R\in  R]]></fr:tex> and <fr:tex
display="inline"><![CDATA[R\notin  R]]></fr:tex> which is a contradiction.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1529</fr:anchor><fr:addr
type="user">nst-001O</fr:addr><fr:route>nst-001O.xml</fr:route><fr:title
text="There is no set of all sets">There is no set of all sets</fr:title><fr:taxon>Corollary</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>An immediate consequence of <fr:link
type="local"
href="nst-001N.xml"
addr="nst-001N"
title="Russell's paradox">Russell's paradox</fr:link> is that there is no set of all sets. If there were a set <fr:tex
display="inline"><![CDATA[V]]></fr:tex> of all sets, then <fr:tex
display="inline"><![CDATA[V\in  V]]></fr:tex> which leads to problems.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1531</fr:anchor><fr:addr
type="user">nst-001P</fr:addr><fr:route>nst-001P.xml</fr:route><fr:title
text="Classes">Classes</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We will often informally refer to a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">(Proper) Class</html:dfn> as an unordered collection which is "too big" to be a set.</fr:p><fr:p>For example, the von Neumann universe <fr:tex
display="inline"><![CDATA[\mathbf {V}]]></fr:tex> is the proper class of all sets.</fr:p><fr:p>In practice, we seldom need to work with proper classes directly. The Working Mathematician needs only sets (until we get to Category Theory, but we'll revisit this as needed).</fr:p><fr:p>The <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Axiom of limitation of size</html:dfn> asserts a collection <fr:tex
display="inline"><![CDATA[C]]></fr:tex> is a proper class if and only if there exists a surjective function from <fr:tex
display="inline"><![CDATA[C]]></fr:tex> to the von Neumann universe <fr:tex
display="inline"><![CDATA[\mathbf {V}]]></fr:tex>.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1533</fr:anchor><fr:addr
type="machine">#460</fr:addr><fr:route>unstable-460.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>We're playing "fast and loose" with things here, but for a discussion of axiomatic set theory based on classes (using the NBG axioms), see <fr:link
type="local"
href="taras-banakh.xml"
addr="taras-banakh"
title="Taras Banakh">Taras Banakh</fr:link>'s <fr:link
type="local"
href="banakh-2020-classical.xml"
addr="banakh-2020-classical"
title="Classical Set Theory: Theory of Sets and Classes">Classical Set Theory: Theory of Sets and Classes</fr:link>.</fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1535</fr:anchor><fr:addr
type="user">nst-000B</fr:addr><fr:route>nst-000B.xml</fr:route><fr:title
text="Union of a family of sets">Union of a family of sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/tarski.html#K3">tarski:def 4</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[F]]></fr:tex> be a family of sets (i.e., set whose elements are sets). We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Union</html:dfn> of <fr:tex
display="inline"><![CDATA[F]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[\bigcup  F]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in \bigcup  F]]></fr:tex> iff there is some set <fr:tex
display="inline"><![CDATA[X\in  F]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>.</fr:p><fr:p>This defines a new constant and we should set about to <fr:link
type="local"
href="nst-000C.xml"
addr="nst-000C"
title="Proving well-definedness of terms">proving it is well-defined</fr:link>, but proving its existence is impossible because it is just stipulated to exist ("axiom of union").</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1537</fr:anchor><fr:addr
type="user">nst-000D</fr:addr><fr:route>nst-000D.xml</fr:route><fr:title
text="Union of two sets">Union of two sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_0.html#K2">xboole_0:def 3</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Union</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[X\cup  Y]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  X\cup  Y]]></fr:tex> iff either <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> or <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>.</fr:p><fr:p>We see that this is commutative <fr:tex
display="inline"><![CDATA[X\cup  Y=Y\cup  X]]></fr:tex> and idempotent <fr:tex
display="inline"><![CDATA[X\cup  X=X]]></fr:tex>.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1539</fr:anchor><fr:addr
type="machine">#465</fr:addr><fr:route>unstable-465.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Existence:</fr:strong> take <fr:tex
display="inline"><![CDATA[X\cup  Y=\bigcup \{X,Y\}]]></fr:tex>. We need to prove <fr:tex
display="inline"><![CDATA[x\in  X\cup  Y\implies  x\in \bigcup \{X,Y\}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x\in \bigcup \{X,Y\}\implies  x\in  X\cup  Y]]></fr:tex>, but these follow immediately.</fr:p>

<fr:p><fr:strong>Uniqueness:</fr:strong> Suppose <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is such that for all <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  A]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> or <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is such that for all <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  B]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> or <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>. We will prove for all <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  A]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[x\in  B]]></fr:tex>: let <fr:tex
display="inline"><![CDATA[x]]></fr:tex> be an arbitrary object. Then
<fr:tex
display="block"><![CDATA[x\in  A\iff  x\in  A\hbox { or }x\in  A\iff  x\in  B]]></fr:tex>
which implies <fr:tex
display="inline"><![CDATA[x\in  A\iff  x\in  B]]></fr:tex>. Hence <fr:tex
display="inline"><![CDATA[A=B]]></fr:tex> by <fr:link
type="local"
href="nst-0004.xml"
addr="nst-0004"
title="Set equality">Set equality</fr:link>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1541</fr:anchor><fr:addr
type="user">nst-000E</fr:addr><fr:route>nst-000E.xml</fr:route><fr:title
text="Basic properties of union of two sets">Basic properties of union of two sets</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/boole.html#T1">boole:th1</fr:link></fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T4">xboole_1:th4</fr:link></fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T12">xboole_1:th12</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, <fr:tex
display="inline"><![CDATA[B]]></fr:tex>, <fr:tex
display="inline"><![CDATA[C]]></fr:tex> be arbitrary sets. Then the following all hold:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[A\cup \emptyset =A]]></fr:tex></fr:li>
<fr:li>Associativity: <fr:tex
display="inline"><![CDATA[A\cup (B\cup  C)=(A\cup  B)\cup  C]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[A\subseteq  B]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[A\cup  B=B]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1543</fr:anchor><fr:addr
type="user">nst-000F</fr:addr><fr:route>nst-000F.xml</fr:route><fr:title
text="Intersection of two sets">Intersection of two sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_0.html#K3">xboole_0:def 4</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define their <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Intersection</html:dfn> to be the set denoted <fr:tex
display="inline"><![CDATA[X\cap  Y]]></fr:tex> such that: for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  X\cap  Y]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>.</fr:p><fr:p>We see this is commutative <fr:tex
display="inline"><![CDATA[X\cap  Y=Y\cap  X]]></fr:tex> and idempotent <fr:tex
display="inline"><![CDATA[X\cap  X=X]]></fr:tex>.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1545</fr:anchor><fr:addr
type="machine">#464</fr:addr><fr:route>unstable-464.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Existence:</fr:strong> We see this exists using <fr:link
type="local"
href="nst-0009.xml"
addr="nst-0009"
title="Set builder notation">set-builder notation</fr:link>  <fr:tex
display="inline"><![CDATA[\{x\in  X\mid  x\in  Y\}]]></fr:tex>.</fr:p>
<fr:p><fr:strong>Uniqueness:</fr:strong> let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[B]]></fr:tex> be two possible candidates for the definition. We see <fr:tex
display="inline"><![CDATA[x\in  A\iff  x\in  X\hbox { and }x\in  Y\iff  x\in  B]]></fr:tex>, which implies <fr:tex
display="inline"><![CDATA[A=B]]></fr:tex> by <fr:link
type="local"
href="nst-0004.xml"
addr="nst-0004"
title="Set equality">Set equality</fr:link>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1547</fr:anchor><fr:addr
type="user">nst-000G</fr:addr><fr:route>nst-000G.xml</fr:route><fr:title
text="Basic properties of intersection of two sets">Basic properties of intersection of two sets</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/boole.html#T2">boole:2</fr:link></fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T17">xboole_1:17</fr:link></fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T28">xboole_1:28</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, <fr:tex
display="inline"><![CDATA[B]]></fr:tex>, <fr:tex
display="inline"><![CDATA[C]]></fr:tex> be any three sets. Then the following all hold:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[A\cap \emptyset =\emptyset ]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[A\cap (B\cap  C)=(A\cap  B)\cap  C]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[A\subseteq  B]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[A\cap  B=A]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1549</fr:anchor><fr:addr
type="user">nst-000H</fr:addr><fr:route>nst-000H.xml</fr:route><fr:title
text="Intersection of family of sets">Intersection of family of sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/setfam_1.html#K1">setfam_1:def 1</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[F]]></fr:tex> be a family of sets (i.e., a set whose members are all sets). We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Intersection</html:dfn> of <fr:tex
display="inline"><![CDATA[F]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[\bigcap  F]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in \bigcap  F]]></fr:tex> iff for each set <fr:tex
display="inline"><![CDATA[Y\in  F]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1551</fr:anchor><fr:addr
type="user">nst-000I</fr:addr><fr:route>nst-000I.xml</fr:route><fr:title
text="Relative complement of a set">Relative complement of a set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.5</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xboole_0.html#K4">xboole_0:def 5</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Relative complement</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> with respect to <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[Y\setminus  X]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\in  Y\setminus  X]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[x\in  Y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x\notin  X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1553</fr:anchor><fr:addr
type="user">nst-000J</fr:addr><fr:route>nst-000J.xml</fr:route><fr:title
text="Complement of a subset">Complement of a subset</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.5</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/subset_1.html#K3">subset_1:def 4</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a subset of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Complement</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to be the subset <fr:tex
display="inline"><![CDATA[X^{\complement }]]></fr:tex> of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> equal to <fr:tex
display="inline"><![CDATA[Y\setminus  X]]></fr:tex>.</fr:p><fr:p>Some texts use <fr:tex
display="inline"><![CDATA[\complement  X]]></fr:tex> or <fr:tex
display="inline"><![CDATA[X']]></fr:tex> for the complement of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1555</fr:anchor><fr:addr
type="user">nst-000K</fr:addr><fr:route>nst-000K.xml</fr:route><fr:title
text="Powerset">Powerset</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.5</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/zfmisc_1.html#K1">zfmisc_1:def 1</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Powerset</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[\mathcal {P}(X)]]></fr:tex> such that for any set <fr:tex
display="inline"><![CDATA[Z]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[Z\in \mathcal {P}(X)]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[Z\subseteq  X]]></fr:tex>. That is to say, the powerset of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is the set of all subsets of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p><fr:p>For finite sets (especially small sets we can write out by hand), we can see this is a sensible thing to define. But for infinite sets, some Mathematicians historically were nervous about this being well-defined. The important thing is that we assert (either axiomatically or dogmatically) this is indeed a set.</fr:p><fr:p>(In ZFC, this is given as an axiom.)</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1557</fr:anchor><fr:addr
type="user">nst-000L</fr:addr><fr:route>nst-000L.xml</fr:route><fr:title
text="Specification for ordered pairs">Specification for ordered pairs</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> be objects. Let <fr:tex
display="inline"><![CDATA[a]]></fr:tex> and <fr:tex
display="inline"><![CDATA[b]]></fr:tex> be objects. We expect the ordered pair <fr:tex
display="inline"><![CDATA[(x,y)]]></fr:tex> to be such that: <fr:tex
display="inline"><![CDATA[(x,y)=(a,b)]]></fr:tex> if and only if <fr:tex
display="inline"><![CDATA[x=a]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y=b]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1559</fr:anchor><fr:addr
type="user">nst-000M</fr:addr><fr:route>nst-000M.xml</fr:route><fr:title
text="Ordered pairs">Ordered pairs</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.6</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/tarski.html#K4">tarski:def 5</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> be objects. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Ordered Pair</html:dfn> to be the object <fr:tex
display="inline"><![CDATA[(x,y) = \{\{x\},\{x,y\}\}]]></fr:tex>.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1561</fr:anchor><fr:addr
type="machine">#463</fr:addr><fr:route>unstable-463.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>A better definition would be <fr:tex
display="inline"><![CDATA[(x,y)=\{\{0,x\},\{1,y\}\}]]></fr:tex> because then the <fr:link
type="local"
href="nst-000O.xml"
addr="nst-000O"
title="Cartesian product of two sets">Cartesian product of two sets</fr:link> coincides with the <fr:link
type="local"
href="nst-002E.xml"
addr="nst-002E"
title="Product of family of sets">Product of family of sets</fr:link> when <fr:tex
display="inline"><![CDATA[I=\{0,1\}]]></fr:tex> is the indexing set.</fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1563</fr:anchor><fr:addr
type="user">nst-000N</fr:addr><fr:route>nst-000N.xml</fr:route><fr:title
text="Ordered pairs implement their specification">Ordered pairs implement their specification</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.6</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/xtuple_0.html#T1">xtuple_0:1</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[a]]></fr:tex>, <fr:tex
display="inline"><![CDATA[b]]></fr:tex>, <fr:tex
display="inline"><![CDATA[c]]></fr:tex>, <fr:tex
display="inline"><![CDATA[d]]></fr:tex> be objects. If <fr:tex
display="inline"><![CDATA[(a,b)=(c,d)]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[a=c]]></fr:tex> and <fr:tex
display="inline"><![CDATA[b=d]]></fr:tex>.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1565</fr:anchor><fr:addr
type="machine">#462</fr:addr><fr:route>unstable-462.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We boild this proof down to two cases: either <fr:tex
display="inline"><![CDATA[c=d]]></fr:tex> or not. We assume <fr:tex
display="inline"><![CDATA[(a,b)=(c,d)]]></fr:tex>.</fr:p>
<fr:p><fr:strong>Case 1:</fr:strong> <fr:tex
display="inline"><![CDATA[c=d]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[(c,d)=(c,c)=\{\{c,c\},\{c\}\}=\{\{c\}\}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(a,b)=\{\{a,b\},\{a\}\}=\{\{c\}\}]]></fr:tex> requires <fr:tex
display="inline"><![CDATA[\{a,b\}=\{c\}]]></fr:tex> which implies <fr:tex
display="inline"><![CDATA[a=b=c]]></fr:tex>. Hence <fr:tex
display="inline"><![CDATA[a=b=c=d]]></fr:tex> which implies <fr:tex
display="inline"><![CDATA[a=c]]></fr:tex> and <fr:tex
display="inline"><![CDATA[b=d]]></fr:tex> as desired.</fr:p>
<fr:p><fr:strong>Case 2:</fr:strong> <fr:tex
display="inline"><![CDATA[c\neq  d]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[\{a\}\neq \{c,d\}]]></fr:tex>, so <fr:tex
display="inline"><![CDATA[\{a\}=\{c\}]]></fr:tex>, which means <fr:tex
display="inline"><![CDATA[a=c]]></fr:tex>. Then we see <fr:tex
display="inline"><![CDATA[(a,b)=(c,b)=(c,d)]]></fr:tex> which implies <fr:tex
display="inline"><![CDATA[\{c,b\}=\{c,d\}]]></fr:tex> which means <fr:tex
display="inline"><![CDATA[b=d]]></fr:tex>. Hence <fr:tex
display="inline"><![CDATA[a=c]]></fr:tex> and <fr:tex
display="inline"><![CDATA[b=d]]></fr:tex>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1567</fr:anchor><fr:addr
type="user">nst-000O</fr:addr><fr:route>nst-000O.xml</fr:route><fr:title
text="Cartesian product of two sets">Cartesian product of two sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.6</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/zfmisc_1.html#K2">zfmisc_1:def 2</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define their <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Cartesian product</html:dfn> to be the set <fr:tex
display="inline"><![CDATA[X\times  Y]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[z]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[z\in  X\times  Y]]></fr:tex> if and only if there exists objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y\in  Y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[z=(x,y)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1569</fr:anchor><fr:addr
type="user">nst-000Q</fr:addr><fr:route>nst-000Q.xml</fr:route><fr:title
text="Properties of Cartesian product">Properties of Cartesian product</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex>, <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, <fr:tex
display="inline"><![CDATA[Z]]></fr:tex> be sets. Then the following all hold:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[X\times  Y\subseteq \mathcal {P}(\mathcal {P}(X\cup  Y))]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[X\times  Y=\emptyset ]]></fr:tex> iff <fr:tex
display="inline"><![CDATA[X=\emptyset ]]></fr:tex> or <fr:tex
display="inline"><![CDATA[Y=\emptyset ]]></fr:tex></fr:li> <fr:li>If <fr:tex
display="inline"><![CDATA[X\times  Y=Y\times  X]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[X=Y]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[(X\cup  Y)\times  Z=(X\times  Z)\cup (Y\times  Z)]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[X\times (Y\cup  Z)=(X\times  Y)\cup (X\times  Z)]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[(X\cap  Y)\times  Z=(X\times  Z)\cap (Y\times  Z)]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[X\times (Y\cap  Z)=(X\times  Y)\cap (X\times  Z)]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[(X\setminus  Y)\times  Z=(X\times  Z)\setminus (Y\times  Z)]]></fr:tex></fr:li> <fr:li><fr:tex
display="inline"><![CDATA[X\times (Y\setminus  Z)=(X\times  Y)\setminus (X\times  Z)]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5606</fr:anchor><fr:addr
type="user">nst-000S</fr:addr><fr:route>nst-000S.xml</fr:route><fr:title
text="Relations and functions in naive set theory">Relations and functions in naive set theory</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5448</fr:anchor><fr:addr
type="user">nst-000T</fr:addr><fr:route>nst-000T.xml</fr:route><fr:title
text="Relation">Relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>We can define a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Relation</html:dfn> broadly is a set <fr:tex
display="inline"><![CDATA[R]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[r\in  R]]></fr:tex> there exists objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[r=(x,y)]]></fr:tex>. In other words, a relation is a set which consists of ordered pairs.</fr:p><fr:p>When <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> are sets, a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Relation</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is a subset <fr:tex
display="inline"><![CDATA[R\subseteq  X\times  Y]]></fr:tex>.</fr:p><fr:p>We will speak of a "Relation of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>" when referring to a subset <fr:tex
display="inline"><![CDATA[R\subseteq  X\times  X]]></fr:tex>.</fr:p><fr:p>If <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is a relation and <fr:tex
display="inline"><![CDATA[(x,y)\in  R]]></fr:tex>, then we will frequently abuse notation and write <fr:tex
display="inline"><![CDATA[x\;R\;y]]></fr:tex>. Usually instead of <fr:tex
display="inline"><![CDATA[R]]></fr:tex>, for particular relations we use <fr:tex
display="inline"><![CDATA[\sim ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\approx ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\cong ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\equiv ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\lt ]]></fr:tex>, or other notation which is more aesthetically pleasing.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5450</fr:anchor><fr:addr
type="user">nst-000V</fr:addr><fr:route>nst-000V.xml</fr:route><fr:title
text="Domain of a relation">Domain of a relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be a relation. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Domain</html:dfn> of <fr:tex
display="inline"><![CDATA[R]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[\mathop {\textrm {dom}}\nolimits (R)=\{x\mid  \exists  y\ldotp  (x,y)\in  R\}]]></fr:tex>.</fr:p><fr:p>When <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is a relation of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, we see <fr:tex
display="inline"><![CDATA[\mathop {\textrm {dom}}\nolimits (R)\subseteq  X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5452</fr:anchor><fr:addr
type="user">nst-000W</fr:addr><fr:route>nst-000W.xml</fr:route><fr:title
text="Range of a relation">Range of a relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be a relation. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Range</html:dfn> of <fr:tex
display="inline"><![CDATA[R]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[\mathop {\textrm {ran}}\nolimits (R)=\{y\mid \exists  x\ldotp (x,y)\in  R\}]]></fr:tex>.</fr:p><fr:p>When <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is a relation of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, we see <fr:tex
display="inline"><![CDATA[\mathop {\textrm {ran}}\nolimits (R)\subseteq  Y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5454</fr:anchor><fr:addr
type="user">nst-000X</fr:addr><fr:route>nst-000X.xml</fr:route><fr:title
text="Field of a relation">Field of a relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/relat_1.html#K1">relat_1:def 6</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be a relation. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Field</html:dfn> of <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is just <fr:tex
display="inline"><![CDATA[\mathop {\textrm {dom}}\nolimits (R)\cup \mathop {\textrm {ran}}\nolimits (R)]]></fr:tex>.</fr:p><fr:p>Observe when <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is a relation of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>, the field <fr:tex
display="inline"><![CDATA[F]]></fr:tex> of <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is a subset <fr:tex
display="inline"><![CDATA[F\subseteq  X\cup  Y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5456</fr:anchor><fr:addr
type="user">nst-001F</fr:addr><fr:route>nst-001F.xml</fr:route><fr:title
text="Inverse relation">Inverse relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be a relation. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Inverse</html:dfn> of <fr:tex
display="inline"><![CDATA[R]]></fr:tex> to be the relation <fr:tex
display="inline"><![CDATA[R^{-1}=\{(y,x)\mid (x,y)\in  R\}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5458</fr:anchor><fr:addr
type="user">nst-000Y</fr:addr><fr:route>nst-000Y.xml</fr:route><fr:title
text="Reflexive relation">Reflexive relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/relat_2.html#V1">relat_2:def 9</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be a relation, let <fr:tex
display="inline"><![CDATA[F]]></fr:tex> be its <fr:link
type="local"
href="nst-000X.xml"
addr="nst-000X"
title="Field of a relation">field</fr:link>. We say <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Reflexive</html:dfn> if for each <fr:tex
display="inline"><![CDATA[x\in  F]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[(x,x)\in  R]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5460</fr:anchor><fr:addr
type="user">nst-000Z</fr:addr><fr:route>nst-000Z.xml</fr:route><fr:title
text="Symmetric relation">Symmetric relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/relat_2.html#V3">relat_2:def 11</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be a relation, let <fr:tex
display="inline"><![CDATA[F]]></fr:tex> be its <fr:link
type="local"
href="nst-000X.xml"
addr="nst-000X"
title="Field of a relation">field</fr:link>. We say <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Symmetric</html:dfn> if for all <fr:tex
display="inline"><![CDATA[x\in  F]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y\in  F]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[(x,y)\in  R]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[(y,x)\in  R]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5462</fr:anchor><fr:addr
type="user">nst-002N</fr:addr><fr:route>nst-002N.xml</fr:route><fr:title
text="Antisymmetric relation">Antisymmetric relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be a relation, let <fr:tex
display="inline"><![CDATA[F]]></fr:tex> be its field. We say <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Antisymmetric</html:dfn> if for each <fr:tex
display="inline"><![CDATA[x,y\in  F]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[(x,y)\in  R]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(y,x)\in  R]]></fr:tex> if and only if <fr:tex
display="inline"><![CDATA[x=y]]></fr:tex>.</fr:p><fr:p>For example, divisibility relation on natural numbers is antisymmetric, or the ordering <fr:tex
display="inline"><![CDATA[\leq ]]></fr:tex> on real numbers is antisymmetric.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5464</fr:anchor><fr:addr
type="user">nst-0010</fr:addr><fr:route>nst-0010.xml</fr:route><fr:title
text="Transitive relation">Transitive relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/relat_2.html#V8">relat_2:def 16</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be a relation, let <fr:tex
display="inline"><![CDATA[F]]></fr:tex> be its <fr:link
type="local"
href="nst-000X.xml"
addr="nst-000X"
title="Field of a relation">field</fr:link>. We say <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Transitive</html:dfn> if for all <fr:tex
display="inline"><![CDATA[x\in  F]]></fr:tex>, <fr:tex
display="inline"><![CDATA[y\in  F]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[z\in  F]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[(x,y)\in  R]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(y,z)\in  R]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[(x,z)\in  R]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5466</fr:anchor><fr:addr
type="user">nst-002O</fr:addr><fr:route>nst-002O.xml</fr:route><fr:title
text="Partial Order">Partial Order</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. A <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Partial Order</html:dfn> on <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a <fr:link
type="local"
href="nst-000Y.xml"
addr="nst-000Y"
title="Reflexive relation">reflexive</fr:link> <fr:link
type="local"
href="nst-002N.xml"
addr="nst-002N"
title="Antisymmetric relation">antisymmetric</fr:link> <fr:link
type="local"
href="nst-0010.xml"
addr="nst-0010"
title="Transitive relation">transitive</fr:link> relation on <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p><fr:p>Usually, partial orders are denoted by <fr:tex
display="inline"><![CDATA[\leq ]]></fr:tex> or something similar.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5468</fr:anchor><fr:addr
type="user">nst-0011</fr:addr><fr:route>nst-0011.xml</fr:route><fr:title
text="Equivalence relation">Equivalence relation</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/eqrel_1.html#NM2">eqrel_1:def</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We define an <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Equivalence Relation</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to be a <fr:link
type="local"
href="nst-000Y.xml"
addr="nst-000Y"
title="Reflexive relation">reflexive</fr:link> <fr:link
type="local"
href="nst-000Z.xml"
addr="nst-000Z"
title="Symmetric relation">symmetric</fr:link> <fr:link
type="local"
href="nst-0010.xml"
addr="nst-0010"
title="Transitive relation">transitive</fr:link> relation of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p><fr:p>For example, <fr:tex
display="inline"><![CDATA[R=\{(x,x)\mid  x\in  X\}]]></fr:tex> is always an equivalence relation of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> which describes equality of elements of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p><fr:p>More generally, an equivalence relation is a generalization of equality. Consequently, it is common to use notation like <fr:tex
display="inline"><![CDATA[\sim ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\approx ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\equiv ]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\cong ]]></fr:tex> for equivalence relations.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5470</fr:anchor><fr:addr
type="user">nst-0012</fr:addr><fr:route>nst-0012.xml</fr:route><fr:title
text="Equivalence class">Equivalence class</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/eqrel_1.html#K6">eqrel_1:def</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set, let <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>, and let <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be an equivalence relation of <fr:tex
display="inline"><![CDATA[X]]></fr:tex>. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Equivalence Class</html:dfn> of <fr:tex
display="inline"><![CDATA[x]]></fr:tex> with respect to <fr:tex
display="inline"><![CDATA[R]]></fr:tex> is the set <fr:tex
display="inline"><![CDATA[[x]_{R}=\{y\in  X\mid  (x,y)\in  R\}]]></fr:tex> consisting of all elements equivalent to <fr:tex
display="inline"><![CDATA[x]]></fr:tex> under <fr:tex
display="inline"><![CDATA[R]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5472</fr:anchor><fr:addr
type="user">nst-0013</fr:addr><fr:route>nst-0013.xml</fr:route><fr:title
text="Composing relations">Composing relations</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.7</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/relat_1.html#K3">relat_1:def 8</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[P]]></fr:tex> and <fr:tex
display="inline"><![CDATA[R]]></fr:tex> be relations. We define their <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Composition</html:dfn> to be the relation denoted <fr:tex
display="inline"><![CDATA[PR]]></fr:tex> or <fr:tex
display="inline"><![CDATA[R\circ  P]]></fr:tex> such that for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[z]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[(x,z)\in  PR]]></fr:tex> iff there exists an object <fr:tex
display="inline"><![CDATA[y]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[(x,y)\in  P]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(y,z)\in  R]]></fr:tex>.</fr:p><fr:p>The <fr:tex
display="inline"><![CDATA[PR]]></fr:tex> notation means <fr:tex
display="inline"><![CDATA[xPRz]]></fr:tex> iff there exists a <fr:tex
display="inline"><![CDATA[y]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[xPyRz]]></fr:tex>.</fr:p><fr:p>The <fr:tex
display="inline"><![CDATA[R\circ  P]]></fr:tex> notation is useful for working with functions.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5474</fr:anchor><fr:addr
type="user">nst-001B</fr:addr><fr:route>nst-001B.xml</fr:route><fr:title
text="Composing relations is associative">Composing relations is associative</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/relat_1.html#T36">relat_1:th36</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[R_{1}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[R_{2}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[R_{3}]]></fr:tex> be relations. Then <fr:tex
display="inline"><![CDATA[(R_{1}\circ  R_{2})\circ  R_{3}=R_{1}\circ (R_{2}\circ  R_{3})]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5476</fr:anchor><fr:addr
type="user">nst-0014</fr:addr><fr:route>nst-0014.xml</fr:route><fr:title
text="Function">Function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.8</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Function</html:dfn> from <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> to be a <fr:link
type="local"
href="nst-000T.xml"
addr="nst-000T"
title="Relation">relation</fr:link> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> denoted <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> such that:
<fr:ol><fr:li><fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/partfun1.html#V1">Total</fr:link>: <fr:tex
display="inline"><![CDATA[\mathop {\textrm {dom}}\nolimits (f)=X]]></fr:tex>, and</fr:li>
<fr:li><fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/funct_1.html#V1">Function-like</fr:link>: for all objects <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, <fr:tex
display="inline"><![CDATA[y]]></fr:tex>, <fr:tex
display="inline"><![CDATA[z]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[(x,y)\in  f]]></fr:tex> and <fr:tex
display="inline"><![CDATA[(x,z)\in  f]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[y=z]]></fr:tex>.</fr:li></fr:ol>
Instead of <fr:tex
display="inline"><![CDATA[(x,y)\in  f]]></fr:tex>, we write <fr:tex
display="inline"><![CDATA[f(x)=y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5478</fr:anchor><fr:addr
type="user">nst-0015</fr:addr><fr:route>nst-0015.xml</fr:route><fr:title
text="Set of all functions">Set of all functions</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.8</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/funct_2.html#K1">funct_2:def 2</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We denote the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Set of all functions</html:dfn> from <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> as either <fr:tex
display="inline"><![CDATA[Y^{X}]]></fr:tex> or <fr:tex
display="inline"><![CDATA[\mathop {\textrm {Hom}}\nolimits (X,Y)]]></fr:tex>.</fr:p><fr:p>We see this really is a set, since a function is a subset of <fr:tex
display="inline"><![CDATA[X\times  Y]]></fr:tex>, so the set of all functions is a subset of <fr:tex
display="inline"><![CDATA[\mathcal {P}(X\times  Y)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5480</fr:anchor><fr:addr
type="user">nst-0016</fr:addr><fr:route>nst-0016.xml</fr:route><fr:title
text="Inclusion">Inclusion</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.8</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/funct_3.html#K6">funct_3:def</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a subset of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>. Then the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Inclusion</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> into <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> is the function <fr:tex
display="inline"><![CDATA[i\colon  X\to  Y]]></fr:tex> defined by <fr:tex
display="inline"><![CDATA[i(x)=x]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5482</fr:anchor><fr:addr
type="user">nst-0017</fr:addr><fr:route>nst-0017.xml</fr:route><fr:title
text="Identity function">Identity function</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/relat_1.html#K4">relat_1:def 10</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Identity Function</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to be the function <fr:tex
display="inline"><![CDATA[\mathop {\textrm {id}}\nolimits _{X}\colon  X\to  X]]></fr:tex> such that for all <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>, <fr:tex
display="inline"><![CDATA[\mathop {\textrm {id}}\nolimits _{X}(x)=x]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5484</fr:anchor><fr:addr
type="user">nst-0018</fr:addr><fr:route>nst-0018.xml</fr:route><fr:title
text="Restriction of a function">Restriction of a function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.8</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/relat_1.html#K5">relat_1:def 11</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[g\colon  Y\to  Z]]></fr:tex> be a function, let <fr:tex
display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Restriction</html:dfn> of <fr:tex
display="inline"><![CDATA[g]]></fr:tex> to <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to be the function <fr:tex
display="inline"><![CDATA[g|_{X}\colon  X\to  Z]]></fr:tex> such that for all <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>, <fr:tex
display="inline"><![CDATA[g|_{X}(x)=g(x)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5486</fr:anchor><fr:addr
type="user">nst-0019</fr:addr><fr:route>nst-0019.xml</fr:route><fr:title
text="Projection of Cartesian product">Projection of Cartesian product</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.8</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Projection Functions</html:dfn> <fr:tex
display="inline"><![CDATA[\pi _{1}\colon  X\times  Y\to  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\pi _{2}\colon  X\times  Y\to  Y]]></fr:tex> by <fr:tex
display="inline"><![CDATA[\pi _{1}(x,y)=x]]></fr:tex> and <fr:tex
display="inline"><![CDATA[\pi _{2}(x,y)=y]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y\in  Y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5488</fr:anchor><fr:addr
type="user">nst-001M</fr:addr><fr:route>nst-001M.xml</fr:route><fr:title
text="Composition of functions">Composition of functions</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g\colon  Y\to  Z]]></fr:tex> be functions. Then the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Composition</html:dfn> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> followed by <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is the function <fr:tex
display="inline"><![CDATA[g\circ  f\colon  X\to  Z]]></fr:tex> defined by <fr:tex
display="inline"><![CDATA[(g\circ  f)(x)=g(f(x))]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex>.</fr:p><fr:p>Observe this is just the <fr:link
type="local"
href="nst-0013.xml"
addr="nst-0013"
title="Composing relations">Composing relations</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5490</fr:anchor><fr:addr
type="user">nst-001A</fr:addr><fr:route>nst-001A.xml</fr:route><fr:title
text="Composing functions is associative">Composing functions is associative</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  W\to  X]]></fr:tex>, <fr:tex
display="inline"><![CDATA[g\colon  X\to  Y]]></fr:tex>, <fr:tex
display="inline"><![CDATA[h\colon  Y\to  Z]]></fr:tex> be functions. Then <fr:tex
display="inline"><![CDATA[h\circ (g\circ  f)=(h\circ  g)\circ  f]]></fr:tex>.</fr:p><fr:p>This follows from <fr:link
type="local"
href="nst-001B.xml"
addr="nst-001B"
title="Composing relations is associative">composing relations is associative</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5492</fr:anchor><fr:addr
type="user">nst-001C</fr:addr><fr:route>nst-001C.xml</fr:route><fr:title
text="Preimage of a function">Preimage of a function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.10</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function, let <fr:tex
display="inline"><![CDATA[B\subseteq  Y]]></fr:tex>. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Preimage</html:dfn> of <fr:tex
display="inline"><![CDATA[B]]></fr:tex> under <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[f^{-1}(A)=\{x\in  X\mid  f(x)\in  B\}]]></fr:tex>.</fr:p><fr:p>This is sometimes denoted <fr:tex
display="inline"><![CDATA[f^{*}(B)]]></fr:tex> to avoid confusing the preimage with the inverse function of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. This allows us to interpret <fr:tex
display="inline"><![CDATA[f^{*}\colon \mathcal {P}(Y)\to \mathcal {P}(X)]]></fr:tex> without ambiguity.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5494</fr:anchor><fr:addr
type="user">ela-001B</fr:addr><fr:route>ela-001B.xml</fr:route><fr:title
text="Image of a function">Image of a function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[Y]]></fr:tex> be sets, let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Image</html:dfn> (or <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Range</html:dfn>) of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to be the subset <fr:tex
display="inline"><![CDATA[\mathop {\textrm {ran}}\nolimits (f)=f(X)=\{f(x)\in  Y\mid  x\in  X\}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5496</fr:anchor><fr:addr
type="user">nst-001D</fr:addr><fr:route>nst-001D.xml</fr:route><fr:title
text="Direct image of a function">Direct image of a function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.10</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function. Let <fr:tex
display="inline"><![CDATA[A\subseteq  X]]></fr:tex>. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Direct Image</html:dfn> of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> under <fr:tex
display="inline"><![CDATA[f]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[f(A)=\{f(x)\in  Y\mid  x\in  A\}]]></fr:tex>.</fr:p><fr:p>We sometimes use the notation <fr:tex
display="inline"><![CDATA[f_{*}(A)]]></fr:tex> for the direct image of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> under <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, so we can describe a function <fr:tex
display="inline"><![CDATA[f_{*}\colon \mathcal {P}(X)\to \mathcal {P}(Y)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5498</fr:anchor><fr:addr
type="user">nst-001E</fr:addr><fr:route>nst-001E.xml</fr:route><fr:title
text="Properties of image and preimage of a function">Properties of image and preimage of a function</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link> <fr:link
type="local"
href="halmos-1974-naive.xml"
addr="halmos-1974-naive"
title="Naive Set Theory">Naive Set Theory</fr:link> Ch.10</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function, let <fr:tex
display="inline"><![CDATA[A\subseteq  X]]></fr:tex>, and <fr:tex
display="inline"><![CDATA[B\subseteq  Y]]></fr:tex>. Then the following all hold:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[f(f^{-1}(B))\subseteq  B]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[A\subseteq  f^{-1}(f(A))]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5500</fr:anchor><fr:addr
type="user">nst-001J</fr:addr><fr:route>nst-001J.xml</fr:route><fr:title
text="Preimages preserve everything">Preimages preserve everything</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="nicolas-bourbaki.xml"
addr="nicolas-bourbaki"
title="Nicolas Bourbaki">Nicolas Bourbaki</fr:link> <fr:link
type="local"
href="bourbaki-1968-theory.xml"
addr="bourbaki-1968-theory"
title="Theory of Sets">Theory of Sets</fr:link> R §2.10</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function, let <fr:tex
display="inline"><![CDATA[L\subseteq  Y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[R\subseteq  Y]]></fr:tex> be subsets. Then the following all hold:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[f^{-1}(L\cup  R)=f^{-1}(L)\cup  f^{-1}(R)]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[f^{-1}(L\cap  R)=f^{-1}(L)\cap  f^{-1}(R)]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[f^{-1}(L\setminus  R)=f^{-1}(L)\setminus  f^{-1}(R)]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5502</fr:anchor><fr:addr
type="user">nst-001K</fr:addr><fr:route>nst-001K.xml</fr:route><fr:title
text="Direct image preserves only union">Direct image preserves only union</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="nicolas-bourbaki.xml"
addr="nicolas-bourbaki"
title="Nicolas Bourbaki">Nicolas Bourbaki</fr:link> <fr:link
type="local"
href="bourbaki-1968-theory.xml"
addr="bourbaki-1968-theory"
title="Theory of Sets">Theory of Sets</fr:link> R§2.5</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function, let <fr:tex
display="inline"><![CDATA[L\subseteq  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[R\subseteq  X]]></fr:tex> be subsets. Then the following all hold:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[f(L\cup  R)=f(L)\cup  f(R)]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[f(L\cap  R)\subseteq  f(L)\cap  f(R)]]></fr:tex></fr:li>
<fr:li><fr:tex
display="inline"><![CDATA[f(L\setminus  R)\supseteq  f(L)\setminus  f(R)]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5504</fr:anchor><fr:addr
type="user">ela-001I</fr:addr><fr:route>ela-001I.xml</fr:route><fr:title
text="Surjective function">Surjective function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function. We say <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Surjective</html:dfn> (or that it's a <fr:em>surjection</fr:em>) if for each <fr:tex
display="inline"><![CDATA[y\in  Y]]></fr:tex> there is at least one <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[f(x)=y]]></fr:tex>.</fr:p><fr:p>In other words, the <fr:link
type="local"
href="ela-001B.xml"
addr="ela-001B"
title="Image of a function">image</fr:link> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is the <fr:link
type="local"
href="ela-001C.xml"
addr="ela-001C"
title="Domain and codomain of a function">codomain</fr:link> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>. Or more vividly, <fr:tex
display="inline"><![CDATA[f]]></fr:tex> "covers" all of <fr:tex
display="inline"><![CDATA[Y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5506</fr:anchor><fr:addr
type="user">nst-001H</fr:addr><fr:route>nst-001H.xml</fr:route><fr:title
text="Surjective functions have right inverse">Surjective functions have right inverse</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be an <fr:link
type="local"
href="ela-001I.xml"
addr="ela-001I"
title="Surjective function">Surjective function</fr:link>. Then there exists a function <fr:tex
display="inline"><![CDATA[g\colon  Y\to  X]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[f\circ  g=\mathop {\textrm {id}}\nolimits _{Y}]]></fr:tex>.</fr:p><fr:p>We call such a <fr:tex
display="inline"><![CDATA[g]]></fr:tex> a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Right Inverse</html:dfn> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5508</fr:anchor><fr:addr
type="user">ela-001J</fr:addr><fr:route>ela-001J.xml</fr:route><fr:title
text="Injective function">Injective function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function. We say <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">injective</html:dfn> (or that it's a <fr:em>injection</fr:em>) if for all <fr:tex
display="inline"><![CDATA[x_{1},x_{2}\in  X]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[f(x_{1})=f(x_{2})]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x_{1}=x_{2}]]></fr:tex>.</fr:p><fr:p>Equivalently, if <fr:tex
display="inline"><![CDATA[f(x_{1})\neq  f(x_{2})]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[x_{1}\neq  x_{2}]]></fr:tex>.</fr:p><fr:p>So no two distinct elements of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> are mapped to the same element under <fr:tex
display="inline"><![CDATA[f]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5510</fr:anchor><fr:addr
type="user">nst-001G</fr:addr><fr:route>nst-001G.xml</fr:route><fr:title
text="Injective functions have a left inverse function">Injective functions have a left inverse function</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be an <fr:link
type="local"
href="ela-001J.xml"
addr="ela-001J"
title="Injective function">Injective function</fr:link>. Then there exists a function <fr:tex
display="inline"><![CDATA[g\colon  Y\to  X]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[g\circ  f=\mathop {\textrm {id}}\nolimits _{X}]]></fr:tex>.</fr:p><fr:p>We call such a <fr:tex
display="inline"><![CDATA[g]]></fr:tex> a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Left Inverse</html:dfn> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5512</fr:anchor><fr:addr
type="user">ela-001K</fr:addr><fr:route>ela-001K.xml</fr:route><fr:title
text="Bijective function">Bijective function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>8</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We say a function <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Bijective</html:dfn> (or say <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is a <fr:em>bijection</fr:em>) if <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is both <fr:link
type="local"
href="ela-001J.xml"
addr="ela-001J"
title="Injective function">injective</fr:link> and <fr:link
type="local"
href="ela-001I.xml"
addr="ela-001I"
title="Surjective function">surjective</fr:link>.</fr:p><fr:p>This means for each <fr:tex
display="inline"><![CDATA[y\in  Y]]></fr:tex>, there exists a unique <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[f(x)=y]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5514</fr:anchor><fr:addr
type="user">nst-001L</fr:addr><fr:route>nst-001L.xml</fr:route><fr:title
text="Inverse function">Inverse function</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>10</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function. We call a function <fr:tex
display="inline"><![CDATA[g\colon  Y\to  X]]></fr:tex> the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Inverse</html:dfn> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex> if <fr:tex
display="inline"><![CDATA[f\circ  g=\mathop {\textrm {id}}\nolimits _{Y}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g\circ  f=\mathop {\textrm {id}}\nolimits _{X}]]></fr:tex>. When such a <fr:tex
display="inline"><![CDATA[g]]></fr:tex> exists, we denote it by <fr:tex
display="inline"><![CDATA[f^{-1}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5516</fr:anchor><fr:addr
type="user">nst-001I</fr:addr><fr:route>nst-001I.xml</fr:route><fr:title
text="Bijective functions have unique inverse">Bijective functions have unique inverse</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/funct_1.html#K2">funct_1:def 5</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be an <fr:link
type="local"
href="ela-001K.xml"
addr="ela-001K"
title="Bijective function">Bijective function</fr:link>. Then there exists a function <fr:tex
display="inline"><![CDATA[g\colon  Y\to  X]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[f\circ  g=\mathop {\textrm {id}}\nolimits _{Y}]]></fr:tex> and <fr:tex
display="inline"><![CDATA[g\circ  f=\mathop {\textrm {id}}\nolimits _{X}]]></fr:tex>. Moreover this function <fr:tex
display="inline"><![CDATA[g]]></fr:tex> is unique.</fr:p><fr:p>We call such a <fr:tex
display="inline"><![CDATA[g]]></fr:tex> the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Inverse</html:dfn> of <fr:tex
display="inline"><![CDATA[f]]></fr:tex>, and we usually denote it by <fr:tex
display="inline"><![CDATA[f^{-1}=g]]></fr:tex>.</fr:p><fr:p>We see that if <fr:tex
display="inline"><![CDATA[(x,y)\in  f]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[(y,x)\in  g]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5518</fr:anchor><fr:addr
type="user">nst-002D</fr:addr><fr:route>nst-002D.xml</fr:route><fr:title
text="Indexed family of sets">Indexed family of sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[I]]></fr:tex> be a set. A <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Family of Sets Indexed by <fr:tex
display="inline"><![CDATA[I]]></fr:tex></html:dfn> is a function-like set <fr:tex
display="inline"><![CDATA[\mathcal {F}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\mathop {\textrm {dom}}\nolimits (\mathcal {F})=I]]></fr:tex>.</fr:p><fr:p>We usually write <fr:tex
display="inline"><![CDATA[\mathcal {F}=\{F_{i}\}_{i\in  I}]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5520</fr:anchor><fr:addr
type="user">nst-002F</fr:addr><fr:route>nst-002F.xml</fr:route><fr:title
text="Unions and intersections of indexed families of sets">Unions and intersections of indexed families of sets</fr:title><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We adopt the notation that, when <fr:tex
display="inline"><![CDATA[I]]></fr:tex> is an indexing and <fr:tex
display="inline"><![CDATA[\mathcal {F}=\{F_{i}\}_{i\in  I}]]></fr:tex> is an <fr:link
type="local"
href="nst-002D.xml"
addr="nst-002D"
title="Indexed family of sets">Indexed family of sets</fr:link>, we write
<fr:tex
display="block"><![CDATA[\bigcup _{i\in  I}F_{i}:=\bigcup \mathcal {F}]]></fr:tex>
and
<fr:tex
display="block"><![CDATA[\bigcap _{i\in  I}F_{i}:=\bigcap \mathcal {F}.]]></fr:tex>
When <fr:tex
display="inline"><![CDATA[I=\mathbb {N}]]></fr:tex> we write
<fr:tex
display="block"><![CDATA[\bigcup _{i=1}^{\infty }F_{i}:=\bigcup \mathcal {F}]]></fr:tex>
and
<fr:tex
display="block"><![CDATA[\bigcap _{i=1}^{\infty }F_{i}:=\bigcap \mathcal {F}.]]></fr:tex>
Similarly, for finite unions ranging over specific indices in an ordered indexing set, we use the lower and upper limits to demarcate the range of the subfamily of sets.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5522</fr:anchor><fr:addr
type="user">nst-002E</fr:addr><fr:route>nst-002E.xml</fr:route><fr:title
text="Product of family of sets">Product of family of sets</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/card_3.html#K4">card_3:def 5</fr:link></fr:meta><fr:meta
name="source"><fr:link
type="external"
href="https://proofwiki.org/wiki/Definition:Cartesian_Product/Family_of_Sets">Proofwiki</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[I]]></fr:tex> be a set, let <fr:tex
display="inline"><![CDATA[\mathcal {F}=\{F_{i}\}_{i\in  I}]]></fr:tex> be an <fr:link
type="local"
href="nst-002D.xml"
addr="nst-002D"
title="Indexed family of sets">Indexed family of sets</fr:link> indexed by <fr:tex
display="inline"><![CDATA[I]]></fr:tex>. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Product</html:dfn> of <fr:tex
display="inline"><![CDATA[\{F_{i}\}_{i\in  I}]]></fr:tex> to be the set <fr:tex
display="inline"><![CDATA[\prod \mathcal {F}=\prod _{i\in  I}F_{i}]]></fr:tex> such that for any object <fr:tex
display="inline"><![CDATA[x]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[x\in \prod _{i\in  I}]]></fr:tex> if and only if <fr:tex
display="inline"><![CDATA[x]]></fr:tex> if function-like and <fr:tex
display="inline"><![CDATA[\mathop {\textrm {dom}}\nolimits (x)=\mathop {\textrm {dom}}\nolimits (\mathcal {F})]]></fr:tex> and for each <fr:tex
display="inline"><![CDATA[i\in  I]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x_{i}\in  F_{i}]]></fr:tex>.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5524</fr:anchor><fr:addr
type="machine">#450</fr:addr><fr:route>unstable-450.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:strong>Well-definedness:</fr:strong> We should prove this is well-defined, but we see this is equivalent to:
<fr:tex
display="block"><![CDATA[\prod _{i\in  I}F_{i}=\{x\in \mathop {\textrm {Hom}}\nolimits (I,\bigcup _{i\in  I}F_{i})\mid \forall  i\in  I\ldotp  x(i)\in  F_{i}\}.]]></fr:tex>
This is obvious a well-defined set using <fr:link
type="local"
href="nst-0009.xml"
addr="nst-0009"
title="Set builder notation">Set builder notation</fr:link>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 

 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5526</fr:anchor><fr:addr
type="machine">#451</fr:addr><fr:route>unstable-451.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>15</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>We see that when <fr:tex
display="inline"><![CDATA[I=\{0,1\}]]></fr:tex>, this is bijective (but not equal) to <fr:tex
display="inline"><![CDATA[F_{0}\times  F_{1}]]></fr:tex>.</fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5608</fr:anchor><fr:addr
type="user">nst-001R</fr:addr><fr:route>nst-001R.xml</fr:route><fr:title
text="Cardinality and Ordinality">Cardinality and Ordinality</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5610</fr:anchor><fr:addr
type="user">nst-001Q</fr:addr><fr:route>nst-001Q.xml</fr:route><fr:title
text="Finite set">Finite set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Definition 2.4</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>We call a set <fr:tex
display="inline"><![CDATA[A]]></fr:tex> <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Finite</html:dfn> if there exists a non-negative integer <fr:tex
display="inline"><![CDATA[n\in \mathbb {N}_{0}]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\{k\in \mathbb {N}\mid  k\leq  n\}]]></fr:tex> is bijective with <fr:tex
display="inline"><![CDATA[A]]></fr:tex>.</fr:p><fr:p>Otherwise, we call <fr:tex
display="inline"><![CDATA[A]]></fr:tex> <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Infinite</html:dfn>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5612</fr:anchor><fr:addr
type="user">nst-001S</fr:addr><fr:route>nst-001S.xml</fr:route><fr:title
text="Countable set">Countable set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Definition 2.4</fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/card_3.html#V4">card_3:def 14</fr:link></fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/card_3.html#V5">card_3:def 15</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>We call a set <fr:tex
display="inline"><![CDATA[A]]></fr:tex> <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Countable</html:dfn> if there is an injective map <fr:tex
display="inline"><![CDATA[A\to \mathbb {N}]]></fr:tex>.</fr:p><fr:p>Otherwise we call <fr:tex
display="inline"><![CDATA[A]]></fr:tex> <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Uncountable</html:dfn>.</fr:p><fr:p>When <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is infinite, <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is countable iff there is a bijection <fr:tex
display="inline"><![CDATA[A\to \mathbb {N}]]></fr:tex> (or a bijection <fr:tex
display="inline"><![CDATA[\mathbb {N}\to  A]]></fr:tex>). In this case, we will call <fr:tex
display="inline"><![CDATA[A]]></fr:tex> <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Countably Infinite</html:dfn> (or <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Denumerable</html:dfn>).</fr:p><fr:p><fr:strong>Caution:</fr:strong> some authors say <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is countable if there is an bijective function <fr:tex
display="inline"><![CDATA[A\to \mathbb {N}]]></fr:tex>. This seems to be the case among analysts, but I don't think I could live with myself if I were to follow their example.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5614</fr:anchor><fr:addr
type="user">nst-001T</fr:addr><fr:route>nst-001T.xml</fr:route><fr:title
text="Integers are countable">Integers are countable</fr:title><fr:taxon>Example</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Example 2.5</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>The integers <fr:tex
display="inline"><![CDATA[\mathbb {Z}]]></fr:tex> are countable. Consider <fr:tex
display="inline"><![CDATA[f\colon \mathbb {N}_{0}\to \mathbb {Z}]]></fr:tex> such that
<fr:tex
display="block"><![CDATA[f(n)=\begin {cases}(n+1)/2 & n\hbox { is odd}\\ -n/2 & n\hbox { is even}\end {cases}]]></fr:tex>
Then <fr:tex
display="inline"><![CDATA[f]]></fr:tex> is a bijection.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5616</fr:anchor><fr:addr
type="user">nst-001U</fr:addr><fr:route>nst-001U.xml</fr:route><fr:title
text="A set bijective with a countably infinite set is countably infinite">A set bijective with a countably infinite set is countably infinite</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> be a set, let <fr:tex
display="inline"><![CDATA[B]]></fr:tex> be a countably infinite set. Then <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is countably infinite iff there is a bijection <fr:tex
display="inline"><![CDATA[f\colon  A\to  B]]></fr:tex>.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5618</fr:anchor><fr:addr
type="machine">#459</fr:addr><fr:route>unstable-459.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[g\colon  B\to \mathbb {N}]]></fr:tex> be an injective function (since <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is countable). If <fr:tex
display="inline"><![CDATA[f\colon  A\to  B]]></fr:tex> is bijective, then <fr:tex
display="inline"><![CDATA[g\circ  f]]></fr:tex> is injective, hence <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is countable.</fr:p>
<fr:p>If <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is countably infinite, then there is a bijection <fr:tex
display="inline"><![CDATA[g\colon  A\to \mathbb {N}]]></fr:tex>. We have <fr:tex
display="inline"><![CDATA[h\colon  B\to \mathbb {N}]]></fr:tex> be bijective (since <fr:tex
display="inline"><![CDATA[B]]></fr:tex> is countable). Then <fr:tex
display="inline"><![CDATA[h^{-1}\circ  g\colon  A\to  B]]></fr:tex> is bijective.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5620</fr:anchor><fr:addr
type="user">nst-001W</fr:addr><fr:route>nst-001W.xml</fr:route><fr:title
text="Sequence">Sequence</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Definition 2.7</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> be a set. A <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Sequence</html:dfn> of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is a function <fr:tex
display="inline"><![CDATA[f\colon \mathbb {N}\to  A]]></fr:tex>, where we usually write <fr:tex
display="inline"><![CDATA[f_{n}]]></fr:tex> instead of <fr:tex
display="inline"><![CDATA[f(n)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5622</fr:anchor><fr:addr
type="user">nst-001X</fr:addr><fr:route>nst-001X.xml</fr:route><fr:title
text="Enumerating elements of a set">Enumerating elements of a set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Definition 2.7</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> be a countably infinite set. We <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Enumerate</html:dfn> the elements of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> by producing an bijection <fr:tex
display="inline"><![CDATA[\mathbb {N}\to  A]]></fr:tex> as a sequence.</fr:p><fr:p>Conversely, if there is a sequence of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> which is bijective, then we call that sequence an <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Enumeration</html:dfn> of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5624</fr:anchor><fr:addr
type="user">nst-001V</fr:addr><fr:route>nst-001V.xml</fr:route><fr:title
text="Every infinite subset of a countably infinite set is countable">Every infinite subset of a countably infinite set is countable</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Theorem 2.8</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> be a countably infinite set, let <fr:tex
display="inline"><![CDATA[E\subseteq  A]]></fr:tex> be infinite. Then <fr:tex
display="inline"><![CDATA[E]]></fr:tex> is countable.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5626</fr:anchor><fr:addr
type="machine">#458</fr:addr><fr:route>unstable-458.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Since <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is countably infinite, we can enumerate its elements as a sequence <fr:tex
display="inline"><![CDATA[x_{n}]]></fr:tex>.</fr:p>
<fr:p>We can construct a sequence <fr:tex
display="inline"><![CDATA[(n_{k})]]></fr:tex> of positive integers such that <fr:tex
display="inline"><![CDATA[x_{n_{k}}\in  E]]></fr:tex>.</fr:p>
<fr:p>Then we have the sequence <fr:tex
display="inline"><![CDATA[f(k)=x_{n_{k}}]]></fr:tex> which enumerates the elements of <fr:tex
display="inline"><![CDATA[E]]></fr:tex>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5628</fr:anchor><fr:addr
type="user">nst-001Y</fr:addr><fr:route>nst-001Y.xml</fr:route><fr:title
text="Cantor's diagonal argument">Cantor's diagonal argument</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Theorem 2.12</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[E_{n}]]></fr:tex> be a countable collection of countably infinite sets. Then
<fr:tex
display="block"><![CDATA[S=\bigcup ^{\infty }_{n=1}E_{n}]]></fr:tex>
is countably infinite.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5630</fr:anchor><fr:addr
type="machine">#457</fr:addr><fr:route>unstable-457.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>For each <fr:tex
display="inline"><![CDATA[n\in \mathbb {N}]]></fr:tex>, let us form a sequence <fr:tex
display="inline"><![CDATA[(x_{n,k})]]></fr:tex> of elements of <fr:tex
display="inline"><![CDATA[E_{n}]]></fr:tex>. Then we arrange these sequences into an infinite table
<fr:tex
display="block"><![CDATA[\begin {matrix} x_{1,1} & x_{1,2} & x_{1,3} & x_{1,4} & \ldots \\ x_{2,1} & x_{2,2} & x_{2,3} & x_{2,4} & \ldots \\ x_{3,1} & x_{3,2} & x_{3,3} & x_{3,4} & \ldots \\ x_{4,1} & x_{4,2} & x_{4,3} & x_{4,4} & \ldots \\ \vdots  & \vdots  & \vdots  & \vdots  & \ddots  \end {matrix}]]></fr:tex>
Then we form a sequence by ordering the table as <fr:tex
display="inline"><![CDATA[x_{1,1}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{2,1}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{1,2}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{3,1}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{2,2}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{1,3}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{4,1}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{3,2}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{2,3}]]></fr:tex>, <fr:tex
display="inline"><![CDATA[x_{1,4}]]></fr:tex>, …, where we remove duplicate entries as they are encountered. This gives us a countably infinite sequence of <fr:tex
display="inline"><![CDATA[S]]></fr:tex>.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5632</fr:anchor><fr:addr
type="user">nst-001Z</fr:addr><fr:route>nst-001Z.xml</fr:route><fr:title
text="{Q} is countable"><fr:tex
display="inline"><![CDATA[\mathbb {Q}]]></fr:tex> is countable</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Corollary to Theorem 2.13</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>The set of rational numbers is countably infinite.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5634</fr:anchor><fr:addr
type="machine">#456</fr:addr><fr:route>unstable-456.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>We form the countably infinite family <fr:tex
display="inline"><![CDATA[E_{n}=\{z/n\in \mathbb {Q}\mid  z\in \mathbb {Z},\gcd (z,n)=1\}]]></fr:tex> where <fr:tex
display="inline"><![CDATA[n\in \mathbb {N}]]></fr:tex> is a positive integer. Each member is bijective with the integers, which is countably infinite. Then
<fr:tex
display="block"><![CDATA[S=\bigcup ^{\infty }_{n=1}E_{n}]]></fr:tex>
is countably infinite by <fr:link
type="local"
href="nst-001Y.xml"
addr="nst-001Y"
title="Cantor's diagonal argument">Cantor's diagonal argument</fr:link>, and <fr:tex
display="inline"><![CDATA[S]]></fr:tex> bijective to the set <fr:tex
display="inline"><![CDATA[\mathbb {Q}]]></fr:tex>. Hence <fr:tex
display="inline"><![CDATA[\mathbb {Q}]]></fr:tex> is countably infinite.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5636</fr:anchor><fr:addr
type="user">nst-0020</fr:addr><fr:route>nst-0020.xml</fr:route><fr:title
text="Set of all sequences of 0,1 is uncountable">Set of all sequences of <fr:tex
display="inline"><![CDATA[\{0,1\}]]></fr:tex> is uncountable</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source"><fr:link
type="local"
href="baby-rudin.xml"
addr="baby-rudin"
title="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:link>, Theorem 2.14</fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> be the set of all sequences of <fr:tex
display="inline"><![CDATA[\{0,1\}]]></fr:tex>. Then the set <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is uncountable.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5638</fr:anchor><fr:addr
type="machine">#454</fr:addr><fr:route>unstable-454.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[E]]></fr:tex> be any countable subset of <fr:tex
display="inline"><![CDATA[A]]></fr:tex>. Let us enumerate the elements of <fr:tex
display="inline"><![CDATA[E]]></fr:tex> into a sequence <fr:tex
display="inline"><![CDATA[x_{n}]]></fr:tex>. We can construct the sequence <fr:tex
display="inline"><![CDATA[x]]></fr:tex> as follows:
<fr:tex
display="block"><![CDATA[x(n) = \begin {cases}1 & \hbox {if }x_{n}(n)=0\\ 0 & \hbox {if }x_{n}(n)=1\end {cases}]]></fr:tex>
Then <fr:tex
display="inline"><![CDATA[x(n)\neq  x_{n}(n)]]></fr:tex> for all <fr:tex
display="inline"><![CDATA[n\in \mathbb {N}]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[x]]></fr:tex> differs from every element of <fr:tex
display="inline"><![CDATA[E]]></fr:tex>, so <fr:tex
display="inline"><![CDATA[x\in  A\setminus  E]]></fr:tex>.</fr:p>
<fr:p>This means every countably infinite subset of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is a proper subset. This means <fr:tex
display="inline"><![CDATA[A]]></fr:tex> must be uncountable since otherwise it would be a proper subset of itself, which is impossible.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 

 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5640</fr:anchor><fr:addr
type="machine">#455</fr:addr><fr:route>unstable-455.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>This implies <fr:tex
display="inline"><![CDATA[\mathbb {R}]]></fr:tex> is uncountable since <fr:tex
display="inline"><![CDATA[A]]></fr:tex> contains the binary expansion of all real numbers between 0 and 1.</fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5642</fr:anchor><fr:addr
type="user">nst-0021</fr:addr><fr:route>nst-0021.xml</fr:route><fr:title
text="Transitive set">Transitive set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#V1">ordinal1:def 2</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We say <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Transitive</html:dfn> if for all sets <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\subseteq  X]]></fr:tex>. In other words, if <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y\in  X]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[y\in  X]]></fr:tex>. So <fr:tex
display="inline"><![CDATA[\in ]]></fr:tex> forms a transitive relation on <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5644</fr:anchor><fr:addr
type="user">nst-0022</fr:addr><fr:route>nst-0022.xml</fr:route><fr:title
text="Connected set">Connected set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#V2">ordinal1:def 3</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We say <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Connected</html:dfn> if for all sets <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex
display="inline"><![CDATA[y\in  X]]></fr:tex>, if <fr:tex
display="inline"><![CDATA[x\notin  y]]></fr:tex> and <fr:tex
display="inline"><![CDATA[x\neq  y]]></fr:tex>, then <fr:tex
display="inline"><![CDATA[y\in  x]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5646</fr:anchor><fr:addr
type="user">nst-0023</fr:addr><fr:route>nst-0023.xml</fr:route><fr:title
text="Ordinal number">Ordinal number</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#V3">ordinal1:def 4</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>We say a set <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is an <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Ordinal</html:dfn> if <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is <fr:link
type="local"
href="nst-0021.xml"
addr="nst-0021"
title="Transitive set">Transitive set</fr:link> and also <fr:link
type="local"
href="nst-0022.xml"
addr="nst-0022"
title="Connected set">Connected set</fr:link>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5648</fr:anchor><fr:addr
type="user">nst-0024</fr:addr><fr:route>nst-0024.xml</fr:route><fr:title
text="Successor">Successor</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#K1">ordinal1:def 1</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Successor</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to be the set <fr:tex
display="block"><![CDATA[\mathop {\textrm {S}}\nolimits (X):=X\cup \{X\}.]]></fr:tex></fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5650</fr:anchor><fr:addr
type="user">nst-0025</fr:addr><fr:route>nst-0025.xml</fr:route><fr:title
text="Successor of ordinal is an ordinal">Successor of ordinal is an ordinal</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#T17">ordinal1:17</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be an <fr:link
type="local"
href="nst-0023.xml"
addr="nst-0023"
title="Ordinal number">Ordinal number</fr:link>. Then <fr:tex
display="inline"><![CDATA[\mathop {\textrm {S}}\nolimits (X)]]></fr:tex> is an <fr:link
type="local"
href="nst-0023.xml"
addr="nst-0023"
title="Ordinal number">Ordinal number</fr:link>, too.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5652</fr:anchor><fr:addr
type="user">nst-0026</fr:addr><fr:route>nst-0026.xml</fr:route><fr:title
text="Union of ordinal is an ordinal">Union of ordinal is an ordinal</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#T18">ordinal1:18</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be an <fr:link
type="local"
href="nst-0023.xml"
addr="nst-0023"
title="Ordinal number">Ordinal number</fr:link>. Then <fr:tex
display="inline"><![CDATA[\bigcup  X]]></fr:tex> is an <fr:link
type="local"
href="nst-0023.xml"
addr="nst-0023"
title="Ordinal number">Ordinal number</fr:link>, too.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5654</fr:anchor><fr:addr
type="user">nst-0027</fr:addr><fr:route>nst-0027.xml</fr:route><fr:title
text="Limit ordinal">Limit ordinal</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#V4">ordinal1:def 6</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> be a set. We say <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Limit Ordinal</html:dfn> if <fr:tex
display="inline"><![CDATA[A=\bigcup  A]]></fr:tex>.</fr:p><fr:p>Note: this means that <fr:tex
display="inline"><![CDATA[\emptyset ]]></fr:tex> is a limit ordinal.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5656</fr:anchor><fr:addr
type="user">nst-0028</fr:addr><fr:route>nst-0028.xml</fr:route><fr:title
text="Criteria for limit ordinal">Criteria for limit ordinal</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#T28">ordinal1:28</fr:link></fr:meta><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#T29">ordinal1:29</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> be an ordinal number. Then the following are equivalent:</fr:p><fr:ol><fr:li><fr:tex
display="inline"><![CDATA[A]]></fr:tex> is a <fr:link
type="local"
href="nst-0027.xml"
addr="nst-0027"
title="Limit ordinal">Limit ordinal</fr:link></fr:li>
<fr:li>for each ordinal <fr:tex
display="inline"><![CDATA[C\in  A]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[\mathop {\textrm {S}}\nolimits (C)\in  A]]></fr:tex></fr:li>
<fr:li>there is no ordinal <fr:tex
display="inline"><![CDATA[B]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[A=\mathop {\textrm {S}}\nolimits (B)]]></fr:tex></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5658</fr:anchor><fr:addr
type="user">nst-0029</fr:addr><fr:route>nst-0029.xml</fr:route><fr:title
text=" (the set of all finite ordinals)"><fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> (the set of all finite ordinals)</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#K4">ordinal1:def 11</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>We define <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> to be the ordinal such that:
<fr:ol><fr:li>contains zero: <fr:tex
display="inline"><![CDATA[\emptyset \in \omega ]]></fr:tex>, and</fr:li>
<fr:li>limit: <fr:tex
display="inline"><![CDATA[\omega ]]></fr:tex> is a <fr:link
type="local"
href="nst-0027.xml"
addr="nst-0027"
title="Limit ordinal">Limit ordinal</fr:link></fr:li>
<fr:li>smallest such ordinal: for any other ordinal <fr:tex
display="inline"><![CDATA[A]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[\emptyset \in  A]]></fr:tex> and <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is a <fr:link
type="local"
href="nst-0027.xml"
addr="nst-0027"
title="Limit ordinal">Limit ordinal</fr:link>, we have <fr:tex
display="inline"><![CDATA[\omega \subseteq  A]]></fr:tex>.</fr:li></fr:ol></fr:p><fr:p>This is the set theoretic construction of the natural numbers, where <fr:tex
display="inline"><![CDATA[0]]></fr:tex> is identified as <fr:tex
display="inline"><![CDATA[\emptyset ]]></fr:tex>, and for any <fr:tex
display="inline"><![CDATA[n\in \omega ]]></fr:tex> we identify <fr:tex
display="inline"><![CDATA[n+1]]></fr:tex> with <fr:tex
display="inline"><![CDATA[\mathop {\textrm {S}}\nolimits (n)]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5660</fr:anchor><fr:addr
type="user">nst-002C</fr:addr><fr:route>nst-002C.xml</fr:route><fr:title
text="There is no set of all ordinals">There is no set of all ordinals</fr:title><fr:taxon>Theorem</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/card_1.html#T25">card_1:25</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>There is no set <fr:tex
display="inline"><![CDATA[X]]></fr:tex> such that for all ordinals <fr:tex
display="inline"><![CDATA[A]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[A\in  X]]></fr:tex>. In other words, there is no set of all ordinal numbers.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5662</fr:anchor><fr:addr
type="machine">#452</fr:addr><fr:route>unstable-452.xml</fr:route><fr:taxon>Proof</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p><fr:link
type="local"
href="nst-002J.xml"
addr="nst-002J"
title="Proof by contradiction">Proof by contradiction</fr:link>. Assume for contradiction that <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is a set such that for all ordinals <fr:tex
display="inline"><![CDATA[A]]></fr:tex>, we have <fr:tex
display="inline"><![CDATA[A\in  X]]></fr:tex>. Then <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is <fr:link
type="local"
href="nst-0021.xml"
addr="nst-0021"
title="Transitive set">Transitive set</fr:link> and <fr:link
type="local"
href="nst-0022.xml"
addr="nst-0022"
title="Connected set">Connected set</fr:link>, which implies <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is an <fr:link
type="local"
href="nst-0023.xml"
addr="nst-0023"
title="Ordinal number">Ordinal number</fr:link>. Then <fr:tex
display="inline"><![CDATA[X\in  X]]></fr:tex>, which is impossible.</fr:p><html:span
xmlns:html="http://www.w3.org/1999/xhtml"
class="qed">∎</html:span></fr:mainmatter><fr:backmatter /></fr:tree>
 

 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5664</fr:anchor><fr:addr
type="machine">#453</fr:addr><fr:route>unstable-453.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>"The collection of all ordinal numbers" is another example of a <fr:link
type="local"
href="nst-001P.xml"
addr="nst-001P"
title="Classes">proper class</fr:link>.</fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5666</fr:anchor><fr:addr
type="user">nst-002A</fr:addr><fr:route>nst-002A.xml</fr:route><fr:title
text="Cardinal number">Cardinal number</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/card_1.html#V1">card_1:def 1</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[A]]></fr:tex> be an <fr:link
type="local"
href="nst-0023.xml"
addr="nst-0023"
title="Ordinal number">Ordinal number</fr:link>. We say <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Cardinal number</html:dfn> if for every ordinal <fr:tex
display="inline"><![CDATA[B]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is bijective to <fr:tex
display="inline"><![CDATA[B]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[A\subseteq  B]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5668</fr:anchor><fr:addr
type="user">nst-002B</fr:addr><fr:route>nst-002B.xml</fr:route><fr:title
text="Cardinality of a set">Cardinality of a set</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors><fr:meta
name="source">MML <fr:link
type="external"
href="https://mizar.uwb.edu.pl/version/current/html/card_1.html#K1">card_1:def 2</fr:link></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[X]]></fr:tex> be a set. We define the <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Cardinality</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> to be the <fr:link
type="local"
href="nst-002A.xml"
addr="nst-002A"
title="Cardinal number">Cardinal number</fr:link> <fr:tex
display="inline"><![CDATA[|X|]]></fr:tex> such that <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is equipotent with <fr:tex
display="inline"><![CDATA[|X|]]></fr:tex>.</fr:p><fr:p>So the cardinality of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is the smallest <fr:link
type="local"
href="nst-0023.xml"
addr="nst-0023"
title="Ordinal number">Ordinal number</fr:link> bijective with <fr:tex
display="inline"><![CDATA[X]]></fr:tex>.</fr:p><fr:p>Usually, we only care if <fr:tex
display="inline"><![CDATA[|X|]]></fr:tex> is finite or not.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5670</fr:anchor><fr:addr
type="user">nst-002L</fr:addr><fr:route>nst-002L.xml</fr:route><fr:title
text="Choice">Choice</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>The axiom of choice appears in various forms in modern Mathematics. This section may be skipped and returned to when needed.</fr:p><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5560</fr:anchor><fr:addr
type="user">nst-002M</fr:addr><fr:route>nst-002M.xml</fr:route><fr:title
text="Axiom of Choice">Axiom of Choice</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[I]]></fr:tex> be an indexing set. Let <fr:tex
display="inline"><![CDATA[\{S_{i}\}_{i\in  I}]]></fr:tex> be a family of nonempty sets indexed by <fr:tex
display="inline"><![CDATA[I]]></fr:tex>. The axiom of choice asserts the existence of a <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">choice <fr:link
type="local"
href="nst-0014.xml"
addr="nst-0014"
title="Function">function</fr:link></html:dfn>, i.e., an indexed set <fr:tex
display="inline"><![CDATA[(x_{i})_{i\in  I}]]></fr:tex> such that for each <fr:tex
display="inline"><![CDATA[i\in  I]]></fr:tex> we see <fr:tex
display="inline"><![CDATA[x_{i}\in  S_{i}]]></fr:tex>.</fr:p><fr:p>In other words, we can choose "some arbitrary" <fr:tex
display="inline"><![CDATA[x_{i}]]></fr:tex> from <fr:tex
display="inline"><![CDATA[S_{i}]]></fr:tex> for each <fr:tex
display="inline"><![CDATA[i\in  I]]></fr:tex>.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5393</fr:anchor><fr:addr
type="machine">#449</fr:addr><fr:route>unstable-449.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>We stress, the "choice function" is a set-theoretic <fr:link
type="local"
href="nst-0014.xml"
addr="nst-0014"
title="Function">function</fr:link>.</fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5562</fr:anchor><fr:addr
type="user">nst-002P</fr:addr><fr:route>nst-002P.xml</fr:route><fr:title
text="Poset">Poset</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>A <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Partially Ordered Set</html:dfn> (or <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Poset</html:dfn>) is a set <fr:tex
display="inline"><![CDATA[X]]></fr:tex> equipped with a <fr:link
type="local"
href="nst-002O.xml"
addr="nst-002O"
title="Partial Order">Partial Order</fr:link> <fr:tex
display="inline"><![CDATA[\leq ]]></fr:tex> usually denoted as a pair <fr:tex
display="inline"><![CDATA[(X,\leq )]]></fr:tex>.</fr:p><fr:p>Note: not all elements are comparable in a poset, i.e., the trichotomy law (for all <fr:tex
display="inline"><![CDATA[x,y\in  X]]></fr:tex> either <fr:tex
display="inline"><![CDATA[x=y]]></fr:tex> or <fr:tex
display="inline"><![CDATA[x\leq  y]]></fr:tex> or <fr:tex
display="inline"><![CDATA[y\leq  x]]></fr:tex>) does not need to hold.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5564</fr:anchor><fr:addr
type="user">nst-002Q</fr:addr><fr:route>nst-002Q.xml</fr:route><fr:title
text="Chain">Chain</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[(X,\leq )]]></fr:tex> be a nonempty <fr:link
type="local"
href="nst-002P.xml"
addr="nst-002P"
title="Poset">Poset</fr:link>. A <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Chain</html:dfn> is a subset <fr:tex
display="inline"><![CDATA[C\subseteq  X]]></fr:tex> such that for all <fr:tex
display="inline"><![CDATA[x,y\in  C]]></fr:tex> either <fr:tex
display="inline"><![CDATA[x\leq  y]]></fr:tex> or <fr:tex
display="inline"><![CDATA[y\leq  x]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5566</fr:anchor><fr:addr
type="user">nst-002R</fr:addr><fr:route>nst-002R.xml</fr:route><fr:title
text="Upper bound">Upper bound</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[(X,\leq )]]></fr:tex> be a nonempty <fr:link
type="local"
href="nst-002P.xml"
addr="nst-002P"
title="Poset">Poset</fr:link>. Let <fr:tex
display="inline"><![CDATA[A\subseteq  X]]></fr:tex> be some subset. An <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Upper Bound</html:dfn> of <fr:tex
display="inline"><![CDATA[A]]></fr:tex> is an element <fr:tex
display="inline"><![CDATA[u\in  X]]></fr:tex> such that for all <fr:tex
display="inline"><![CDATA[a\in  A]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[a\leq  u]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5568</fr:anchor><fr:addr
type="user">nst-002S</fr:addr><fr:route>nst-002S.xml</fr:route><fr:title
text="Maximal element">Maximal element</fr:title><fr:taxon>Definition</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[(X,\leq )]]></fr:tex> be a nonempty <fr:link
type="local"
href="nst-002P.xml"
addr="nst-002P"
title="Poset">Poset</fr:link>. A <html:dfn
xmlns:html="http://www.w3.org/1999/xhtml">Maximal Element</html:dfn> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> is an element <fr:tex
display="inline"><![CDATA[m\in  X]]></fr:tex> such that for all <fr:tex
display="inline"><![CDATA[x\in  X]]></fr:tex> we have <fr:tex
display="inline"><![CDATA[x\leq  m]]></fr:tex>.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>5570</fr:anchor><fr:addr
type="user">zorn's-lemma</fr:addr><fr:route>zorn's-lemma.xml</fr:route><fr:title
text="Zorn's lemma">Zorn's lemma</fr:title><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>Let <fr:tex
display="inline"><![CDATA[(X,\leq )]]></fr:tex> be a nonempty <fr:link
type="local"
href="nst-002P.xml"
addr="nst-002P"
title="Poset">Poset</fr:link>. If every <fr:link
type="local"
href="nst-002Q.xml"
addr="nst-002Q"
title="Chain">chain</fr:link> of <fr:tex
display="inline"><![CDATA[X]]></fr:tex> has an <fr:link
type="local"
href="nst-002R.xml"
addr="nst-002R"
title="Upper bound">upper bound</fr:link>, then <fr:tex
display="inline"><![CDATA[X]]></fr:tex> has a <fr:link
type="local"
href="nst-002S.xml"
addr="nst-002S"
title="Maximal element">Maximal element</fr:link>.</fr:p>
 
   
   <fr:tree
toc="false"
numbered="true"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>1581</fr:anchor><fr:addr
type="machine">#244</fr:addr><fr:route>unstable-244.xml</fr:route><fr:taxon>Remark</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>This is logically equivalent to the <fr:link
type="local"
href="nst-002M.xml"
addr="nst-002M"
title="Axiom of Choice">Axiom of Choice</fr:link>.</fr:mainmatter><fr:backmatter /></fr:tree>
 
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="References">References</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>15415</fr:anchor><fr:addr
type="user">banakh-2020-classical</fr:addr><fr:route>banakh-2020-classical.xml</fr:route><fr:title
text="Classical Set Theory: Theory of Sets and Classes">Classical Set Theory: Theory of Sets and Classes</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>2020</fr:year></fr:date><fr:authors><fr:author><fr:link
type="local"
href="taras-banakh.xml"
addr="taras-banakh"
title="Taras Banakh">Taras Banakh</fr:link></fr:author></fr:authors><fr:meta
name="external">https://arxiv.org/abs/2006.01613</fr:meta><fr:meta
name="bibtex"><![CDATA[@misc{banakh2020classical,
      title={Classical Set Theory: Theory of Sets and Classes}, 
      author={Taras Banakh},
      year={2020},
      eprint={2006.01613},
      archivePrefix={arXiv},
      primaryClass={math.LO},
      url={https://arxiv.org/abs/2006.01613}, 
}]]></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>Lecture notes about <fr:tex
display="inline"><![CDATA[\mathsf {NBG}]]></fr:tex> axioms.</fr:p></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>15417</fr:anchor><fr:addr
type="user">baby-rudin</fr:addr><fr:route>baby-rudin.xml</fr:route><fr:title
text="Principles of Mathematical Analysis">Principles of Mathematical Analysis</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>1976</fr:year></fr:date><fr:authors><fr:author><fr:link
type="local"
href="walter-rudin.xml"
addr="walter-rudin"
title="Walter Rudin">Walter Rudin</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@book{rudin1976principles,
author={Rudin, Walter},
title={{Principles of Mathematical Analysis}},
year={1976},
edition={McGraw Hill},
publisher={third}
}]]></fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>15419</fr:anchor><fr:addr
type="user">halmos-1974-naive</fr:addr><fr:route>halmos-1974-naive.xml</fr:route><fr:title
text="Naive Set Theory">Naive Set Theory</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>1974</fr:year></fr:date><fr:authors><fr:author><fr:link
type="local"
href="paul-r-halmos.xml"
addr="paul-r-halmos"
title="Paul R. Halmos">Paul R. Halmos</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@book{halmos1974naive,
  author={Halmos, Paul},
  title={Naive Set Theory},
  year={1974},
  publisher={D. Van Nostrand Company Inc.}
}]]></fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>15421</fr:anchor><fr:addr
type="user">bourbaki-1968-theory</fr:addr><fr:route>bourbaki-1968-theory.xml</fr:route><fr:title
text="Theory of Sets">Theory of Sets</fr:title><fr:taxon>Reference</fr:taxon><fr:date><fr:year>1968</fr:year></fr:date><fr:authors><fr:author><fr:link
type="local"
href="nicolas-bourbaki.xml"
addr="nicolas-bourbaki"
title="Nicolas Bourbaki">Nicolas Bourbaki</fr:link></fr:author></fr:authors><fr:meta
name="bibtex"><![CDATA[@book{bourbaki1968theory,
  author={Bourbaki, Nicolas},
  title={Theory of Sets},
  year={1968},
  publisher={Springer}
}]]></fr:meta></fr:frontmatter><fr:mainmatter><fr:p>This actually describes an axiomatic set theory roughly as strong as Z (not ZF), but uses Hilbert's epsilon calculus which is much stronger than first-order logic. It gives Bourbaki something <fr:em>even stronger</fr:em> than the global choice operator "for free".</fr:p></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree
toc="false"
numbered="false"
show-heading="true"
show-metadata="false"
expanded="true"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:title
text="Backlinks">Backlinks</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree
toc="true"
numbered="false"
show-heading="true"
show-metadata="true"
expanded="false"
root="false"
xmlns:fr="http://www.jonmsterling.com/jms-005P.xml"><fr:frontmatter><fr:anchor>15423</fr:anchor><fr:addr
type="user">index</fr:addr><fr:route>index.xml</fr:route><fr:title
text="Forests of Mathematics">Forests of Mathematics</fr:title><fr:date><fr:year>2025</fr:year><fr:month>5</fr:month><fr:day>12</fr:day></fr:date><fr:authors><fr:author><fr:link
type="local"
href="alex-nelson.xml"
addr="alex-nelson"
title="Alex Nelson">Alex Nelson</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter><fr:p>This roughly corresponds to my "mental model" of Mathematics as I have learned it. For more rambling about this, see the <fr:link
type="local"
href="preface.xml"
addr="preface"
title="Preface">Preface</fr:link>. For feedback, feel free to file an <fr:link
type="external"
href="https://github.com/pqnelson/math/issues">issue</fr:link> on Github, or send me an email (<fr:code>pqnelson at remove this GMAIL dot</fr:code> com).</fr:p><fr:ol><fr:li><fr:link
type="local"
href="preface.xml"
addr="preface"
title="Preface">Preface</fr:link></fr:li>
<fr:li><fr:link
type="local"
href="ela.xml"
addr="ela"
title="Elementary linear algebra">Elementary linear algebra</fr:link></fr:li> <fr:li><fr:link
type="local"
href="nst.xml"
addr="nst"
title="Naive set theory">Naive set theory</fr:link></fr:li> <fr:li><fr:link
type="local"
href="ila.xml"
addr="ila"
title="Intermediate linear algebra">Intermediate linear algebra</fr:link></fr:li> <fr:li><fr:link
type="local"
href="ca.xml"
addr="ca"
title="Classical Analysis">Classical Analysis</fr:link></fr:li>  <fr:li><fr:link
type="local"
href="iaa.xml"
addr="iaa"
title="Introduction to Abstract Algebra">Introduction to Abstract Algebra</fr:link> <fr:ol><fr:li><fr:link
type="local"
href="iaa-0003.xml"
addr="iaa-0003"
title="Preferatory notes">Preferatory notes</fr:link></fr:li> <fr:li><fr:link
type="local"
href="iaa-0001.xml"
addr="iaa-0001"
title="Traditional Introduction to Groups">Traditional Introduction to Groups</fr:link></fr:li> <fr:li><fr:link
type="local"
href="iaa-0008.xml"
addr="iaa-0008"
title="Traditional Introduction to Rings">Traditional Introduction to Rings</fr:link></fr:li> <fr:li><fr:link
type="local"
href="iaa-0009.xml"
addr="iaa-0009"
title="Traditional Introduction to Modules">Traditional Introduction to Modules</fr:link></fr:li> <fr:li><fr:link
type="local"
href="iaa-000B.xml"
addr="iaa-000B"
title="Traditional Treatment of Galois Theory">Traditional Treatment of Galois Theory</fr:link></fr:li></fr:ol></fr:li>
<fr:li><fr:link
type="local"
href="ac.xml"
addr="ac"
title="Commutative Algebra">Commutative Algebra</fr:link></fr:li>  <fr:li><fr:link
type="local"
href="sl.xml"
addr="sl"
title="Special linear group">Special linear group</fr:link></fr:li>
<fr:li><fr:link
type="local"
href="jordan.xml"
addr="jordan"
title="Jordan algebras">Jordan algebras</fr:link></fr:li></fr:ol></fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>