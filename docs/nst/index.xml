<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>12</fr:month>
      <fr:day>9</fr:day>
    </fr:date>
    <fr:uri>http://localhost:8000/nst/</fr:uri>
    <fr:display-uri>nst</fr:display-uri>
    <fr:route>/nst/</fr:route>
    <fr:title text="Naive set theory">Naive set theory</fr:title>
  </fr:frontmatter>
  <fr:mainmatter>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors>
          <fr:author>
            <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
          </fr:author>
        </fr:authors>
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>12</fr:month>
          <fr:day>9</fr:day>
        </fr:date>
        <fr:uri>http://localhost:8000/nst-000P/</fr:uri>
        <fr:display-uri>nst-000P</fr:display-uri>
        <fr:route>/nst-000P/</fr:route>
        <fr:title text="Basic concepts and constructions of naive set theory">Basic concepts and constructions of naive set theory</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-002H/</fr:uri>
            <fr:display-uri>nst-002H</fr:display-uri>
            <fr:route>/nst-002H/</fr:route>
            <fr:title text="Proof strategies">Proof strategies</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>There are various common "strategies" for proving various claims in Mathematics. We will review the basic strategies here.</html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-002G/</fr:uri>
                <fr:display-uri>nst-002G</fr:display-uri>
                <fr:route>/nst-002G/</fr:route>
                <fr:title text="Direct proof">Direct proof</fr:title>
                <fr:taxon>proof strategy</fr:taxon>
              </fr:frontmatter>
              <fr:mainmatter><html:p>When trying to prove a claim of the form "If <fr:tex display="inline"><![CDATA[P]]></fr:tex>, then <fr:tex display="inline"><![CDATA[Q]]></fr:tex>", a direct proof has the following skeleton:</html:p>
  <html:blockquote>Assume <fr:tex display="inline"><![CDATA[P]]></fr:tex>. [Intermediate proof steps] Thus <fr:tex display="inline"><![CDATA[Q]]></fr:tex>.</html:blockquote>
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-002I/</fr:uri>
                <fr:display-uri>nst-002I</fr:display-uri>
                <fr:route>/nst-002I/</fr:route>
                <fr:title text="Proof by contrapositive">Proof by contrapositive</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>We can take advantage of the fact that "If <fr:tex display="inline"><![CDATA[P]]></fr:tex> then <fr:tex display="inline"><![CDATA[Q]]></fr:tex>" has the same truth table as "If not <fr:tex display="inline"><![CDATA[Q]]></fr:tex>, then not <fr:tex display="inline"><![CDATA[P]]></fr:tex>". This "Not <fr:tex display="inline"><![CDATA[Q]]></fr:tex> implies not <fr:tex display="inline"><![CDATA[P]]></fr:tex>" is called the <html:dfn>Contrapositive</html:dfn> of "<fr:tex display="inline"><![CDATA[P]]></fr:tex> implies <fr:tex display="inline"><![CDATA[Q]]></fr:tex>". Usually we embark on a <fr:link href="/nst-002G/" title="Direct proof" uri="http://localhost:8000/nst-002G/" display-uri="nst-002G" type="local">Direct proof</fr:link> and so the proof looks like:</html:p>
  <html:blockquote>Assume not <fr:tex display="inline"><![CDATA[Q]]></fr:tex>. [Intermediate proof steps.] Hence not <fr:tex display="inline"><![CDATA[P]]></fr:tex>.</html:blockquote>
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-002J/</fr:uri>
                <fr:display-uri>nst-002J</fr:display-uri>
                <fr:route>/nst-002J/</fr:route>
                <fr:title text="Proof by contradiction">Proof by contradiction</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>When trying to prove the claim <fr:tex display="inline"><![CDATA[P]]></fr:tex>, it is useful to use the fact that its double negation "Not (not <fr:tex display="inline"><![CDATA[P]]></fr:tex>)" is logically equivalent to <fr:tex display="inline"><![CDATA[P]]></fr:tex>, and then use the fact  that "Not <fr:tex display="inline"><![CDATA[Q]]></fr:tex>" is logically equivalent to "If <fr:tex display="inline"><![CDATA[Q]]></fr:tex> then contradiction". Taken together, <fr:tex display="inline"><![CDATA[P]]></fr:tex> is logically equivalent to "If not <fr:tex display="inline"><![CDATA[P]]></fr:tex>, then contradiction." This is a proof by contradiction.</html:p>
                <html:p>When <fr:tex display="inline"><![CDATA[P]]></fr:tex> is an implication "If <fr:tex display="inline"><![CDATA[H]]></fr:tex> then <fr:tex display="inline"><![CDATA[R]]></fr:tex>", a proof by contradiction looks like "If <fr:tex display="inline"><![CDATA[H]]></fr:tex> and not <fr:tex display="inline"><![CDATA[R]]></fr:tex>, then contradiction".</html:p>
              </fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>12</fr:month>
                  <fr:day>15</fr:day>
                </fr:date>
                <fr:uri>http://localhost:8000/nst-002K/</fr:uri>
                <fr:display-uri>nst-002K</fr:display-uri>
                <fr:route>/nst-002K/</fr:route>
                <fr:title text="Proof by induction">Proof by induction</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>If we have a claim which is a formula indexed by natural numbers <fr:tex display="inline"><![CDATA[P[n]]]></fr:tex>, then a proof by induction on <fr:tex display="inline"><![CDATA[n]]></fr:tex> looks like:</html:p>
                <html:ol><html:li><html:strong>Base case:</html:strong> For <fr:tex display="inline"><![CDATA[n=0]]></fr:tex> (or <fr:tex display="inline"><![CDATA[n=1]]></fr:tex>), prove <fr:tex display="inline"><![CDATA[P[0]]]></fr:tex> (resp., <fr:tex display="inline"><![CDATA[P[1]]]></fr:tex>).</html:li>
<html:li><html:strong>Inductive argument:</html:strong> For arbitrary <fr:tex display="inline"><![CDATA[n]]></fr:tex>, prove the claim "If <fr:tex display="inline"><![CDATA[P[n]]]></fr:tex> then <fr:tex display="inline"><![CDATA[P[n+1]]]></fr:tex>". Usually this is done by a <fr:link href="/nst-002G/" title="Direct proof" uri="http://localhost:8000/nst-002G/" display-uri="nst-002G" type="local">Direct proof</fr:link> and we call the statement "Assume <fr:tex display="inline"><![CDATA[P[n]]]></fr:tex>" the <html:dfn>Inductive Hypothesis</html:dfn>.</html:li></html:ol>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000R/</fr:uri>
            <fr:display-uri>nst-000R</fr:display-uri>
            <fr:route>/nst-000R/</fr:route>
            <fr:title text="Ontology of Mathematics">Ontology of Mathematics</fr:title>
            <fr:taxon>remark</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>What are the basic "things" we work with in Mathematics? It may seem that we have numbers, functions, and quite possibly other objects.</html:p><html:p>Broadly speaking, we could describe Mathematics as working with "sets" (unordered collections of stuff) and "objects" (any generic term or object).</html:p><html:p>In practice, there are compelling reasons to stipulate that <html:em>everything</html:em> in Mathematics consists of sets. This should be understood as saying that sets form the "machine code" of Mathematics. This is explicitly stated in Bourbaki's <fr:link href="/bourbaki-1968-theory/" title="Theory of Sets" uri="http://localhost:8000/bourbaki-1968-theory/" display-uri="bourbaki-1968-theory" type="local">Theory of Sets</fr:link>, II §1.1 (bottom of page 65 of English edition):</html:p>
  <html:blockquote><html:p>From a "naive" point of view, many mathematical entities can be formalized as collections or "sets" of objects. We do not seek to formalize this notion, and in the formalistic interpretation of what follows, the word "set" is to be considered as strictly synonymous with "term".</html:p></html:blockquote>
<html:p>We will just stipulate that everything in Mathematics may be considered as an instance of some abstract type we call an "object". We extend this with a subtype called a "set". All sets are objects.</html:p><html:p>But some Mathematicians want to discuss the collection of all sets. This can't possibly be a set (otherwise we run into Russell's paradox), so we need to either modify our ontology (and work with "classes" instead of "sets", and call a class a "set" when it's a member of a class) or extend our ontology (to include a "class" as a third species of object). We will discuss this when the time comes, but the ontology is mildly flexible.</html:p></fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0001/</fr:uri>
            <fr:display-uri>nst-0001</fr:display-uri>
            <fr:route>/nst-0001/</fr:route>
            <fr:title text="Set">Set</fr:title>
            <fr:taxon>provisional definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We [pretend to] define a [naive] <html:dfn>Set</html:dfn> to be a well-defined unordered collection of objects.</html:p>
            <html:p>If <fr:tex display="inline"><![CDATA[x]]></fr:tex> is an object and <fr:tex display="inline"><![CDATA[X]]></fr:tex> is a set, then we write <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> if <fr:tex display="inline"><![CDATA[x]]></fr:tex> is an element (or member) of <fr:tex display="inline"><![CDATA[X]]></fr:tex>. If <fr:tex display="inline"><![CDATA[x]]></fr:tex> is not an element of <fr:tex display="inline"><![CDATA[X]]></fr:tex>, then we write <fr:tex display="inline"><![CDATA[x\notin  X]]></fr:tex>.</html:p>
            <html:p>We will also write <fr:tex display="inline"><![CDATA[X\ni  x]]></fr:tex> as a synonym for <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex>. We also write <fr:tex display="inline"><![CDATA[X\not \ni  x]]></fr:tex>.</html:p>
            <html:p>This isn't really a definition, because set theory is given axiomatically. We usually give axioms to specify the behaviour of the binary infixed predicate <fr:tex display="inline"><![CDATA[\in ]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000C/</fr:uri>
            <fr:display-uri>nst-000C</fr:display-uri>
            <fr:route>/nst-000C/</fr:route>
            <fr:title text="Proving well-definedness of terms">Proving well-definedness of terms</fr:title>
            <fr:taxon>remark</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>When we define a new term in Mathematics, we should prove it is well-defined. What this proof requires depends on what we're defining.</html:p>
            <html:ul><html:li>A new constant (possibly parametrized by other objects) <fr:tex display="inline"><![CDATA[C]]></fr:tex> defined as satisfying some condition <fr:tex display="inline"><![CDATA[\Phi [C]]]></fr:tex> requires proving (1) its existence (i.e, proving <fr:tex display="inline"><![CDATA[\exists  x\ldotp \Phi [x]]]></fr:tex>), and (2) its uniqueness (i.e., <fr:tex display="inline"><![CDATA[\forall  x,y\ldotp \Phi [x]\land \Phi [y]\implies  x=y]]></fr:tex>).</html:li>
<html:li>A new constant <fr:tex display="inline"><![CDATA[C]]></fr:tex> which is defined as abbreviating some complicated expression is usually well-defined, sometimes we need to prove it has the "correct type".</html:li>
<html:li>A new species of thing (like a vector space or a <fr:link href="/field-0001/" title="Field" uri="http://localhost:8000/field-0001/" display-uri="field-0001" type="local">Field</fr:link>) should require proving the existence of at least one such gadget.</html:li>
<html:li>All other types of definitions (predicates, adjectives, etc.) are well-defined.</html:li></html:ul>
            <html:p>One of the reasons why the <fr:link href="/nst-0001/" title="Set" uri="http://localhost:8000/nst-0001/" display-uri="nst-0001" type="local">"definition" of a set</fr:link> is not really a definition is because we should prove the existence of a set, but that's not possible. It's also why Mathematicians invented <html:em>axiomatic</html:em> set theory: presumably there are mathematical objects called "sets" which already exist, and we're trying to specify their behaviour (or some reasonable approximation) using axioms.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000U/</fr:uri>
            <fr:display-uri>nst-000U</fr:display-uri>
            <fr:route>/nst-000U/</fr:route>
            <fr:title text="Examples of common sets">Examples of common sets</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We have some very common sets encountered in Mathematics, so we have special notation for them:</html:p>
            <html:ul><html:li><fr:tex display="inline"><![CDATA[\mathbb {N}_{0}=\{0,1,2,3,…\}]]></fr:tex> the set of all non-negative integers</html:li>
<html:li><fr:tex display="inline"><![CDATA[\mathbb {N}=\{1,2,3,4,…\}]]></fr:tex> the set of all positive integers</html:li>
<html:li><fr:tex display="inline"><![CDATA[\mathbb {Z}=\{…,-3,-2,-1,0,1,2,3,…\}]]></fr:tex> the set of all integers</html:li>
<html:li><fr:tex display="inline"><![CDATA[\mathbb {Q}=\{\frac {m}{n}\mid  m\in \mathbb {Z},n\in \mathbb {N}]]></fr:tex> the set of all rational numbers</html:li>
<html:li><fr:tex display="inline"><![CDATA[\mathbb {R}]]></fr:tex> the set of real numbers</html:li>
<html:li><fr:tex display="inline"><![CDATA[\mathbb {C}=\{x+\mathrm {i} y\mid  x,y\in \mathbb {R}\}]]></fr:tex> the set of complex numbers</html:li></html:ul>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0002/</fr:uri>
            <fr:display-uri>nst-0002</fr:display-uri>
            <fr:route>/nst-0002/</fr:route>
            <fr:title text="Finite sets">Finite sets</fr:title>
            <fr:taxon>notation</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>If we have a set consisting of finitely many elements, we write it out as a comma-separated list delimited by <fr:tex display="inline"><![CDATA[\{…\}]]></fr:tex>.</html:p>
            <html:p>For example, the set of prime numbers less than 10 is <fr:tex display="inline"><![CDATA[\{2,3,5,7\}]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0003/</fr:uri>
            <fr:display-uri>nst-0003</fr:display-uri>
            <fr:route>/nst-0003/</fr:route>
            <fr:title text="Empty set">Empty set</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be a set. We say <fr:tex display="inline"><![CDATA[X]]></fr:tex> is <html:dfn>Empty</html:dfn> if there is no object <fr:tex display="inline"><![CDATA[x]]></fr:tex> such that <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0004/</fr:uri>
            <fr:display-uri>nst-0004</fr:display-uri>
            <fr:route>/nst-0004/</fr:route>
            <fr:title text="Set equality">Set equality</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the predicate <html:dfn>Set Equality</html:dfn> (or just <html:em>equality</html:em>) of <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex>, denoted <fr:tex display="inline"><![CDATA[X=Y]]></fr:tex>, to mean they have the same elements; i.e., for all objects <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> if and only if <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>.</html:p>
            <html:p>When <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> are not equal, we write <fr:tex display="inline"><![CDATA[X\neq  Y]]></fr:tex>.</html:p>
            <html:p>(This is technically an axiom of ZFC called the "axiom of extensionality".)</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0005/</fr:uri>
            <fr:display-uri>nst-0005</fr:display-uri>
            <fr:route>/nst-0005/</fr:route>
            <fr:title text="The empty set">The empty set</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>We define <html:em>the</html:em> empty set to be the constant denoted <fr:tex display="inline"><![CDATA[\emptyset ]]></fr:tex> (or sometimes <fr:tex display="inline"><![CDATA[\{\}]]></fr:tex>).</html:p><html:p>We need to prove this is well-defined. For constants, this means proving it exists and is unique.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><html:strong>Existence:</html:strong> Take the empty list as a set <fr:tex display="inline"><![CDATA[\{\}]]></fr:tex>. This is clearly empty.</html:p>

<html:p><html:strong>Uniqueness:</html:strong> Suppose we have <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> both be empty sets. We want to prove <fr:tex display="inline"><![CDATA[X=Y]]></fr:tex>. Then for any object <fr:tex display="inline"><![CDATA[x]]></fr:tex>, we want to prove (1) if <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> then <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>, and (2) if <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex> then <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex>.</html:p>

<html:p>(1) <fr:link href="/nst-002J/" title="Proof by contradiction" uri="http://localhost:8000/nst-002J/" display-uri="nst-002J" type="local">Proof by contradiction</fr:link>. Assume <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex>. But <fr:tex display="inline"><![CDATA[X]]></fr:tex> is <fr:link href="/nst-0004/" title="Set equality" uri="http://localhost:8000/nst-0004/" display-uri="nst-0004" type="local">empty</fr:link>, so <fr:tex display="inline"><![CDATA[X]]></fr:tex> cannot have any members. Then we have a contradiction. Hence we can conclude whatever we want, in particular <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>.</html:p>

<html:p>(2) The argument is the same but switching <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex>.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0006/</fr:uri>
            <fr:display-uri>nst-0006</fr:display-uri>
            <fr:route>/nst-0006/</fr:route>
            <fr:title text="Subset">Subset</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the predicate <fr:tex display="inline"><![CDATA[X\subseteq  Y]]></fr:tex> to mean: for any object <fr:tex display="inline"><![CDATA[x]]></fr:tex>, if <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> then <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>. In other words, all elements of <fr:tex display="inline"><![CDATA[X]]></fr:tex> are also elements of <fr:tex display="inline"><![CDATA[Y]]></fr:tex>. (This is very different than <fr:tex display="inline"><![CDATA[X]]></fr:tex> is an element of <fr:tex display="inline"><![CDATA[Y]]></fr:tex>!)</html:p>
            <html:p>We write <fr:tex display="inline"><![CDATA[Y\supseteq  X]]></fr:tex> as a synonym for <fr:tex display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>.</html:p>
            <html:p>We also write <fr:tex display="inline"><![CDATA[X\nsubseteq  Y]]></fr:tex> as the antonym for <fr:tex display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>, and <fr:tex display="inline"><![CDATA[Y\nsupseteq  X]]></fr:tex> for the antonym of <fr:tex display="inline"><![CDATA[Y\supseteq  X]]></fr:tex>.</html:p>
            <html:p>Observe that <fr:tex display="inline"><![CDATA[X\subseteq  X]]></fr:tex> for any set <fr:tex display="inline"><![CDATA[X]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0007/</fr:uri>
            <fr:display-uri>nst-0007</fr:display-uri>
            <fr:route>/nst-0007/</fr:route>
            <fr:title text="Proper subset">Proper subset</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the predicate <fr:tex display="inline"><![CDATA[X\subset  Y]]></fr:tex> to mean <fr:tex display="inline"><![CDATA[X\subseteq  Y]]></fr:tex> and <fr:tex display="inline"><![CDATA[X\neq  Y]]></fr:tex>.</html:p>
            <html:p>We also have the synonym <fr:tex display="inline"><![CDATA[Y\supset  X]]></fr:tex> for <fr:tex display="inline"><![CDATA[X\subset  Y]]></fr:tex>.</html:p>
            <html:p>The choice of notation varies wildly. Some authors do not even distinguish proper subsets from "improper" subsets. Worse, some use <fr:tex display="inline"><![CDATA[\subset ]]></fr:tex> for improper subsets. We have chosen to use notation analogous to <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\lt ]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0008/</fr:uri>
            <fr:display-uri>nst-0008</fr:display-uri>
            <fr:route>/nst-0008/</fr:route>
            <fr:title text="Proving two sets are equal">Proving two sets are equal</fr:title>
            <fr:taxon>strategy</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Generically, when we want to prove <fr:link href="/nst-0004/" title="Set equality" uri="http://localhost:8000/nst-0004/" display-uri="nst-0004" type="local">Set equality</fr:link> like proving <fr:tex display="inline"><![CDATA[X=Y]]></fr:tex>, we can use the <fr:link href="/nst-0006/" title="Subset" uri="http://localhost:8000/nst-0006/" display-uri="nst-0006" type="local">Subset</fr:link> predicate to prove two claims: (1) <fr:tex display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>, (2) <fr:tex display="inline"><![CDATA[Y\subseteq  X]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0009/</fr:uri>
            <fr:display-uri>nst-0009</fr:display-uri>
            <fr:route>/nst-0009/</fr:route>
            <fr:title text="Set builder notation">Set builder notation</fr:title>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.2</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>There are times when the notation for <fr:link href="/nst-0002/" title="Finite sets" uri="http://localhost:8000/nst-0002/" display-uri="nst-0002" type="local">Finite sets</fr:link> is clunky or impractical (e.g., write out the first <fr:tex display="inline"><![CDATA[10^{120}]]></fr:tex> prime numbers). We have another notation for describing a set: if <fr:tex display="inline"><![CDATA[P[x]]]></fr:tex> is a unary predicate and <fr:tex display="inline"><![CDATA[X]]></fr:tex> is a set, then we write
<fr:tex display="block"><![CDATA[\{x\in  X\mid  P[x]\}]]></fr:tex>
which describes "The set of <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> such that <fr:tex display="inline"><![CDATA[P[x]]]></fr:tex> holds". The vertical bar ("|") is read "such that". The allowable predicates <fr:tex display="inline"><![CDATA[P[-]]]></fr:tex> must form a valid <fr:link href="/nst-000A/" title="Sentences in set theory" uri="http://localhost:8000/nst-000A/" display-uri="nst-000A" type="local">sentence</fr:link>. (This form of set builder notation is called "the axiom scheme of specification" in ZFC set theory.)</html:p>
            <html:p>The other form of set builder notation which appears frequently: if <fr:tex display="inline"><![CDATA[F(-)]]></fr:tex> is some construction, and <fr:tex display="inline"><![CDATA[P[-]]]></fr:tex> is a unary predicate, and <fr:tex display="inline"><![CDATA[X]]></fr:tex> is a set, then
<fr:tex display="block"><![CDATA[\{F(x)\mid  x\in  X,P[x]\}]]></fr:tex>
describes the set obtained by applying <fr:tex display="inline"><![CDATA[F]]></fr:tex> to each element of <fr:tex display="inline"><![CDATA[X]]></fr:tex> which satisfies the predicate <fr:tex display="inline"><![CDATA[P]]></fr:tex>.</html:p>
            <html:p>The Working Mathematician usually "suppresses" (omits) the <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> clause when it is understood.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000A/</fr:uri>
            <fr:display-uri>nst-000A</fr:display-uri>
            <fr:route>/nst-000A/</fr:route>
            <fr:title text="Sentences in set theory">Sentences in set theory</fr:title>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.2</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The allowed sentences or predicates appearing in set builder notation may be described recursively.</html:p>
            <html:p>We can describe what possible formulas appear using the following:</html:p>
            <html:ul><html:li><fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex display="inline"><![CDATA[X=Y]]></fr:tex> are the atomic formulas</html:li>
<html:li>"not &lt;formula&gt;"</html:li>
<html:li>"&lt;formula&gt; and &lt;formula&gt;" or just a comma-separated list of formulas, all of which are expected to hold</html:li>
<html:li>"&lt;formula&gt; or &lt;formula&gt;" for the disjunction of formulas (in the sense of "either &lt;formula&gt; or &lt;formula&gt; or both")</html:li>
<html:li>"if &lt;formula&gt; then &lt;formula&gt;" (or "&lt;formula&gt; implies &lt;formula&gt;")</html:li>
<html:li>"&lt;formula&gt; iff &lt;formula&gt;"</html:li>
<html:li>"for all …"</html:li>
<html:li>"for some …" (or "exists …")</html:li></html:ul>
            <html:p>… as well as using any predicates we've defined (like the <fr:link href="/nst-0006/" title="Subset" uri="http://localhost:8000/nst-0006/" display-uri="nst-0006" type="local">Subset</fr:link> predicate).</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001N/</fr:uri>
            <fr:display-uri>nst-001N</fr:display-uri>
            <fr:route>/nst-001N/</fr:route>
            <fr:title text="Russell's paradox">Russell's paradox</fr:title>
            <fr:taxon>theorem</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Suppose we try defining the set
<fr:tex display="block"><![CDATA[R=\{S\hbox { is a set}\mid  S\notin  S\}.]]></fr:tex>
Then we obtain a contradiction if such a set exists. (The solution is to restrict what set-builder notation.)</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Well, assume <fr:tex display="inline"><![CDATA[R]]></fr:tex> exists. We will prove we obtain a contradiction. Our proof is by cases: either <fr:tex display="inline"><![CDATA[R\in  R]]></fr:tex> or <fr:tex display="inline"><![CDATA[R\notin  R]]></fr:tex>.</html:p>
<html:p><html:strong>Case 1:</html:strong> Assume <fr:tex display="inline"><![CDATA[R\in  R]]></fr:tex>. Then this means <fr:tex display="inline"><![CDATA[R\notin  R]]></fr:tex>. But we have both <fr:tex display="inline"><![CDATA[R\in  R]]></fr:tex> and <fr:tex display="inline"><![CDATA[R\notin  R]]></fr:tex> which is a contradiction.</html:p>
<html:p><html:strong>Case 2:</html:strong> Assume <fr:tex display="inline"><![CDATA[R\notin  R]]></fr:tex>. But this is the defining property for members of <fr:tex display="inline"><![CDATA[R]]></fr:tex>. This implies <fr:tex display="inline"><![CDATA[R\in  R]]></fr:tex>. Again, we have both <fr:tex display="inline"><![CDATA[R\in  R]]></fr:tex> and <fr:tex display="inline"><![CDATA[R\notin  R]]></fr:tex> which is a contradiction.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001O/</fr:uri>
            <fr:display-uri>nst-001O</fr:display-uri>
            <fr:route>/nst-001O/</fr:route>
            <fr:title text="There is no set of all sets">There is no set of all sets</fr:title>
            <fr:taxon>corollary</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>An immediate consequence of <fr:link href="/nst-001N/" title="Russell's paradox" uri="http://localhost:8000/nst-001N/" display-uri="nst-001N" type="local">Russell's paradox</fr:link> is that there is no set of all sets. If there were a set <fr:tex display="inline"><![CDATA[V]]></fr:tex> of all sets, then <fr:tex display="inline"><![CDATA[V\in  V]]></fr:tex> which leads to problems.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001P/</fr:uri>
            <fr:display-uri>nst-001P</fr:display-uri>
            <fr:route>/nst-001P/</fr:route>
            <fr:title text="Classes">Classes</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>We will often informally refer to a <html:dfn>(Proper) Class</html:dfn> as an unordered collection which is "too big" to be a set.</html:p><html:p>For example, the von Neumann universe <fr:tex display="inline"><![CDATA[\mathbf {V}]]></fr:tex> is the proper class of all sets.</html:p><html:p>In practice, we seldom need to work with proper classes directly. The Working Mathematician needs only sets (until we get to Category Theory, but we'll revisit this as needed).</html:p><html:p>The <html:dfn>Axiom of limitation of size</html:dfn> asserts a collection <fr:tex display="inline"><![CDATA[C]]></fr:tex> is a proper class if and only if there exists a surjective function from <fr:tex display="inline"><![CDATA[C]]></fr:tex> to the von Neumann universe <fr:tex display="inline"><![CDATA[\mathbf {V}]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:taxon>remark</fr:taxon></fr:frontmatter><fr:mainmatter>We're playing "fast and loose" with things here, but for a discussion of axiomatic set theory based on classes (using the NBG axioms), see <fr:link href="/taras-banakh/" title="Taras Banakh" uri="http://localhost:8000/taras-banakh/" display-uri="taras-banakh" type="local">Taras Banakh</fr:link>'s <fr:link href="/banakh-2020-classical/" title="Classical Set Theory: Theory of Sets and Classes" uri="http://localhost:8000/banakh-2020-classical/" display-uri="banakh-2020-classical" type="local">Classical Set Theory: Theory of Sets and Classes</fr:link>.</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000B/</fr:uri>
            <fr:display-uri>nst-000B</fr:display-uri>
            <fr:route>/nst-000B/</fr:route>
            <fr:title text="Union of a family of sets">Union of a family of sets</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.4</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/tarski.html#K3" type="external">tarski:def 4</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[F]]></fr:tex> be a family of sets (i.e., set whose elements are sets). We define the <html:dfn>Union</html:dfn> of <fr:tex display="inline"><![CDATA[F]]></fr:tex> to be the set <fr:tex display="inline"><![CDATA[\bigcup  F]]></fr:tex> such that for all objects <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in \bigcup  F]]></fr:tex> iff there is some set <fr:tex display="inline"><![CDATA[X\in  F]]></fr:tex> such that <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex>.</html:p>
            <html:p>This defines a new constant and we should set about to <fr:link href="/nst-000C/" title="Proving well-definedness of terms" uri="http://localhost:8000/nst-000C/" display-uri="nst-000C" type="local">proving it is well-defined</fr:link>, but proving its existence is impossible because it is just stipulated to exist ("axiom of union").</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000D/</fr:uri>
            <fr:display-uri>nst-000D</fr:display-uri>
            <fr:route>/nst-000D/</fr:route>
            <fr:title text="Union of two sets">Union of two sets</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.4</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xboole_0.html#K2" type="external">xboole_0:def 3</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the <html:dfn>Union</html:dfn> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> to be the set <fr:tex display="inline"><![CDATA[X\cup  Y]]></fr:tex> such that for all objects <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in  X\cup  Y]]></fr:tex> iff either <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> or <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>.</html:p><html:p>We see that this is commutative <fr:tex display="inline"><![CDATA[X\cup  Y=Y\cup  X]]></fr:tex> and idempotent <fr:tex display="inline"><![CDATA[X\cup  X=X]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><html:strong>Existence:</html:strong> take <fr:tex display="inline"><![CDATA[X\cup  Y=\bigcup \{X,Y\}]]></fr:tex>. We need to prove <fr:tex display="inline"><![CDATA[x\in  X\cup  Y\implies  x\in \bigcup \{X,Y\}]]></fr:tex> and <fr:tex display="inline"><![CDATA[x\in \bigcup \{X,Y\}\implies  x\in  X\cup  Y]]></fr:tex>, but these follow immediately.</html:p>

<html:p><html:strong>Uniqueness:</html:strong> Suppose <fr:tex display="inline"><![CDATA[A]]></fr:tex> is such that for all <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in  A]]></fr:tex> iff <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> or <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>, and <fr:tex display="inline"><![CDATA[B]]></fr:tex> is such that for all <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in  B]]></fr:tex> iff <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> or <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>. We will prove for all <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in  A]]></fr:tex> iff <fr:tex display="inline"><![CDATA[x\in  B]]></fr:tex>: let <fr:tex display="inline"><![CDATA[x]]></fr:tex> be an arbitrary object. Then
<fr:tex display="block"><![CDATA[x\in  A\iff  x\in  A\hbox { or }x\in  A\iff  x\in  B]]></fr:tex>
which implies <fr:tex display="inline"><![CDATA[x\in  A\iff  x\in  B]]></fr:tex>. Hence <fr:tex display="inline"><![CDATA[A=B]]></fr:tex> by <fr:link href="/nst-0004/" title="Set equality" uri="http://localhost:8000/nst-0004/" display-uri="nst-0004" type="local">Set equality</fr:link>.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000E/</fr:uri>
            <fr:display-uri>nst-000E</fr:display-uri>
            <fr:route>/nst-000E/</fr:route>
            <fr:title text="Basic properties of union of two sets">Basic properties of union of two sets</fr:title>
            <fr:taxon>theorem</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.4</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/boole.html#T1" type="external">boole:th1</fr:link></fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T4" type="external">xboole_1:th4</fr:link></fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T12" type="external">xboole_1:th12</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex>, <fr:tex display="inline"><![CDATA[B]]></fr:tex>, <fr:tex display="inline"><![CDATA[C]]></fr:tex> be arbitrary sets. Then the following all hold:</html:p>
            <html:ol><html:li><fr:tex display="inline"><![CDATA[A\cup \emptyset =A]]></fr:tex></html:li>
<html:li>Associativity: <fr:tex display="inline"><![CDATA[A\cup (B\cup  C)=(A\cup  B)\cup  C]]></fr:tex></html:li>
<html:li><fr:tex display="inline"><![CDATA[A\subseteq  B]]></fr:tex> iff <fr:tex display="inline"><![CDATA[A\cup  B=B]]></fr:tex></html:li></html:ol>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000F/</fr:uri>
            <fr:display-uri>nst-000F</fr:display-uri>
            <fr:route>/nst-000F/</fr:route>
            <fr:title text="Intersection of two sets">Intersection of two sets</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.4</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xboole_0.html#K3" type="external">xboole_0:def 4</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We define their <html:dfn>Intersection</html:dfn> to be the set denoted <fr:tex display="inline"><![CDATA[X\cap  Y]]></fr:tex> such that: for all objects <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in  X\cap  Y]]></fr:tex> iff <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>.</html:p><html:p>We see this is commutative <fr:tex display="inline"><![CDATA[X\cap  Y=Y\cap  X]]></fr:tex> and idempotent <fr:tex display="inline"><![CDATA[X\cap  X=X]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><html:strong>Existence:</html:strong> We see this exists using <fr:link href="/nst-0009/" title="Set builder notation" uri="http://localhost:8000/nst-0009/" display-uri="nst-0009" type="local">set-builder notation</fr:link>  <fr:tex display="inline"><![CDATA[\{x\in  X\mid  x\in  Y\}]]></fr:tex>.</html:p>
<html:p><html:strong>Uniqueness:</html:strong> let <fr:tex display="inline"><![CDATA[A]]></fr:tex> and <fr:tex display="inline"><![CDATA[B]]></fr:tex> be two possible candidates for the definition. We see <fr:tex display="inline"><![CDATA[x\in  A\iff  x\in  X\hbox { and }x\in  Y\iff  x\in  B]]></fr:tex>, which implies <fr:tex display="inline"><![CDATA[A=B]]></fr:tex> by <fr:link href="/nst-0004/" title="Set equality" uri="http://localhost:8000/nst-0004/" display-uri="nst-0004" type="local">Set equality</fr:link>.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000G/</fr:uri>
            <fr:display-uri>nst-000G</fr:display-uri>
            <fr:route>/nst-000G/</fr:route>
            <fr:title text="Basic properties of intersection of two sets">Basic properties of intersection of two sets</fr:title>
            <fr:taxon>theorem</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.4</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/boole.html#T2" type="external">boole:2</fr:link></fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T17" type="external">xboole_1:17</fr:link></fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xboole_1.html#T28" type="external">xboole_1:28</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex>, <fr:tex display="inline"><![CDATA[B]]></fr:tex>, <fr:tex display="inline"><![CDATA[C]]></fr:tex> be any three sets. Then the following all hold:</html:p>
            <html:ol><html:li><fr:tex display="inline"><![CDATA[A\cap \emptyset =\emptyset ]]></fr:tex></html:li>
<html:li><fr:tex display="inline"><![CDATA[A\cap (B\cap  C)=(A\cap  B)\cap  C]]></fr:tex></html:li>
<html:li><fr:tex display="inline"><![CDATA[A\subseteq  B]]></fr:tex> iff <fr:tex display="inline"><![CDATA[A\cap  B=A]]></fr:tex></html:li></html:ol>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000H/</fr:uri>
            <fr:display-uri>nst-000H</fr:display-uri>
            <fr:route>/nst-000H/</fr:route>
            <fr:title text="Intersection of family of sets">Intersection of family of sets</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.4</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/setfam_1.html#K1" type="external">setfam_1:def 1</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[F]]></fr:tex> be a family of sets (i.e., a set whose members are all sets). We define the <html:dfn>Intersection</html:dfn> of <fr:tex display="inline"><![CDATA[F]]></fr:tex> to be the set <fr:tex display="inline"><![CDATA[\bigcap  F]]></fr:tex> such that for all objects <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in \bigcap  F]]></fr:tex> iff for each set <fr:tex display="inline"><![CDATA[Y\in  F]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000I/</fr:uri>
            <fr:display-uri>nst-000I</fr:display-uri>
            <fr:route>/nst-000I/</fr:route>
            <fr:title text="Relative complement of a set">Relative complement of a set</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.5</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xboole_0.html#K4" type="external">xboole_0:def 5</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the <html:dfn>Relative complement</html:dfn> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> with respect to <fr:tex display="inline"><![CDATA[Y]]></fr:tex> to be the set <fr:tex display="inline"><![CDATA[Y\setminus  X]]></fr:tex> such that for all objects <fr:tex display="inline"><![CDATA[x]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\in  Y\setminus  X]]></fr:tex> iff <fr:tex display="inline"><![CDATA[x\in  Y]]></fr:tex> and <fr:tex display="inline"><![CDATA[x\notin  X]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000J/</fr:uri>
            <fr:display-uri>nst-000J</fr:display-uri>
            <fr:route>/nst-000J/</fr:route>
            <fr:title text="Complement of a subset">Complement of a subset</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.5</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/subset_1.html#K3" type="external">subset_1:def 4</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be a subset of <fr:tex display="inline"><![CDATA[Y]]></fr:tex>. We define the <html:dfn>Complement</html:dfn> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> to be the subset <fr:tex display="inline"><![CDATA[X^{\complement }]]></fr:tex> of <fr:tex display="inline"><![CDATA[Y]]></fr:tex> equal to <fr:tex display="inline"><![CDATA[Y\setminus  X]]></fr:tex>.</html:p>
            <html:p>Some texts use <fr:tex display="inline"><![CDATA[\complement  X]]></fr:tex> or <fr:tex display="inline"><![CDATA[X']]></fr:tex> for the complement of <fr:tex display="inline"><![CDATA[X]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000K/</fr:uri>
            <fr:display-uri>nst-000K</fr:display-uri>
            <fr:route>/nst-000K/</fr:route>
            <fr:title text="Powerset">Powerset</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.5</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/zfmisc_1.html#K1" type="external">zfmisc_1:def 1</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be a set. We define the <html:dfn>Powerset</html:dfn> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> to be the set <fr:tex display="inline"><![CDATA[\mathcal {P}(X)]]></fr:tex> such that for any set <fr:tex display="inline"><![CDATA[Z]]></fr:tex> we have <fr:tex display="inline"><![CDATA[Z\in \mathcal {P}(X)]]></fr:tex> iff <fr:tex display="inline"><![CDATA[Z\subseteq  X]]></fr:tex>. That is to say, the powerset of <fr:tex display="inline"><![CDATA[X]]></fr:tex> is the set of all subsets of <fr:tex display="inline"><![CDATA[X]]></fr:tex>.</html:p>
            <html:p>For finite sets (especially small sets we can write out by hand), we can see this is a sensible thing to define. But for infinite sets, some Mathematicians historically were nervous about this being well-defined. The important thing is that we assert (either axiomatically or dogmatically) this is indeed a set.</html:p>
            <html:p>(In ZFC, this is given as an axiom.)</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000L/</fr:uri>
            <fr:display-uri>nst-000L</fr:display-uri>
            <fr:route>/nst-000L/</fr:route>
            <fr:title text="Specification for ordered pairs">Specification for ordered pairs</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[x]]></fr:tex> and <fr:tex display="inline"><![CDATA[y]]></fr:tex> be objects. Let <fr:tex display="inline"><![CDATA[a]]></fr:tex> and <fr:tex display="inline"><![CDATA[b]]></fr:tex> be objects. We expect the ordered pair <fr:tex display="inline"><![CDATA[(x,y)]]></fr:tex> to be such that: <fr:tex display="inline"><![CDATA[(x,y)=(a,b)]]></fr:tex> if and only if <fr:tex display="inline"><![CDATA[x=a]]></fr:tex> and <fr:tex display="inline"><![CDATA[y=b]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000M/</fr:uri>
            <fr:display-uri>nst-000M</fr:display-uri>
            <fr:route>/nst-000M/</fr:route>
            <fr:title text="Ordered pairs">Ordered pairs</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.6</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/tarski.html#K4" type="external">tarski:def 5</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[x]]></fr:tex> and <fr:tex display="inline"><![CDATA[y]]></fr:tex> be objects. We define the <html:dfn>Ordered Pair</html:dfn> to be the object <fr:tex display="inline"><![CDATA[(x,y) = \{\{x\},\{x,y\}\}]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:taxon>remark</fr:taxon></fr:frontmatter><fr:mainmatter>A better definition would be <fr:tex display="inline"><![CDATA[(x,y)=\{\{0,x\},\{1,y\}\}]]></fr:tex> because then the <fr:link href="/nst-000O/" title="Cartesian product of two sets" uri="http://localhost:8000/nst-000O/" display-uri="nst-000O" type="local">Cartesian product of two sets</fr:link> coincides with the <fr:link href="/nst-002E/" title="Product of family of sets" uri="http://localhost:8000/nst-002E/" display-uri="nst-002E" type="local">Product of family of sets</fr:link> when <fr:tex display="inline"><![CDATA[I=\{0,1\}]]></fr:tex> is the indexing set.</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000N/</fr:uri>
            <fr:display-uri>nst-000N</fr:display-uri>
            <fr:route>/nst-000N/</fr:route>
            <fr:title text="Ordered pairs implement their specification">Ordered pairs implement their specification</fr:title>
            <fr:taxon>theorem</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.6</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/xtuple_0.html#T1" type="external">xtuple_0:1</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[a]]></fr:tex>, <fr:tex display="inline"><![CDATA[b]]></fr:tex>, <fr:tex display="inline"><![CDATA[c]]></fr:tex>, <fr:tex display="inline"><![CDATA[d]]></fr:tex> be objects. If <fr:tex display="inline"><![CDATA[(a,b)=(c,d)]]></fr:tex>, then <fr:tex display="inline"><![CDATA[a=c]]></fr:tex> and <fr:tex display="inline"><![CDATA[b=d]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>9</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>We boild this proof down to two cases: either <fr:tex display="inline"><![CDATA[c=d]]></fr:tex> or not. We assume <fr:tex display="inline"><![CDATA[(a,b)=(c,d)]]></fr:tex>.</html:p>
<html:p><html:strong>Case 1:</html:strong> <fr:tex display="inline"><![CDATA[c=d]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[(c,d)=(c,c)=\{\{c,c\},\{c\}\}=\{\{c\}\}]]></fr:tex> and <fr:tex display="inline"><![CDATA[(a,b)=\{\{a,b\},\{a\}\}=\{\{c\}\}]]></fr:tex> requires <fr:tex display="inline"><![CDATA[\{a,b\}=\{c\}]]></fr:tex> which implies <fr:tex display="inline"><![CDATA[a=b=c]]></fr:tex>. Hence <fr:tex display="inline"><![CDATA[a=b=c=d]]></fr:tex> which implies <fr:tex display="inline"><![CDATA[a=c]]></fr:tex> and <fr:tex display="inline"><![CDATA[b=d]]></fr:tex> as desired.</html:p>
<html:p><html:strong>Case 2:</html:strong> <fr:tex display="inline"><![CDATA[c\neq  d]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[\{a\}\neq \{c,d\}]]></fr:tex>, so <fr:tex display="inline"><![CDATA[\{a\}=\{c\}]]></fr:tex>, which means <fr:tex display="inline"><![CDATA[a=c]]></fr:tex>. Then we see <fr:tex display="inline"><![CDATA[(a,b)=(c,b)=(c,d)]]></fr:tex> which implies <fr:tex display="inline"><![CDATA[\{c,b\}=\{c,d\}]]></fr:tex> which means <fr:tex display="inline"><![CDATA[b=d]]></fr:tex>. Hence <fr:tex display="inline"><![CDATA[a=c]]></fr:tex> and <fr:tex display="inline"><![CDATA[b=d]]></fr:tex>.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000O/</fr:uri>
            <fr:display-uri>nst-000O</fr:display-uri>
            <fr:route>/nst-000O/</fr:route>
            <fr:title text="Cartesian product of two sets">Cartesian product of two sets</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.6</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/zfmisc_1.html#K2" type="external">zfmisc_1:def 2</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We define their <html:dfn>Cartesian product</html:dfn> to be the set <fr:tex display="inline"><![CDATA[X\times  Y]]></fr:tex> such that for all objects <fr:tex display="inline"><![CDATA[z]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[z\in  X\times  Y]]></fr:tex> if and only if there exists objects <fr:tex display="inline"><![CDATA[x]]></fr:tex> and <fr:tex display="inline"><![CDATA[y]]></fr:tex> such that <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex display="inline"><![CDATA[y\in  Y]]></fr:tex> and <fr:tex display="inline"><![CDATA[z=(x,y)]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000Q/</fr:uri>
            <fr:display-uri>nst-000Q</fr:display-uri>
            <fr:route>/nst-000Q/</fr:route>
            <fr:title text="Properties of Cartesian product">Properties of Cartesian product</fr:title>
            <fr:taxon>theorem</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex>, <fr:tex display="inline"><![CDATA[Y]]></fr:tex>, <fr:tex display="inline"><![CDATA[Z]]></fr:tex> be sets. Then the following all hold:</html:p>
            <html:ol><html:li><fr:tex display="inline"><![CDATA[X\times  Y\subseteq \mathcal {P}(\mathcal {P}(X\cup  Y))]]></fr:tex></html:li>
<html:li><fr:tex display="inline"><![CDATA[X\times  Y=\emptyset ]]></fr:tex> iff <fr:tex display="inline"><![CDATA[X=\emptyset ]]></fr:tex> or <fr:tex display="inline"><![CDATA[Y=\emptyset ]]></fr:tex></html:li> <html:li>If <fr:tex display="inline"><![CDATA[X\times  Y=Y\times  X]]></fr:tex>, then <fr:tex display="inline"><![CDATA[X=Y]]></fr:tex></html:li> <html:li><fr:tex display="inline"><![CDATA[(X\cup  Y)\times  Z=(X\times  Z)\cup (Y\times  Z)]]></fr:tex></html:li> <html:li><fr:tex display="inline"><![CDATA[X\times (Y\cup  Z)=(X\times  Y)\cup (X\times  Z)]]></fr:tex></html:li> <html:li><fr:tex display="inline"><![CDATA[(X\cap  Y)\times  Z=(X\times  Z)\cap (Y\times  Z)]]></fr:tex></html:li> <html:li><fr:tex display="inline"><![CDATA[X\times (Y\cap  Z)=(X\times  Y)\cap (X\times  Z)]]></fr:tex></html:li> <html:li><fr:tex display="inline"><![CDATA[(X\setminus  Y)\times  Z=(X\times  Z)\setminus (Y\times  Z)]]></fr:tex></html:li> <html:li><fr:tex display="inline"><![CDATA[X\times (Y\setminus  Z)=(X\times  Y)\setminus (X\times  Z)]]></fr:tex></html:li></html:ol>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors>
          <fr:author>
            <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
          </fr:author>
        </fr:authors>
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>12</fr:month>
          <fr:day>9</fr:day>
        </fr:date>
        <fr:uri>http://localhost:8000/nst-000S/</fr:uri>
        <fr:display-uri>nst-000S</fr:display-uri>
        <fr:route>/nst-000S/</fr:route>
        <fr:title text="Relations and functions in naive set theory">Relations and functions in naive set theory</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000T/</fr:uri>
            <fr:display-uri>nst-000T</fr:display-uri>
            <fr:route>/nst-000T/</fr:route>
            <fr:title text="Relation">Relation</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.7</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We can define a <html:dfn>Relation</html:dfn> broadly is a set <fr:tex display="inline"><![CDATA[R]]></fr:tex> such that for all objects <fr:tex display="inline"><![CDATA[r\in  R]]></fr:tex> there exists objects <fr:tex display="inline"><![CDATA[x]]></fr:tex> and <fr:tex display="inline"><![CDATA[y]]></fr:tex> such that <fr:tex display="inline"><![CDATA[r=(x,y)]]></fr:tex>. In other words, a relation is a set which consists of ordered pairs.</html:p>
            <html:p>When <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> are sets, a <html:dfn>Relation</html:dfn> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> is a subset <fr:tex display="inline"><![CDATA[R\subseteq  X\times  Y]]></fr:tex>.</html:p>
            <html:p>We will speak of a "Relation of <fr:tex display="inline"><![CDATA[X]]></fr:tex>" when referring to a subset <fr:tex display="inline"><![CDATA[R\subseteq  X\times  X]]></fr:tex>.</html:p>
            <html:p>If <fr:tex display="inline"><![CDATA[R]]></fr:tex> is a relation and <fr:tex display="inline"><![CDATA[(x,y)\in  R]]></fr:tex>, then we will frequently abuse notation and write <fr:tex display="inline"><![CDATA[x\;R\;y]]></fr:tex>. Usually instead of <fr:tex display="inline"><![CDATA[R]]></fr:tex>, for particular relations we use <fr:tex display="inline"><![CDATA[\sim ]]></fr:tex>, <fr:tex display="inline"><![CDATA[\approx ]]></fr:tex>, <fr:tex display="inline"><![CDATA[\cong ]]></fr:tex>, <fr:tex display="inline"><![CDATA[\equiv ]]></fr:tex>, <fr:tex display="inline"><![CDATA[\lt ]]></fr:tex>, or other notation which is more aesthetically pleasing.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000V/</fr:uri>
            <fr:display-uri>nst-000V</fr:display-uri>
            <fr:route>/nst-000V/</fr:route>
            <fr:title text="Domain of a relation">Domain of a relation</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.7</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[R]]></fr:tex> be a relation. We define the <html:dfn>Domain</html:dfn> of <fr:tex display="inline"><![CDATA[R]]></fr:tex> to be the set <fr:tex display="inline"><![CDATA[\mathop {\textrm {dom}}\nolimits (R)=\{x\mid  \exists  y\ldotp  (x,y)\in  R\}]]></fr:tex>.</html:p>
            <html:p>When <fr:tex display="inline"><![CDATA[R]]></fr:tex> is a relation of <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex>, we see <fr:tex display="inline"><![CDATA[\mathop {\textrm {dom}}\nolimits (R)\subseteq  X]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000W/</fr:uri>
            <fr:display-uri>nst-000W</fr:display-uri>
            <fr:route>/nst-000W/</fr:route>
            <fr:title text="Range of a relation">Range of a relation</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.7</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[R]]></fr:tex> be a relation. We define the <html:dfn>Range</html:dfn> of <fr:tex display="inline"><![CDATA[R]]></fr:tex> to be the set <fr:tex display="inline"><![CDATA[\mathop {\textrm {ran}}\nolimits (R)=\{y\mid \exists  x\ldotp (x,y)\in  R\}]]></fr:tex>.</html:p>
            <html:p>When <fr:tex display="inline"><![CDATA[R]]></fr:tex> is a relation of <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex>, we see <fr:tex display="inline"><![CDATA[\mathop {\textrm {ran}}\nolimits (R)\subseteq  Y]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000X/</fr:uri>
            <fr:display-uri>nst-000X</fr:display-uri>
            <fr:route>/nst-000X/</fr:route>
            <fr:title text="Field of a relation">Field of a relation</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.7</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/relat_1.html#K1" type="external">relat_1:def 6</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[R]]></fr:tex> be a relation. We define the <html:dfn>Field</html:dfn> of <fr:tex display="inline"><![CDATA[R]]></fr:tex> is just <fr:tex display="inline"><![CDATA[\mathop {\textrm {dom}}\nolimits (R)\cup \mathop {\textrm {ran}}\nolimits (R)]]></fr:tex>.</html:p>
            <html:p>Observe when <fr:tex display="inline"><![CDATA[R]]></fr:tex> is a relation of <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex>, the field <fr:tex display="inline"><![CDATA[F]]></fr:tex> of <fr:tex display="inline"><![CDATA[R]]></fr:tex> is a subset <fr:tex display="inline"><![CDATA[F\subseteq  X\cup  Y]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001F/</fr:uri>
            <fr:display-uri>nst-001F</fr:display-uri>
            <fr:route>/nst-001F/</fr:route>
            <fr:title text="Inverse relation">Inverse relation</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[R]]></fr:tex> be a relation. We define the <html:dfn>Inverse</html:dfn> of <fr:tex display="inline"><![CDATA[R]]></fr:tex> to be the relation <fr:tex display="inline"><![CDATA[R^{-1}=\{(y,x)\mid (x,y)\in  R\}]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000Y/</fr:uri>
            <fr:display-uri>nst-000Y</fr:display-uri>
            <fr:route>/nst-000Y/</fr:route>
            <fr:title text="Reflexive relation">Reflexive relation</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.7</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/relat_2.html#V1" type="external">relat_2:def 9</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[R]]></fr:tex> be a relation, let <fr:tex display="inline"><![CDATA[F]]></fr:tex> be its <fr:link href="/nst-000X/" title="Field of a relation" uri="http://localhost:8000/nst-000X/" display-uri="nst-000X" type="local">field</fr:link>. We say <fr:tex display="inline"><![CDATA[R]]></fr:tex> is <html:dfn>Reflexive</html:dfn> if for each <fr:tex display="inline"><![CDATA[x\in  F]]></fr:tex> we have <fr:tex display="inline"><![CDATA[(x,x)\in  R]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-000Z/</fr:uri>
            <fr:display-uri>nst-000Z</fr:display-uri>
            <fr:route>/nst-000Z/</fr:route>
            <fr:title text="Symmetric relation">Symmetric relation</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.7</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/relat_2.html#V3" type="external">relat_2:def 11</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[R]]></fr:tex> be a relation, let <fr:tex display="inline"><![CDATA[F]]></fr:tex> be its <fr:link href="/nst-000X/" title="Field of a relation" uri="http://localhost:8000/nst-000X/" display-uri="nst-000X" type="local">field</fr:link>. We say <fr:tex display="inline"><![CDATA[R]]></fr:tex> is <html:dfn>Symmetric</html:dfn> if for all <fr:tex display="inline"><![CDATA[x\in  F]]></fr:tex> and <fr:tex display="inline"><![CDATA[y\in  F]]></fr:tex>, if <fr:tex display="inline"><![CDATA[(x,y)\in  R]]></fr:tex>, then <fr:tex display="inline"><![CDATA[(y,x)\in  R]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>18</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-002N/</fr:uri>
            <fr:display-uri>nst-002N</fr:display-uri>
            <fr:route>/nst-002N/</fr:route>
            <fr:title text="Antisymmetric relation">Antisymmetric relation</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[R]]></fr:tex> be a relation, let <fr:tex display="inline"><![CDATA[F]]></fr:tex> be its field. We say <fr:tex display="inline"><![CDATA[R]]></fr:tex> is <html:dfn>Antisymmetric</html:dfn> if for each <fr:tex display="inline"><![CDATA[x,y\in  F]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[(x,y)\in  R]]></fr:tex> and <fr:tex display="inline"><![CDATA[(y,x)\in  R]]></fr:tex> if and only if <fr:tex display="inline"><![CDATA[x=y]]></fr:tex>.</html:p>
            <html:p>For example, divisibility relation on natural numbers is antisymmetric, or the ordering <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex> on real numbers is antisymmetric.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0010/</fr:uri>
            <fr:display-uri>nst-0010</fr:display-uri>
            <fr:route>/nst-0010/</fr:route>
            <fr:title text="Transitive relation">Transitive relation</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.7</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/relat_2.html#V8" type="external">relat_2:def 16</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[R]]></fr:tex> be a relation, let <fr:tex display="inline"><![CDATA[F]]></fr:tex> be its <fr:link href="/nst-000X/" title="Field of a relation" uri="http://localhost:8000/nst-000X/" display-uri="nst-000X" type="local">field</fr:link>. We say <fr:tex display="inline"><![CDATA[R]]></fr:tex> is <html:dfn>Transitive</html:dfn> if for all <fr:tex display="inline"><![CDATA[x\in  F]]></fr:tex>, <fr:tex display="inline"><![CDATA[y\in  F]]></fr:tex>, and <fr:tex display="inline"><![CDATA[z\in  F]]></fr:tex>, if <fr:tex display="inline"><![CDATA[(x,y)\in  R]]></fr:tex> and <fr:tex display="inline"><![CDATA[(y,z)\in  R]]></fr:tex>, then <fr:tex display="inline"><![CDATA[(x,z)\in  R]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>18</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-002O/</fr:uri>
            <fr:display-uri>nst-002O</fr:display-uri>
            <fr:route>/nst-002O/</fr:route>
            <fr:title text="Partial Order">Partial Order</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be a set. A <html:dfn>Partial Order</html:dfn> on <fr:tex display="inline"><![CDATA[X]]></fr:tex> is a <fr:link href="/nst-000Y/" title="Reflexive relation" uri="http://localhost:8000/nst-000Y/" display-uri="nst-000Y" type="local">reflexive</fr:link> <fr:link href="/nst-002N/" title="Antisymmetric relation" uri="http://localhost:8000/nst-002N/" display-uri="nst-002N" type="local">antisymmetric</fr:link> <fr:link href="/nst-0010/" title="Transitive relation" uri="http://localhost:8000/nst-0010/" display-uri="nst-0010" type="local">transitive</fr:link> relation on <fr:tex display="inline"><![CDATA[X]]></fr:tex>.</html:p>
            <html:p>Usually, partial orders are denoted by <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex> or something similar.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0011/</fr:uri>
            <fr:display-uri>nst-0011</fr:display-uri>
            <fr:route>/nst-0011/</fr:route>
            <fr:title text="Equivalence relation">Equivalence relation</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.7</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/eqrel_1.html#NM2" type="external">eqrel_1:def</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be a set. We define an <html:dfn>Equivalence Relation</html:dfn> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> to be a <fr:link href="/nst-000Y/" title="Reflexive relation" uri="http://localhost:8000/nst-000Y/" display-uri="nst-000Y" type="local">reflexive</fr:link> <fr:link href="/nst-000Z/" title="Symmetric relation" uri="http://localhost:8000/nst-000Z/" display-uri="nst-000Z" type="local">symmetric</fr:link> <fr:link href="/nst-0010/" title="Transitive relation" uri="http://localhost:8000/nst-0010/" display-uri="nst-0010" type="local">transitive</fr:link> relation of <fr:tex display="inline"><![CDATA[X]]></fr:tex>.</html:p>
            <html:p>For example, <fr:tex display="inline"><![CDATA[R=\{(x,x)\mid  x\in  X\}]]></fr:tex> is always an equivalence relation of <fr:tex display="inline"><![CDATA[X]]></fr:tex> which describes equality of elements of <fr:tex display="inline"><![CDATA[X]]></fr:tex>.</html:p>
            <html:p>More generally, an equivalence relation is a generalization of equality. Consequently, it is common to use notation like <fr:tex display="inline"><![CDATA[\sim ]]></fr:tex>, <fr:tex display="inline"><![CDATA[\approx ]]></fr:tex>, <fr:tex display="inline"><![CDATA[\equiv ]]></fr:tex>, <fr:tex display="inline"><![CDATA[\cong ]]></fr:tex> for equivalence relations.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0012/</fr:uri>
            <fr:display-uri>nst-0012</fr:display-uri>
            <fr:route>/nst-0012/</fr:route>
            <fr:title text="Equivalence class">Equivalence class</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.7</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/eqrel_1.html#K6" type="external">eqrel_1:def</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be a set, let <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex>, and let <fr:tex display="inline"><![CDATA[R]]></fr:tex> be an equivalence relation of <fr:tex display="inline"><![CDATA[X]]></fr:tex>. We define the <html:dfn>Equivalence Class</html:dfn> of <fr:tex display="inline"><![CDATA[x]]></fr:tex> with respect to <fr:tex display="inline"><![CDATA[R]]></fr:tex> is the set <fr:tex display="inline"><![CDATA[[x]_{R}=\{y\in  X\mid  (x,y)\in  R\}]]></fr:tex> consisting of all elements equivalent to <fr:tex display="inline"><![CDATA[x]]></fr:tex> under <fr:tex display="inline"><![CDATA[R]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0013/</fr:uri>
            <fr:display-uri>nst-0013</fr:display-uri>
            <fr:route>/nst-0013/</fr:route>
            <fr:title text="Composing relations">Composing relations</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.7</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/relat_1.html#K3" type="external">relat_1:def 8</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[P]]></fr:tex> and <fr:tex display="inline"><![CDATA[R]]></fr:tex> be relations. We define their <html:dfn>Composition</html:dfn> to be the relation denoted <fr:tex display="inline"><![CDATA[PR]]></fr:tex> or <fr:tex display="inline"><![CDATA[R\circ  P]]></fr:tex> such that for all objects <fr:tex display="inline"><![CDATA[x]]></fr:tex> and <fr:tex display="inline"><![CDATA[z]]></fr:tex> we have <fr:tex display="inline"><![CDATA[(x,z)\in  PR]]></fr:tex> iff there exists an object <fr:tex display="inline"><![CDATA[y]]></fr:tex> such that <fr:tex display="inline"><![CDATA[(x,y)\in  P]]></fr:tex> and <fr:tex display="inline"><![CDATA[(y,z)\in  R]]></fr:tex>.</html:p>
            <html:p>The <fr:tex display="inline"><![CDATA[PR]]></fr:tex> notation means <fr:tex display="inline"><![CDATA[xPRz]]></fr:tex> iff there exists a <fr:tex display="inline"><![CDATA[y]]></fr:tex> such that <fr:tex display="inline"><![CDATA[xPyRz]]></fr:tex>.</html:p>
            <html:p>The <fr:tex display="inline"><![CDATA[R\circ  P]]></fr:tex> notation is useful for working with functions.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001B/</fr:uri>
            <fr:display-uri>nst-001B</fr:display-uri>
            <fr:route>/nst-001B/</fr:route>
            <fr:title text="Composing relations is associative">Composing relations is associative</fr:title>
            <fr:taxon>theorem</fr:taxon>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/relat_1.html#T36" type="external">relat_1:th36</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[R_{1}]]></fr:tex>, <fr:tex display="inline"><![CDATA[R_{2}]]></fr:tex>, <fr:tex display="inline"><![CDATA[R_{3}]]></fr:tex> be relations. Then <fr:tex display="inline"><![CDATA[(R_{1}\circ  R_{2})\circ  R_{3}=R_{1}\circ (R_{2}\circ  R_{3})]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0014/</fr:uri>
            <fr:display-uri>nst-0014</fr:display-uri>
            <fr:route>/nst-0014/</fr:route>
            <fr:title text="Function">Function</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.8</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We define a <html:dfn>Function</html:dfn> from <fr:tex display="inline"><![CDATA[X]]></fr:tex> to <fr:tex display="inline"><![CDATA[Y]]></fr:tex> to be a <fr:link href="/nst-000T/" title="Relation" uri="http://localhost:8000/nst-000T/" display-uri="nst-000T" type="local">relation</fr:link> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> denoted <fr:tex display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> such that:
<html:ol><html:li><fr:link href="https://mizar.uwb.edu.pl/version/current/html/partfun1.htmlV1" type="external">Total</fr:link>: <fr:tex display="inline"><![CDATA[\mathop {\textrm {dom}}\nolimits (f)=X]]></fr:tex>, and</html:li>
<html:li><fr:link href="https://mizar.uwb.edu.pl/version/current/html/funct_1.htmlV1" type="external">Function-like</fr:link>: for all objects <fr:tex display="inline"><![CDATA[x]]></fr:tex>, <fr:tex display="inline"><![CDATA[y]]></fr:tex>, <fr:tex display="inline"><![CDATA[z]]></fr:tex> such that <fr:tex display="inline"><![CDATA[(x,y)\in  f]]></fr:tex> and <fr:tex display="inline"><![CDATA[(x,z)\in  f]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[y=z]]></fr:tex>.</html:li></html:ol>
Instead of <fr:tex display="inline"><![CDATA[(x,y)\in  f]]></fr:tex>, we write <fr:tex display="inline"><![CDATA[f(x)=y]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0015/</fr:uri>
            <fr:display-uri>nst-0015</fr:display-uri>
            <fr:route>/nst-0015/</fr:route>
            <fr:title text="Set of all functions">Set of all functions</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.8</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/funct_2.html#K1" type="external">funct_2:def 2</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We denote the <html:dfn>Set of all functions</html:dfn> from <fr:tex display="inline"><![CDATA[X]]></fr:tex> to <fr:tex display="inline"><![CDATA[Y]]></fr:tex> as either <fr:tex display="inline"><![CDATA[Y^{X}]]></fr:tex> or <fr:tex display="inline"><![CDATA[\mathop {\textrm {Hom}}\nolimits (X,Y)]]></fr:tex>.</html:p>
            <html:p>We see this really is a set, since a function is a subset of <fr:tex display="inline"><![CDATA[X\times  Y]]></fr:tex>, so the set of all functions is a subset of <fr:tex display="inline"><![CDATA[\mathcal {P}(X\times  Y)]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0016/</fr:uri>
            <fr:display-uri>nst-0016</fr:display-uri>
            <fr:route>/nst-0016/</fr:route>
            <fr:title text="Inclusion">Inclusion</fr:title>
            <fr:taxon>example</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.8</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/funct_3.html#K6" type="external">funct_3:def</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be a subset of <fr:tex display="inline"><![CDATA[Y]]></fr:tex>. Then the <html:dfn>Inclusion</html:dfn> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> into <fr:tex display="inline"><![CDATA[Y]]></fr:tex> is the function <fr:tex display="inline"><![CDATA[i\colon  X\to  Y]]></fr:tex> defined by <fr:tex display="inline"><![CDATA[i(x)=x]]></fr:tex> for all <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0017/</fr:uri>
            <fr:display-uri>nst-0017</fr:display-uri>
            <fr:route>/nst-0017/</fr:route>
            <fr:title text="Identity function">Identity function</fr:title>
            <fr:taxon>example</fr:taxon>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/relat_1.html#K4" type="external">relat_1:def 10</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be a set. We define the <html:dfn>Identity Function</html:dfn> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> to be the function <fr:tex display="inline"><![CDATA[\mathop {\textrm {id}}\nolimits _{X}\colon  X\to  X]]></fr:tex> such that for all <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex>, <fr:tex display="inline"><![CDATA[\mathop {\textrm {id}}\nolimits _{X}(x)=x]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0018/</fr:uri>
            <fr:display-uri>nst-0018</fr:display-uri>
            <fr:route>/nst-0018/</fr:route>
            <fr:title text="Restriction of a function">Restriction of a function</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.8</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/relat_1.html#K5" type="external">relat_1:def 11</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[g\colon  Y\to  Z]]></fr:tex> be a function, let <fr:tex display="inline"><![CDATA[X\subseteq  Y]]></fr:tex>. We define the <html:dfn>Restriction</html:dfn> of <fr:tex display="inline"><![CDATA[g]]></fr:tex> to <fr:tex display="inline"><![CDATA[X]]></fr:tex> to be the function <fr:tex display="inline"><![CDATA[g|_{X}\colon  X\to  Z]]></fr:tex> such that for all <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex>, <fr:tex display="inline"><![CDATA[g|_{X}(x)=g(x)]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0019/</fr:uri>
            <fr:display-uri>nst-0019</fr:display-uri>
            <fr:route>/nst-0019/</fr:route>
            <fr:title text="Projection of Cartesian product">Projection of Cartesian product</fr:title>
            <fr:taxon>example</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.8</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets. We define the <html:dfn>Projection Functions</html:dfn> <fr:tex display="inline"><![CDATA[\pi _{1}\colon  X\times  Y\to  X]]></fr:tex> and <fr:tex display="inline"><![CDATA[\pi _{2}\colon  X\times  Y\to  Y]]></fr:tex> by <fr:tex display="inline"><![CDATA[\pi _{1}(x,y)=x]]></fr:tex> and <fr:tex display="inline"><![CDATA[\pi _{2}(x,y)=y]]></fr:tex> for all <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex display="inline"><![CDATA[y\in  Y]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>10</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001M/</fr:uri>
            <fr:display-uri>nst-001M</fr:display-uri>
            <fr:route>/nst-001M/</fr:route>
            <fr:title text="Composition of functions">Composition of functions</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> and <fr:tex display="inline"><![CDATA[g\colon  Y\to  Z]]></fr:tex> be functions. Then the <html:dfn>Composition</html:dfn> of <fr:tex display="inline"><![CDATA[f]]></fr:tex> followed by <fr:tex display="inline"><![CDATA[g]]></fr:tex> is the function <fr:tex display="inline"><![CDATA[g\circ  f\colon  X\to  Z]]></fr:tex> defined by <fr:tex display="inline"><![CDATA[(g\circ  f)(x)=g(f(x))]]></fr:tex> for all <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex>.</html:p>
            <html:p>Observe this is just the <fr:link href="/nst-0013/" title="Composing relations" uri="http://localhost:8000/nst-0013/" display-uri="nst-0013" type="local">Composing relations</fr:link>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001A/</fr:uri>
            <fr:display-uri>nst-001A</fr:display-uri>
            <fr:route>/nst-001A/</fr:route>
            <fr:title text="Composing functions is associative">Composing functions is associative</fr:title>
            <fr:taxon>theorem</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[f\colon  W\to  X]]></fr:tex>, <fr:tex display="inline"><![CDATA[g\colon  X\to  Y]]></fr:tex>, <fr:tex display="inline"><![CDATA[h\colon  Y\to  Z]]></fr:tex> be functions. Then <fr:tex display="inline"><![CDATA[h\circ (g\circ  f)=(h\circ  g)\circ  f]]></fr:tex>.</html:p>
            <html:p>This follows from <fr:link href="/nst-001B/" title="Composing relations is associative" uri="http://localhost:8000/nst-001B/" display-uri="nst-001B" type="local">composing relations is associative</fr:link>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001C/</fr:uri>
            <fr:display-uri>nst-001C</fr:display-uri>
            <fr:route>/nst-001C/</fr:route>
            <fr:title text="Preimage of a function">Preimage of a function</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.10</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function, let <fr:tex display="inline"><![CDATA[B\subseteq  Y]]></fr:tex>. We define the <html:dfn>Preimage</html:dfn> of <fr:tex display="inline"><![CDATA[B]]></fr:tex> under <fr:tex display="inline"><![CDATA[f]]></fr:tex> to be the set <fr:tex display="inline"><![CDATA[f^{-1}(A)=\{x\in  X\mid  f(x)\in  B\}]]></fr:tex>.</html:p>
            <html:p>This is sometimes denoted <fr:tex display="inline"><![CDATA[f^{*}(B)]]></fr:tex> to avoid confusing the preimage with the inverse function of <fr:tex display="inline"><![CDATA[f]]></fr:tex>. This allows us to interpret <fr:tex display="inline"><![CDATA[f^{*}\colon \mathcal {P}(Y)\to \mathcal {P}(X)]]></fr:tex> without ambiguity.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>8</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/ela-001B/</fr:uri>
            <fr:display-uri>ela-001B</fr:display-uri>
            <fr:route>/ela-001B/</fr:route>
            <fr:title text="Image of a function">Image of a function</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> and <fr:tex display="inline"><![CDATA[Y]]></fr:tex> be sets, let <fr:tex display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function. We define the <html:dfn>Image</html:dfn> (or <html:dfn>Range</html:dfn>) of <fr:tex display="inline"><![CDATA[f]]></fr:tex> to be the subset <fr:tex display="inline"><![CDATA[\mathop {\textrm {ran}}\nolimits (f)=f(X)=\{f(x)\in  Y\mid  x\in  X\}]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001D/</fr:uri>
            <fr:display-uri>nst-001D</fr:display-uri>
            <fr:route>/nst-001D/</fr:route>
            <fr:title text="Direct image of a function">Direct image of a function</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.10</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function. Let <fr:tex display="inline"><![CDATA[A\subseteq  X]]></fr:tex>. We define the <html:dfn>Direct Image</html:dfn> of <fr:tex display="inline"><![CDATA[A]]></fr:tex> under <fr:tex display="inline"><![CDATA[f]]></fr:tex> to be the set <fr:tex display="inline"><![CDATA[f(A)=\{f(x)\in  Y\mid  x\in  A\}]]></fr:tex>.</html:p>
            <html:p>We sometimes use the notation <fr:tex display="inline"><![CDATA[f_{*}(A)]]></fr:tex> for the direct image of <fr:tex display="inline"><![CDATA[A]]></fr:tex> under <fr:tex display="inline"><![CDATA[f]]></fr:tex>, so we can describe a function <fr:tex display="inline"><![CDATA[f_{*}\colon \mathcal {P}(X)\to \mathcal {P}(Y)]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001E/</fr:uri>
            <fr:display-uri>nst-001E</fr:display-uri>
            <fr:route>/nst-001E/</fr:route>
            <fr:title text="Properties of image and preimage of a function">Properties of image and preimage of a function</fr:title>
            <fr:taxon>theorem</fr:taxon>
            <fr:meta name="source"><fr:link href="/paul-r-halmos/" title="Paul R. Halmos" uri="http://localhost:8000/paul-r-halmos/" display-uri="paul-r-halmos" type="local">Paul R. Halmos</fr:link> <fr:link href="/halmos-1974-naive/" title="Naive Set Theory" uri="http://localhost:8000/halmos-1974-naive/" display-uri="halmos-1974-naive" type="local">Naive Set Theory</fr:link> Ch.10</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function, let <fr:tex display="inline"><![CDATA[A\subseteq  X]]></fr:tex>, and <fr:tex display="inline"><![CDATA[B\subseteq  Y]]></fr:tex>. Then the following all hold:</html:p>
            <html:ol><html:li><fr:tex display="inline"><![CDATA[f(f^{-1}(B))\subseteq  B]]></fr:tex></html:li>
<html:li><fr:tex display="inline"><![CDATA[A\subseteq  f^{-1}(f(A))]]></fr:tex></html:li></html:ol>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001J/</fr:uri>
            <fr:display-uri>nst-001J</fr:display-uri>
            <fr:route>/nst-001J/</fr:route>
            <fr:title text="Preimages preserve everything">Preimages preserve everything</fr:title>
            <fr:taxon>theorem</fr:taxon>
            <fr:meta name="source"><fr:link href="/nicolas-bourbaki/" title="Nicolas Bourbaki" uri="http://localhost:8000/nicolas-bourbaki/" display-uri="nicolas-bourbaki" type="local">Nicolas Bourbaki</fr:link> <fr:link href="/bourbaki-1968-theory/" title="Theory of Sets" uri="http://localhost:8000/bourbaki-1968-theory/" display-uri="bourbaki-1968-theory" type="local">Theory of Sets</fr:link> R §2.10</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function, let <fr:tex display="inline"><![CDATA[L\subseteq  Y]]></fr:tex> and <fr:tex display="inline"><![CDATA[R\subseteq  Y]]></fr:tex> be subsets. Then the following all hold:</html:p>
            <html:ol><html:li><fr:tex display="inline"><![CDATA[f^{-1}(L\cup  R)=f^{-1}(L)\cup  f^{-1}(R)]]></fr:tex></html:li>
<html:li><fr:tex display="inline"><![CDATA[f^{-1}(L\cap  R)=f^{-1}(L)\cap  f^{-1}(R)]]></fr:tex></html:li>
<html:li><fr:tex display="inline"><![CDATA[f^{-1}(L\setminus  R)=f^{-1}(L)\setminus  f^{-1}(R)]]></fr:tex></html:li></html:ol>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001K/</fr:uri>
            <fr:display-uri>nst-001K</fr:display-uri>
            <fr:route>/nst-001K/</fr:route>
            <fr:title text="Direct image preserves only union">Direct image preserves only union</fr:title>
            <fr:taxon>theorem</fr:taxon>
            <fr:meta name="source"><fr:link href="/nicolas-bourbaki/" title="Nicolas Bourbaki" uri="http://localhost:8000/nicolas-bourbaki/" display-uri="nicolas-bourbaki" type="local">Nicolas Bourbaki</fr:link> <fr:link href="/bourbaki-1968-theory/" title="Theory of Sets" uri="http://localhost:8000/bourbaki-1968-theory/" display-uri="bourbaki-1968-theory" type="local">Theory of Sets</fr:link> R§2.5</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function, let <fr:tex display="inline"><![CDATA[L\subseteq  X]]></fr:tex> and <fr:tex display="inline"><![CDATA[R\subseteq  X]]></fr:tex> be subsets. Then the following all hold:</html:p>
            <html:ol><html:li><fr:tex display="inline"><![CDATA[f(L\cup  R)=f(L)\cup  f(R)]]></fr:tex></html:li>
<html:li><fr:tex display="inline"><![CDATA[f(L\cap  R)\subseteq  f(L)\cap  f(R)]]></fr:tex></html:li>
<html:li><fr:tex display="inline"><![CDATA[f(L\setminus  R)\supseteq  f(L)\setminus  f(R)]]></fr:tex></html:li></html:ol>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>8</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/ela-001I/</fr:uri>
            <fr:display-uri>ela-001I</fr:display-uri>
            <fr:route>/ela-001I/</fr:route>
            <fr:title text="Surjective function">Surjective function</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function. We say <fr:tex display="inline"><![CDATA[f]]></fr:tex> is <html:dfn>Surjective</html:dfn> (or that it's a <html:em>surjection</html:em>) if for each <fr:tex display="inline"><![CDATA[y\in  Y]]></fr:tex> there is at least one <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> such that <fr:tex display="inline"><![CDATA[f(x)=y]]></fr:tex>.</html:p>
            <html:p>In other words, the <fr:link href="/ela-001B/" title="Image of a function" uri="http://localhost:8000/ela-001B/" display-uri="ela-001B" type="local">image</fr:link> of <fr:tex display="inline"><![CDATA[f]]></fr:tex> is the <fr:link href="/ela-001C/" title="Domain and codomain of a function" uri="http://localhost:8000/ela-001C/" display-uri="ela-001C" type="local">codomain</fr:link> of <fr:tex display="inline"><![CDATA[f]]></fr:tex>. Or more vividly, <fr:tex display="inline"><![CDATA[f]]></fr:tex> "covers" all of <fr:tex display="inline"><![CDATA[Y]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001H/</fr:uri>
            <fr:display-uri>nst-001H</fr:display-uri>
            <fr:route>/nst-001H/</fr:route>
            <fr:title text="Surjective functions have right inverse">Surjective functions have right inverse</fr:title>
            <fr:taxon>theorem</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be an <fr:link href="/ela-001I/" title="Surjective function" uri="http://localhost:8000/ela-001I/" display-uri="ela-001I" type="local">Surjective function</fr:link>. Then there exists a function <fr:tex display="inline"><![CDATA[g\colon  Y\to  X]]></fr:tex> such that <fr:tex display="inline"><![CDATA[f\circ  g=\mathop {\textrm {id}}\nolimits _{Y}]]></fr:tex>.</html:p>
            <html:p>We call such a <fr:tex display="inline"><![CDATA[g]]></fr:tex> a <html:dfn>Right Inverse</html:dfn> of <fr:tex display="inline"><![CDATA[f]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>8</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/ela-001J/</fr:uri>
            <fr:display-uri>ela-001J</fr:display-uri>
            <fr:route>/ela-001J/</fr:route>
            <fr:title text="Injective function">Injective function</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function. We say <fr:tex display="inline"><![CDATA[f]]></fr:tex> is <html:dfn>injective</html:dfn> (or that it's a <html:em>injection</html:em>) if for all <fr:tex display="inline"><![CDATA[x_{1},x_{2}\in  X]]></fr:tex> such that <fr:tex display="inline"><![CDATA[f(x_{1})=f(x_{2})]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x_{1}=x_{2}]]></fr:tex>.</html:p>
            <html:p>Equivalently, if <fr:tex display="inline"><![CDATA[f(x_{1})\neq  f(x_{2})]]></fr:tex>, then <fr:tex display="inline"><![CDATA[x_{1}\neq  x_{2}]]></fr:tex>.</html:p>
            <html:p>So no two distinct elements of <fr:tex display="inline"><![CDATA[X]]></fr:tex> are mapped to the same element under <fr:tex display="inline"><![CDATA[f]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001G/</fr:uri>
            <fr:display-uri>nst-001G</fr:display-uri>
            <fr:route>/nst-001G/</fr:route>
            <fr:title text="Injective functions have a left inverse function">Injective functions have a left inverse function</fr:title>
            <fr:taxon>theorem</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be an <fr:link href="/ela-001J/" title="Injective function" uri="http://localhost:8000/ela-001J/" display-uri="ela-001J" type="local">Injective function</fr:link>. Then there exists a function <fr:tex display="inline"><![CDATA[g\colon  Y\to  X]]></fr:tex> such that <fr:tex display="inline"><![CDATA[g\circ  f=\mathop {\textrm {id}}\nolimits _{X}]]></fr:tex>.</html:p>
            <html:p>We call such a <fr:tex display="inline"><![CDATA[g]]></fr:tex> a <html:dfn>Left Inverse</html:dfn> of <fr:tex display="inline"><![CDATA[f]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>8</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/ela-001K/</fr:uri>
            <fr:display-uri>ela-001K</fr:display-uri>
            <fr:route>/ela-001K/</fr:route>
            <fr:title text="Bijective function">Bijective function</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We say a function <fr:tex display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> is <html:dfn>Bijective</html:dfn> (or say <fr:tex display="inline"><![CDATA[f]]></fr:tex> is a <html:em>bijection</html:em>) if <fr:tex display="inline"><![CDATA[f]]></fr:tex> is both <fr:link href="/ela-001J/" title="Injective function" uri="http://localhost:8000/ela-001J/" display-uri="ela-001J" type="local">injective</fr:link> and <fr:link href="/ela-001I/" title="Surjective function" uri="http://localhost:8000/ela-001I/" display-uri="ela-001I" type="local">surjective</fr:link>.</html:p>
            <html:p>This means for each <fr:tex display="inline"><![CDATA[y\in  Y]]></fr:tex>, there exists a unique <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> such that <fr:tex display="inline"><![CDATA[f(x)=y]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>10</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001L/</fr:uri>
            <fr:display-uri>nst-001L</fr:display-uri>
            <fr:route>/nst-001L/</fr:route>
            <fr:title text="Inverse function">Inverse function</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be a function. We call a function <fr:tex display="inline"><![CDATA[g\colon  Y\to  X]]></fr:tex> the <html:dfn>Inverse</html:dfn> of <fr:tex display="inline"><![CDATA[f]]></fr:tex> if <fr:tex display="inline"><![CDATA[f\circ  g=\mathop {\textrm {id}}\nolimits _{Y}]]></fr:tex> and <fr:tex display="inline"><![CDATA[g\circ  f=\mathop {\textrm {id}}\nolimits _{X}]]></fr:tex>. When such a <fr:tex display="inline"><![CDATA[g]]></fr:tex> exists, we denote it by <fr:tex display="inline"><![CDATA[f^{-1}]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>9</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001I/</fr:uri>
            <fr:display-uri>nst-001I</fr:display-uri>
            <fr:route>/nst-001I/</fr:route>
            <fr:title text="Bijective functions have unique inverse">Bijective functions have unique inverse</fr:title>
            <fr:taxon>theorem</fr:taxon>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/funct_1.html#K2" type="external">funct_1:def 5</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[f\colon  X\to  Y]]></fr:tex> be an <fr:link href="/ela-001K/" title="Bijective function" uri="http://localhost:8000/ela-001K/" display-uri="ela-001K" type="local">Bijective function</fr:link>. Then there exists a function <fr:tex display="inline"><![CDATA[g\colon  Y\to  X]]></fr:tex> such that <fr:tex display="inline"><![CDATA[f\circ  g=\mathop {\textrm {id}}\nolimits _{Y}]]></fr:tex> and <fr:tex display="inline"><![CDATA[g\circ  f=\mathop {\textrm {id}}\nolimits _{X}]]></fr:tex>. Moreover this function <fr:tex display="inline"><![CDATA[g]]></fr:tex> is unique.</html:p>
            <html:p>We call such a <fr:tex display="inline"><![CDATA[g]]></fr:tex> the <html:dfn>Inverse</html:dfn> of <fr:tex display="inline"><![CDATA[f]]></fr:tex>, and we usually denote it by <fr:tex display="inline"><![CDATA[f^{-1}=g]]></fr:tex>.</html:p>
            <html:p>We see that if <fr:tex display="inline"><![CDATA[(x,y)\in  f]]></fr:tex>, then <fr:tex display="inline"><![CDATA[(y,x)\in  g]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-002D/</fr:uri>
            <fr:display-uri>nst-002D</fr:display-uri>
            <fr:route>/nst-002D/</fr:route>
            <fr:title text="Indexed family of sets">Indexed family of sets</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[I]]></fr:tex> be a set. A <html:dfn>Family of Sets Indexed by <fr:tex display="inline"><![CDATA[I]]></fr:tex></html:dfn> is a function-like set <fr:tex display="inline"><![CDATA[\mathcal {F}]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\mathop {\textrm {dom}}\nolimits (\mathcal {F})=I]]></fr:tex>.</html:p>
            <html:p>We usually write <fr:tex display="inline"><![CDATA[\mathcal {F}=\{F_{i}\}_{i\in  I}]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-002F/</fr:uri>
            <fr:display-uri>nst-002F</fr:display-uri>
            <fr:route>/nst-002F/</fr:route>
            <fr:title text="Unions and intersections of indexed families of sets">Unions and intersections of indexed families of sets</fr:title>
            <fr:taxon>remark</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We adopt the notation that, when <fr:tex display="inline"><![CDATA[I]]></fr:tex> is an indexing and <fr:tex display="inline"><![CDATA[\mathcal {F}=\{F_{i}\}_{i\in  I}]]></fr:tex> is an <fr:link href="/nst-002D/" title="Indexed family of sets" uri="http://localhost:8000/nst-002D/" display-uri="nst-002D" type="local">Indexed family of sets</fr:link>, we write
<fr:tex display="block"><![CDATA[\bigcup _{i\in  I}F_{i}:=\bigcup \mathcal {F}]]></fr:tex>
and
<fr:tex display="block"><![CDATA[\bigcap _{i\in  I}F_{i}:=\bigcap \mathcal {F}.]]></fr:tex>
When <fr:tex display="inline"><![CDATA[I=\mathbb {N}]]></fr:tex> we write
<fr:tex display="block"><![CDATA[\bigcup _{i=1}^{\infty }F_{i}:=\bigcup \mathcal {F}]]></fr:tex>
and
<fr:tex display="block"><![CDATA[\bigcap _{i=1}^{\infty }F_{i}:=\bigcap \mathcal {F}.]]></fr:tex>
Similarly, for finite unions ranging over specific indices in an ordered indexing set, we use the lower and upper limits to demarcate the range of the subfamily of sets.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>15</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-002E/</fr:uri>
            <fr:display-uri>nst-002E</fr:display-uri>
            <fr:route>/nst-002E/</fr:route>
            <fr:title text="Product of family of sets">Product of family of sets</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/card_3.html#K4" type="external">card_3:def 5</fr:link></fr:meta>
            <fr:meta name="source">
              <fr:link href="https://proofwiki.org/wiki/Definition:Cartesian_Product/Family_of_Sets" type="external">Proofwiki</fr:link>
            </fr:meta>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[I]]></fr:tex> be a set, let <fr:tex display="inline"><![CDATA[\mathcal {F}=\{F_{i}\}_{i\in  I}]]></fr:tex> be an <fr:link href="/nst-002D/" title="Indexed family of sets" uri="http://localhost:8000/nst-002D/" display-uri="nst-002D" type="local">Indexed family of sets</fr:link> indexed by <fr:tex display="inline"><![CDATA[I]]></fr:tex>. We define the <html:dfn>Product</html:dfn> of <fr:tex display="inline"><![CDATA[\{F_{i}\}_{i\in  I}]]></fr:tex> to be the set <fr:tex display="inline"><![CDATA[\prod \mathcal {F}=\prod _{i\in  I}F_{i}]]></fr:tex> such that for any object <fr:tex display="inline"><![CDATA[x]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[x\in \prod _{i\in  I}]]></fr:tex> if and only if <fr:tex display="inline"><![CDATA[x]]></fr:tex> if function-like and <fr:tex display="inline"><![CDATA[\mathop {\textrm {dom}}\nolimits (x)=\mathop {\textrm {dom}}\nolimits (\mathcal {F})]]></fr:tex> and for each <fr:tex display="inline"><![CDATA[i\in  I]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x_{i}\in  F_{i}]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>15</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><html:strong>Well-definedness:</html:strong> We should prove this is well-defined, but we see this is equivalent to:
<fr:tex display="block"><![CDATA[\prod _{i\in  I}F_{i}=\{x\in \mathop {\textrm {Hom}}\nolimits (I,\bigcup _{i\in  I}F_{i})\mid \forall  i\in  I\ldotp  x(i)\in  F_{i}\}.]]></fr:tex>
This is obvious a well-defined set using <fr:link href="/nst-0009/" title="Set builder notation" uri="http://localhost:8000/nst-0009/" display-uri="nst-0009" type="local">Set builder notation</fr:link>.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 

 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>15</fr:day></fr:date><fr:taxon>remark</fr:taxon></fr:frontmatter><fr:mainmatter>We see that when <fr:tex display="inline"><![CDATA[I=\{0,1\}]]></fr:tex>, this is bijective (but not equal) to <fr:tex display="inline"><![CDATA[F_{0}\times  F_{1}]]></fr:tex>.</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors>
          <fr:author>
            <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
          </fr:author>
        </fr:authors>
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>12</fr:month>
          <fr:day>11</fr:day>
        </fr:date>
        <fr:uri>http://localhost:8000/nst-001R/</fr:uri>
        <fr:display-uri>nst-001R</fr:display-uri>
        <fr:route>/nst-001R/</fr:route>
        <fr:title text="Cardinality and Ordinality">Cardinality and Ordinality</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001Q/</fr:uri>
            <fr:display-uri>nst-001Q</fr:display-uri>
            <fr:route>/nst-001Q/</fr:route>
            <fr:title text="Finite set">Finite set</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/baby-rudin/" title="Principles of Mathematical Analysis" uri="http://localhost:8000/baby-rudin/" display-uri="baby-rudin" type="local">Principles of Mathematical Analysis</fr:link>, Definition 2.4</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We call a set <fr:tex display="inline"><![CDATA[A]]></fr:tex> <html:dfn>Finite</html:dfn> if there exists a non-negative integer <fr:tex display="inline"><![CDATA[n\in \mathbb {N}_{0}]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\{k\in \mathbb {N}\mid  k\leq  n\}]]></fr:tex> is bijective with <fr:tex display="inline"><![CDATA[A]]></fr:tex>.</html:p>
            <html:p>Otherwise, we call <fr:tex display="inline"><![CDATA[A]]></fr:tex> <html:dfn>Infinite</html:dfn>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001S/</fr:uri>
            <fr:display-uri>nst-001S</fr:display-uri>
            <fr:route>/nst-001S/</fr:route>
            <fr:title text="Countable set">Countable set</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/baby-rudin/" title="Principles of Mathematical Analysis" uri="http://localhost:8000/baby-rudin/" display-uri="baby-rudin" type="local">Principles of Mathematical Analysis</fr:link>, Definition 2.4</fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/card_3.html#V4" type="external">card_3:def 14</fr:link></fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/card_3.html#V5" type="external">card_3:def 15</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We call a set <fr:tex display="inline"><![CDATA[A]]></fr:tex> <html:dfn>Countable</html:dfn> if there is an injective map <fr:tex display="inline"><![CDATA[A\to \mathbb {N}]]></fr:tex>.</html:p>
            <html:p>Otherwise we call <fr:tex display="inline"><![CDATA[A]]></fr:tex> <html:dfn>Uncountable</html:dfn>.</html:p>
            <html:p>When <fr:tex display="inline"><![CDATA[A]]></fr:tex> is infinite, <fr:tex display="inline"><![CDATA[A]]></fr:tex> is countable iff there is a bijection <fr:tex display="inline"><![CDATA[A\to \mathbb {N}]]></fr:tex> (or a bijection <fr:tex display="inline"><![CDATA[\mathbb {N}\to  A]]></fr:tex>). In this case, we will call <fr:tex display="inline"><![CDATA[A]]></fr:tex> <html:dfn>Countably Infinite</html:dfn> (or <html:dfn>Denumerable</html:dfn>).</html:p>
            <html:p><html:strong>Caution:</html:strong> some authors say <fr:tex display="inline"><![CDATA[A]]></fr:tex> is countable if there is an bijective function <fr:tex display="inline"><![CDATA[A\to \mathbb {N}]]></fr:tex>. This seems to be the case among analysts, but I don't think I could live with myself if I were to follow their example.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001T/</fr:uri>
            <fr:display-uri>nst-001T</fr:display-uri>
            <fr:route>/nst-001T/</fr:route>
            <fr:title text="Integers are countable">Integers are countable</fr:title>
            <fr:taxon>example</fr:taxon>
            <fr:meta name="source"><fr:link href="/baby-rudin/" title="Principles of Mathematical Analysis" uri="http://localhost:8000/baby-rudin/" display-uri="baby-rudin" type="local">Principles of Mathematical Analysis</fr:link>, Example 2.5</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The integers <fr:tex display="inline"><![CDATA[\mathbb {Z}]]></fr:tex> are countable. Consider <fr:tex display="inline"><![CDATA[f\colon \mathbb {N}_{0}\to \mathbb {Z}]]></fr:tex> such that
<fr:tex display="block"><![CDATA[f(n)=\begin {cases}(n+1)/2 & n\hbox { is odd}\\
-n/2 & n\hbox { is even}\end {cases}]]></fr:tex>
Then <fr:tex display="inline"><![CDATA[f]]></fr:tex> is a bijection.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001U/</fr:uri>
            <fr:display-uri>nst-001U</fr:display-uri>
            <fr:route>/nst-001U/</fr:route>
            <fr:title text="A set bijective with a countably infinite set is countably infinite">A set bijective with a countably infinite set is countably infinite</fr:title>
            <fr:taxon>theorem</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a set, let <fr:tex display="inline"><![CDATA[B]]></fr:tex> be a countably infinite set. Then <fr:tex display="inline"><![CDATA[A]]></fr:tex> is countably infinite iff there is a bijection <fr:tex display="inline"><![CDATA[f\colon  A\to  B]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[g\colon  B\to \mathbb {N}]]></fr:tex> be an injective function (since <fr:tex display="inline"><![CDATA[B]]></fr:tex> is countable). If <fr:tex display="inline"><![CDATA[f\colon  A\to  B]]></fr:tex> is bijective, then <fr:tex display="inline"><![CDATA[g\circ  f]]></fr:tex> is injective, hence <fr:tex display="inline"><![CDATA[A]]></fr:tex> is countable.</html:p>
<html:p>If <fr:tex display="inline"><![CDATA[A]]></fr:tex> is countably infinite, then there is a bijection <fr:tex display="inline"><![CDATA[g\colon  A\to \mathbb {N}]]></fr:tex>. We have <fr:tex display="inline"><![CDATA[h\colon  B\to \mathbb {N}]]></fr:tex> be bijective (since <fr:tex display="inline"><![CDATA[B]]></fr:tex> is countable). Then <fr:tex display="inline"><![CDATA[h^{-1}\circ  g\colon  A\to  B]]></fr:tex> is bijective.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001W/</fr:uri>
            <fr:display-uri>nst-001W</fr:display-uri>
            <fr:route>/nst-001W/</fr:route>
            <fr:title text="Sequence">Sequence</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/baby-rudin/" title="Principles of Mathematical Analysis" uri="http://localhost:8000/baby-rudin/" display-uri="baby-rudin" type="local">Principles of Mathematical Analysis</fr:link>, Definition 2.7</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a set. A <html:dfn>Sequence</html:dfn> of <fr:tex display="inline"><![CDATA[A]]></fr:tex> is a function <fr:tex display="inline"><![CDATA[f\colon \mathbb {N}\to  A]]></fr:tex>, where we usually write <fr:tex display="inline"><![CDATA[f_{n}]]></fr:tex> instead of <fr:tex display="inline"><![CDATA[f(n)]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001X/</fr:uri>
            <fr:display-uri>nst-001X</fr:display-uri>
            <fr:route>/nst-001X/</fr:route>
            <fr:title text="Enumerating elements of a set">Enumerating elements of a set</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source"><fr:link href="/baby-rudin/" title="Principles of Mathematical Analysis" uri="http://localhost:8000/baby-rudin/" display-uri="baby-rudin" type="local">Principles of Mathematical Analysis</fr:link>, Definition 2.7</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a countably infinite set. We <html:dfn>Enumerate</html:dfn> the elements of <fr:tex display="inline"><![CDATA[A]]></fr:tex> by producing an bijection <fr:tex display="inline"><![CDATA[\mathbb {N}\to  A]]></fr:tex> as a sequence.</html:p>
            <html:p>Conversely, if there is a sequence of <fr:tex display="inline"><![CDATA[A]]></fr:tex> which is bijective, then we call that sequence an <html:dfn>Enumeration</html:dfn> of <fr:tex display="inline"><![CDATA[A]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001V/</fr:uri>
            <fr:display-uri>nst-001V</fr:display-uri>
            <fr:route>/nst-001V/</fr:route>
            <fr:title text="Every infinite subset of a countably infinite set is countable">Every infinite subset of a countably infinite set is countable</fr:title>
            <fr:taxon>theorem</fr:taxon>
            <fr:meta name="source"><fr:link href="/baby-rudin/" title="Principles of Mathematical Analysis" uri="http://localhost:8000/baby-rudin/" display-uri="baby-rudin" type="local">Principles of Mathematical Analysis</fr:link>, Theorem 2.8</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a countably infinite set, let <fr:tex display="inline"><![CDATA[E\subseteq  A]]></fr:tex> be infinite. Then <fr:tex display="inline"><![CDATA[E]]></fr:tex> is countable.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Since <fr:tex display="inline"><![CDATA[A]]></fr:tex> is countably infinite, we can enumerate its elements as a sequence <fr:tex display="inline"><![CDATA[x_{n}]]></fr:tex>.</html:p>
<html:p>We can construct a sequence <fr:tex display="inline"><![CDATA[(n_{k})]]></fr:tex> of positive integers such that <fr:tex display="inline"><![CDATA[x_{n_{k}}\in  E]]></fr:tex>.</html:p>
<html:p>Then we have the sequence <fr:tex display="inline"><![CDATA[f(k)=x_{n_{k}}]]></fr:tex> which enumerates the elements of <fr:tex display="inline"><![CDATA[E]]></fr:tex>.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001Y/</fr:uri>
            <fr:display-uri>nst-001Y</fr:display-uri>
            <fr:route>/nst-001Y/</fr:route>
            <fr:title text="Cantor's diagonal argument">Cantor's diagonal argument</fr:title>
            <fr:taxon>theorem</fr:taxon>
            <fr:meta name="source"><fr:link href="/baby-rudin/" title="Principles of Mathematical Analysis" uri="http://localhost:8000/baby-rudin/" display-uri="baby-rudin" type="local">Principles of Mathematical Analysis</fr:link>, Theorem 2.12</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[E_{n}]]></fr:tex> be a countable collection of countably infinite sets. Then
<fr:tex display="block"><![CDATA[S=\bigcup ^{\infty }_{n=1}E_{n}]]></fr:tex>
is countably infinite.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>For each <fr:tex display="inline"><![CDATA[n\in \mathbb {N}]]></fr:tex>, let us form a sequence <fr:tex display="inline"><![CDATA[(x_{n,k})]]></fr:tex> of elements of <fr:tex display="inline"><![CDATA[E_{n}]]></fr:tex>. Then we arrange these sequences into an infinite table
<fr:tex display="block"><![CDATA[\begin {matrix}
x_{1,1} & x_{1,2} & x_{1,3} & x_{1,4} & \ldots \\
x_{2,1} & x_{2,2} & x_{2,3} & x_{2,4} & \ldots \\
x_{3,1} & x_{3,2} & x_{3,3} & x_{3,4} & \ldots \\
x_{4,1} & x_{4,2} & x_{4,3} & x_{4,4} & \ldots \\
\vdots  & \vdots  & \vdots  & \vdots  & \ddots 
\end {matrix}]]></fr:tex>
Then we form a sequence by ordering the table as <fr:tex display="inline"><![CDATA[x_{1,1}]]></fr:tex>, <fr:tex display="inline"><![CDATA[x_{2,1}]]></fr:tex>, <fr:tex display="inline"><![CDATA[x_{1,2}]]></fr:tex>, <fr:tex display="inline"><![CDATA[x_{3,1}]]></fr:tex>, <fr:tex display="inline"><![CDATA[x_{2,2}]]></fr:tex>, <fr:tex display="inline"><![CDATA[x_{1,3}]]></fr:tex>, <fr:tex display="inline"><![CDATA[x_{4,1}]]></fr:tex>, <fr:tex display="inline"><![CDATA[x_{3,2}]]></fr:tex>, <fr:tex display="inline"><![CDATA[x_{2,3}]]></fr:tex>, <fr:tex display="inline"><![CDATA[x_{1,4}]]></fr:tex>, …, where we remove duplicate entries as they are encountered. This gives us a countably infinite sequence of <fr:tex display="inline"><![CDATA[S]]></fr:tex>.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-001Z/</fr:uri>
            <fr:display-uri>nst-001Z</fr:display-uri>
            <fr:route>/nst-001Z/</fr:route>
            <fr:title text="\QQ  is countable"><fr:tex display="inline"><![CDATA[\QQ ]]></fr:tex> is countable</fr:title>
            <fr:taxon>theorem</fr:taxon>
            <fr:meta name="source"><fr:link href="/baby-rudin/" title="Principles of Mathematical Analysis" uri="http://localhost:8000/baby-rudin/" display-uri="baby-rudin" type="local">Principles of Mathematical Analysis</fr:link>, Corollary to Theorem 2.13</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter><html:p>The set of rational numbers is countably infinite.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>We form the countably infinite family <fr:tex display="inline"><![CDATA[E_{n}=\{z/n\in \mathbb {Q}\mid  z\in \mathbb {Z},\gcd (z,n)=1\}]]></fr:tex> where <fr:tex display="inline"><![CDATA[n\in \mathbb {N}]]></fr:tex> is a positive integer. Each member is bijective with the integers, which is countably infinite. Then
<fr:tex display="block"><![CDATA[S=\bigcup ^{\infty }_{n=1}E_{n}]]></fr:tex>
is countably infinite by <fr:link href="/nst-001Y/" title="Cantor's diagonal argument" uri="http://localhost:8000/nst-001Y/" display-uri="nst-001Y" type="local">Cantor's diagonal argument</fr:link>, and <fr:tex display="inline"><![CDATA[S]]></fr:tex> bijective to the set <fr:tex display="inline"><![CDATA[\mathbb {Q}]]></fr:tex>. Hence <fr:tex display="inline"><![CDATA[\mathbb {Q}]]></fr:tex> is countably infinite.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0020/</fr:uri>
            <fr:display-uri>nst-0020</fr:display-uri>
            <fr:route>/nst-0020/</fr:route>
            <fr:title text="Set of all sequences of \{0,1\} is uncountable">Set of all sequences of <fr:tex display="inline"><![CDATA[\{0,1\}]]></fr:tex> is uncountable</fr:title>
            <fr:taxon>theorem</fr:taxon>
            <fr:meta name="source"><fr:link href="/baby-rudin/" title="Principles of Mathematical Analysis" uri="http://localhost:8000/baby-rudin/" display-uri="baby-rudin" type="local">Principles of Mathematical Analysis</fr:link>, Theorem 2.14</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be the set of all sequences of <fr:tex display="inline"><![CDATA[\{0,1\}]]></fr:tex>. Then the set <fr:tex display="inline"><![CDATA[A]]></fr:tex> is uncountable.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[E]]></fr:tex> be any countable subset of <fr:tex display="inline"><![CDATA[A]]></fr:tex>. Let us enumerate the elements of <fr:tex display="inline"><![CDATA[E]]></fr:tex> into a sequence <fr:tex display="inline"><![CDATA[x_{n}]]></fr:tex>. We can construct the sequence <fr:tex display="inline"><![CDATA[x]]></fr:tex> as follows:
<fr:tex display="block"><![CDATA[x(n) = \begin {cases}1 & \hbox {if }x_{n}(n)=0\\
0 & \hbox {if }x_{n}(n)=1\end {cases}]]></fr:tex>
Then <fr:tex display="inline"><![CDATA[x(n)\neq  x_{n}(n)]]></fr:tex> for all <fr:tex display="inline"><![CDATA[n\in \mathbb {N}]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[x]]></fr:tex> differs from every element of <fr:tex display="inline"><![CDATA[E]]></fr:tex>, so <fr:tex display="inline"><![CDATA[x\in  A\setminus  E]]></fr:tex>.</html:p>
<html:p>This means every countably infinite subset of <fr:tex display="inline"><![CDATA[A]]></fr:tex> is a proper subset. This means <fr:tex display="inline"><![CDATA[A]]></fr:tex> must be uncountable since otherwise it would be a proper subset of itself, which is impossible.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 

 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:taxon>remark</fr:taxon></fr:frontmatter><fr:mainmatter>This implies <fr:tex display="inline"><![CDATA[\mathbb {R}]]></fr:tex> is uncountable since <fr:tex display="inline"><![CDATA[A]]></fr:tex> contains the binary expansion of all real numbers between 0 and 1.</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0021/</fr:uri>
            <fr:display-uri>nst-0021</fr:display-uri>
            <fr:route>/nst-0021/</fr:route>
            <fr:title text="Transitive set">Transitive set</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#V1" type="external">ordinal1:def 2</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be a set. We say <fr:tex display="inline"><![CDATA[X]]></fr:tex> is <html:dfn>Transitive</html:dfn> if for all sets <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\subseteq  X]]></fr:tex>. In other words, if <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex display="inline"><![CDATA[y\in  X]]></fr:tex>, then <fr:tex display="inline"><![CDATA[y\in  X]]></fr:tex>. So <fr:tex display="inline"><![CDATA[\in ]]></fr:tex> forms a transitive relation on <fr:tex display="inline"><![CDATA[X]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0022/</fr:uri>
            <fr:display-uri>nst-0022</fr:display-uri>
            <fr:route>/nst-0022/</fr:route>
            <fr:title text="Connected set">Connected set</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#V2" type="external">ordinal1:def 3</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be a set. We say <fr:tex display="inline"><![CDATA[X]]></fr:tex> is <html:dfn>Connected</html:dfn> if for all sets <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> and <fr:tex display="inline"><![CDATA[y\in  X]]></fr:tex>, if <fr:tex display="inline"><![CDATA[x\notin  y]]></fr:tex> and <fr:tex display="inline"><![CDATA[x\neq  y]]></fr:tex>, then <fr:tex display="inline"><![CDATA[y\in  x]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0023/</fr:uri>
            <fr:display-uri>nst-0023</fr:display-uri>
            <fr:route>/nst-0023/</fr:route>
            <fr:title text="Ordinal number">Ordinal number</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#V3" type="external">ordinal1:def 4</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We say a set <fr:tex display="inline"><![CDATA[X]]></fr:tex> is an <html:dfn>Ordinal</html:dfn> if <fr:tex display="inline"><![CDATA[X]]></fr:tex> is <fr:link href="/nst-0021/" title="Transitive set" uri="http://localhost:8000/nst-0021/" display-uri="nst-0021" type="local">Transitive set</fr:link> and also <fr:link href="/nst-0022/" title="Connected set" uri="http://localhost:8000/nst-0022/" display-uri="nst-0022" type="local">Connected set</fr:link>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0024/</fr:uri>
            <fr:display-uri>nst-0024</fr:display-uri>
            <fr:route>/nst-0024/</fr:route>
            <fr:title text="Successor">Successor</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#K1" type="external">ordinal1:def 1</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be a set. We define the <html:dfn>Successor</html:dfn> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> to be the set <fr:tex display="block"><![CDATA[\mathop {\textrm {S}}\nolimits (X):=X\cup \{X\}.]]></fr:tex></html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0025/</fr:uri>
            <fr:display-uri>nst-0025</fr:display-uri>
            <fr:route>/nst-0025/</fr:route>
            <fr:title text="Successor of ordinal is an ordinal">Successor of ordinal is an ordinal</fr:title>
            <fr:taxon>theorem</fr:taxon>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#T17" type="external">ordinal1:17</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be an <fr:link href="/nst-0023/" title="Ordinal number" uri="http://localhost:8000/nst-0023/" display-uri="nst-0023" type="local">Ordinal number</fr:link>. Then <fr:tex display="inline"><![CDATA[\mathop {\textrm {S}}\nolimits (X)]]></fr:tex> is an <fr:link href="/nst-0023/" title="Ordinal number" uri="http://localhost:8000/nst-0023/" display-uri="nst-0023" type="local">Ordinal number</fr:link>, too.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0026/</fr:uri>
            <fr:display-uri>nst-0026</fr:display-uri>
            <fr:route>/nst-0026/</fr:route>
            <fr:title text="Union of ordinal is an ordinal">Union of ordinal is an ordinal</fr:title>
            <fr:taxon>theorem</fr:taxon>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#T18" type="external">ordinal1:18</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be an <fr:link href="/nst-0023/" title="Ordinal number" uri="http://localhost:8000/nst-0023/" display-uri="nst-0023" type="local">Ordinal number</fr:link>. Then <fr:tex display="inline"><![CDATA[\bigcup  X]]></fr:tex> is an <fr:link href="/nst-0023/" title="Ordinal number" uri="http://localhost:8000/nst-0023/" display-uri="nst-0023" type="local">Ordinal number</fr:link>, too.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0027/</fr:uri>
            <fr:display-uri>nst-0027</fr:display-uri>
            <fr:route>/nst-0027/</fr:route>
            <fr:title text="Limit ordinal">Limit ordinal</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#V4" type="external">ordinal1:def 6</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be a set. We say <fr:tex display="inline"><![CDATA[A]]></fr:tex> is a <html:dfn>Limit Ordinal</html:dfn> if <fr:tex display="inline"><![CDATA[A=\bigcup  A]]></fr:tex>.</html:p>
            <html:p>Note: this means that <fr:tex display="inline"><![CDATA[\emptyset ]]></fr:tex> is a limit ordinal.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0028/</fr:uri>
            <fr:display-uri>nst-0028</fr:display-uri>
            <fr:route>/nst-0028/</fr:route>
            <fr:title text="Criteria for limit ordinal">Criteria for limit ordinal</fr:title>
            <fr:taxon>theorem</fr:taxon>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#T28" type="external">ordinal1:28</fr:link></fr:meta>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#T29" type="external">ordinal1:29</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be an ordinal number. Then the following are equivalent:</html:p>
            <html:ol><html:li><fr:tex display="inline"><![CDATA[A]]></fr:tex> is a <fr:link href="/nst-0027/" title="Limit ordinal" uri="http://localhost:8000/nst-0027/" display-uri="nst-0027" type="local">Limit ordinal</fr:link></html:li>
<html:li>for each ordinal <fr:tex display="inline"><![CDATA[C\in  A]]></fr:tex> we have <fr:tex display="inline"><![CDATA[\mathop {\textrm {S}}\nolimits (C)\in  A]]></fr:tex></html:li>
<html:li>there is no ordinal <fr:tex display="inline"><![CDATA[B]]></fr:tex> such that <fr:tex display="inline"><![CDATA[A=\mathop {\textrm {S}}\nolimits (B)]]></fr:tex></html:li></html:ol>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-0029/</fr:uri>
            <fr:display-uri>nst-0029</fr:display-uri>
            <fr:route>/nst-0029/</fr:route>
            <fr:title text="\omega  (the set of all finite ordinals)"><fr:tex display="inline"><![CDATA[\omega ]]></fr:tex> (the set of all finite ordinals)</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/ordinal1.html#K4" type="external">ordinal1:def 11</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>We define <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex> to be the ordinal such that:
<html:ol><html:li>contains zero: <fr:tex display="inline"><![CDATA[\emptyset \in \omega ]]></fr:tex>, and</html:li>
<html:li>limit: <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex> is a <fr:link href="/nst-0027/" title="Limit ordinal" uri="http://localhost:8000/nst-0027/" display-uri="nst-0027" type="local">Limit ordinal</fr:link></html:li>
<html:li>smallest such ordinal: for any other ordinal <fr:tex display="inline"><![CDATA[A]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\emptyset \in  A]]></fr:tex> and <fr:tex display="inline"><![CDATA[A]]></fr:tex> is a <fr:link href="/nst-0027/" title="Limit ordinal" uri="http://localhost:8000/nst-0027/" display-uri="nst-0027" type="local">Limit ordinal</fr:link>, we have <fr:tex display="inline"><![CDATA[\omega \subseteq  A]]></fr:tex>.</html:li></html:ol></html:p>
            <html:p>This is the set theoretic construction of the natural numbers, where <fr:tex display="inline"><![CDATA[0]]></fr:tex> is identified as <fr:tex display="inline"><![CDATA[\emptyset ]]></fr:tex>, and for any <fr:tex display="inline"><![CDATA[n\in \omega ]]></fr:tex> we identify <fr:tex display="inline"><![CDATA[n+1]]></fr:tex> with <fr:tex display="inline"><![CDATA[\mathop {\textrm {S}}\nolimits (n)]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-002C/</fr:uri>
            <fr:display-uri>nst-002C</fr:display-uri>
            <fr:route>/nst-002C/</fr:route>
            <fr:title text="There is no set of all ordinals">There is no set of all ordinals</fr:title>
            <fr:taxon>theorem</fr:taxon>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/card_1.html#T25" type="external">card_1:25</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter><html:p>There is no set <fr:tex display="inline"><![CDATA[X]]></fr:tex> such that for all ordinals <fr:tex display="inline"><![CDATA[A]]></fr:tex> we have <fr:tex display="inline"><![CDATA[A\in  X]]></fr:tex>. In other words, there is no set of all ordinal numbers.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:taxon>proof</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:link href="/nst-002J/" title="Proof by contradiction" uri="http://localhost:8000/nst-002J/" display-uri="nst-002J" type="local">Proof by contradiction</fr:link>. Assume for contradiction that <fr:tex display="inline"><![CDATA[X]]></fr:tex> is a set such that for all ordinals <fr:tex display="inline"><![CDATA[A]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[A\in  X]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[X]]></fr:tex> is <fr:link href="/nst-0021/" title="Transitive set" uri="http://localhost:8000/nst-0021/" display-uri="nst-0021" type="local">Transitive set</fr:link> and <fr:link href="/nst-0022/" title="Connected set" uri="http://localhost:8000/nst-0022/" display-uri="nst-0022" type="local">Connected set</fr:link>, which implies <fr:tex display="inline"><![CDATA[X]]></fr:tex> is an <fr:link href="/nst-0023/" title="Ordinal number" uri="http://localhost:8000/nst-0023/" display-uri="nst-0023" type="local">Ordinal number</fr:link>. Then <fr:tex display="inline"><![CDATA[X\in  X]]></fr:tex>, which is impossible.</html:p><html:span class="qed">∎</html:span></fr:mainmatter></fr:tree>
 

 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>11</fr:day></fr:date><fr:taxon>remark</fr:taxon></fr:frontmatter><fr:mainmatter>"The collection of all ordinal numbers" is another example of a <fr:link href="/nst-001P/" title="Classes" uri="http://localhost:8000/nst-001P/" display-uri="nst-001P" type="local">proper class</fr:link>.</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-002A/</fr:uri>
            <fr:display-uri>nst-002A</fr:display-uri>
            <fr:route>/nst-002A/</fr:route>
            <fr:title text="Cardinal number">Cardinal number</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/card_1.html#V1" type="external">card_1:def 1</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[A]]></fr:tex> be an <fr:link href="/nst-0023/" title="Ordinal number" uri="http://localhost:8000/nst-0023/" display-uri="nst-0023" type="local">Ordinal number</fr:link>. We say <fr:tex display="inline"><![CDATA[A]]></fr:tex> is a <html:dfn>Cardinal number</html:dfn> if for every ordinal <fr:tex display="inline"><![CDATA[B]]></fr:tex> such that <fr:tex display="inline"><![CDATA[A]]></fr:tex> is bijective to <fr:tex display="inline"><![CDATA[B]]></fr:tex> we have <fr:tex display="inline"><![CDATA[A\subseteq  B]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>11</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-002B/</fr:uri>
            <fr:display-uri>nst-002B</fr:display-uri>
            <fr:route>/nst-002B/</fr:route>
            <fr:title text="Cardinality of a set">Cardinality of a set</fr:title>
            <fr:taxon>definition</fr:taxon>
            <fr:meta name="source">MML <fr:link href="https://mizar.uwb.edu.pl/version/current/html/card_1.html#K1" type="external">card_1:def 2</fr:link></fr:meta>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be a set. We define the <html:dfn>Cardinality</html:dfn> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> to be the <fr:link href="/nst-002A/" title="Cardinal number" uri="http://localhost:8000/nst-002A/" display-uri="nst-002A" type="local">Cardinal number</fr:link> <fr:tex display="inline"><![CDATA[|X|]]></fr:tex> such that <fr:tex display="inline"><![CDATA[X]]></fr:tex> is equipotent with <fr:tex display="inline"><![CDATA[|X|]]></fr:tex>.</html:p>
            <html:p>So the cardinality of <fr:tex display="inline"><![CDATA[X]]></fr:tex> is the smallest <fr:link href="/nst-0023/" title="Ordinal number" uri="http://localhost:8000/nst-0023/" display-uri="nst-0023" type="local">Ordinal number</fr:link> bijective with <fr:tex display="inline"><![CDATA[X]]></fr:tex>.</html:p>
            <html:p>Usually, we only care if <fr:tex display="inline"><![CDATA[|X|]]></fr:tex> is finite or not.</html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false">
      <fr:frontmatter>
        <fr:authors>
          <fr:author>
            <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
          </fr:author>
        </fr:authors>
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>12</fr:month>
          <fr:day>18</fr:day>
        </fr:date>
        <fr:uri>http://localhost:8000/nst-002L/</fr:uri>
        <fr:display-uri>nst-002L</fr:display-uri>
        <fr:route>/nst-002L/</fr:route>
        <fr:title text="Choice">Choice</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <html:p>The axiom of choice appears in various forms in modern Mathematics. This section may be skipped and returned to when needed.</html:p>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>18</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-002M/</fr:uri>
            <fr:display-uri>nst-002M</fr:display-uri>
            <fr:route>/nst-002M/</fr:route>
            <fr:title text="Axiom of Choice">Axiom of Choice</fr:title>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[I]]></fr:tex> be an indexing set. Let <fr:tex display="inline"><![CDATA[\{S_{i}\}_{i\in  I}]]></fr:tex> be a family of nonempty sets indexed by <fr:tex display="inline"><![CDATA[I]]></fr:tex>. The axiom of choice asserts the existence of a <html:dfn>choice <fr:link href="/nst-0014/" title="Function" uri="http://localhost:8000/nst-0014/" display-uri="nst-0014" type="local">function</fr:link></html:dfn>, i.e., an indexed set <fr:tex display="inline"><![CDATA[(x_{i})_{i\in  I}]]></fr:tex> such that for each <fr:tex display="inline"><![CDATA[i\in  I]]></fr:tex> we see <fr:tex display="inline"><![CDATA[x_{i}\in  S_{i}]]></fr:tex>.</html:p><html:p>In other words, we can choose "some arbitrary" <fr:tex display="inline"><![CDATA[x_{i}]]></fr:tex> from <fr:tex display="inline"><![CDATA[S_{i}]]></fr:tex> for each <fr:tex display="inline"><![CDATA[i\in  I]]></fr:tex>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:taxon>remark</fr:taxon></fr:frontmatter><fr:mainmatter>We stress, the "choice function" is a set-theoretic <fr:link href="/nst-0014/" title="Function" uri="http://localhost:8000/nst-0014/" display-uri="nst-0014" type="local">function</fr:link>.</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>18</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-002P/</fr:uri>
            <fr:display-uri>nst-002P</fr:display-uri>
            <fr:route>/nst-002P/</fr:route>
            <fr:title text="Poset">Poset</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>A <html:dfn>Partially Ordered Set</html:dfn> (or <html:dfn>Poset</html:dfn>) is a set <fr:tex display="inline"><![CDATA[X]]></fr:tex> equipped with a <fr:link href="/nst-002O/" title="Partial Order" uri="http://localhost:8000/nst-002O/" display-uri="nst-002O" type="local">Partial Order</fr:link> <fr:tex display="inline"><![CDATA[\leq ]]></fr:tex> usually denoted as a pair <fr:tex display="inline"><![CDATA[(X,\leq )]]></fr:tex>.</html:p>
            <html:p>Note: not all elements are comparable in a poset, i.e., the trichotomy law (for all <fr:tex display="inline"><![CDATA[x,y\in  X]]></fr:tex> either <fr:tex display="inline"><![CDATA[x=y]]></fr:tex> or <fr:tex display="inline"><![CDATA[x\leq  y]]></fr:tex> or <fr:tex display="inline"><![CDATA[y\leq  x]]></fr:tex>) does not need to hold.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>18</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-002Q/</fr:uri>
            <fr:display-uri>nst-002Q</fr:display-uri>
            <fr:route>/nst-002Q/</fr:route>
            <fr:title text="Chain">Chain</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[(X,\leq )]]></fr:tex> be a nonempty <fr:link href="/nst-002P/" title="Poset" uri="http://localhost:8000/nst-002P/" display-uri="nst-002P" type="local">Poset</fr:link>. A <html:dfn>Chain</html:dfn> is a subset <fr:tex display="inline"><![CDATA[C\subseteq  X]]></fr:tex> such that for all <fr:tex display="inline"><![CDATA[x,y\in  C]]></fr:tex> either <fr:tex display="inline"><![CDATA[x\leq  y]]></fr:tex> or <fr:tex display="inline"><![CDATA[y\leq  x]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>18</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-002R/</fr:uri>
            <fr:display-uri>nst-002R</fr:display-uri>
            <fr:route>/nst-002R/</fr:route>
            <fr:title text="Upper bound">Upper bound</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[(X,\leq )]]></fr:tex> be a nonempty <fr:link href="/nst-002P/" title="Poset" uri="http://localhost:8000/nst-002P/" display-uri="nst-002P" type="local">Poset</fr:link>. Let <fr:tex display="inline"><![CDATA[A\subseteq  X]]></fr:tex> be some subset. An <html:dfn>Upper Bound</html:dfn> of <fr:tex display="inline"><![CDATA[A]]></fr:tex> is an element <fr:tex display="inline"><![CDATA[u\in  X]]></fr:tex> such that for all <fr:tex display="inline"><![CDATA[a\in  A]]></fr:tex> we have <fr:tex display="inline"><![CDATA[a\leq  u]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>18</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/nst-002S/</fr:uri>
            <fr:display-uri>nst-002S</fr:display-uri>
            <fr:route>/nst-002S/</fr:route>
            <fr:title text="Maximal element">Maximal element</fr:title>
            <fr:taxon>definition</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Let <fr:tex display="inline"><![CDATA[(X,\leq )]]></fr:tex> be a nonempty <fr:link href="/nst-002P/" title="Poset" uri="http://localhost:8000/nst-002P/" display-uri="nst-002P" type="local">Poset</fr:link>. A <html:dfn>Maximal Element</html:dfn> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> is an element <fr:tex display="inline"><![CDATA[m\in  X]]></fr:tex> such that for all <fr:tex display="inline"><![CDATA[x\in  X]]></fr:tex> we have <fr:tex display="inline"><![CDATA[x\leq  m]]></fr:tex>.</html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>12</fr:month>
              <fr:day>18</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/zorn's-lemma/</fr:uri>
            <fr:display-uri>zorn's-lemma</fr:display-uri>
            <fr:route>/zorn's-lemma/</fr:route>
            <fr:title text="Zorn's lemma">Zorn's lemma</fr:title>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[(X,\leq )]]></fr:tex> be a nonempty <fr:link href="/nst-002P/" title="Poset" uri="http://localhost:8000/nst-002P/" display-uri="nst-002P" type="local">Poset</fr:link>. If every <fr:link href="/nst-002Q/" title="Chain" uri="http://localhost:8000/nst-002Q/" display-uri="nst-002Q" type="local">chain</fr:link> of <fr:tex display="inline"><![CDATA[X]]></fr:tex> has an <fr:link href="/nst-002R/" title="Upper bound" uri="http://localhost:8000/nst-002R/" display-uri="nst-002R" type="local">upper bound</fr:link>, then <fr:tex display="inline"><![CDATA[X]]></fr:tex> has a <fr:link href="/nst-002S/" title="Maximal element" uri="http://localhost:8000/nst-002S/" display-uri="nst-002S" type="local">Maximal element</fr:link>.</html:p>
 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>12</fr:month><fr:day>18</fr:day></fr:date><fr:taxon>remark</fr:taxon></fr:frontmatter><fr:mainmatter>This is logically equivalent to the <fr:link href="/nst-002M/" title="Axiom of Choice" uri="http://localhost:8000/nst-002M/" display-uri="nst-002M" type="local">Axiom of Choice</fr:link>.</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/alex-nelson/" title="Alex Nelson" uri="http://localhost:8000/alex-nelson/" display-uri="alex-nelson" type="local">Alex Nelson</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>5</fr:month>
              <fr:day>12</fr:day>
            </fr:date>
            <fr:uri>http://localhost:8000/index/</fr:uri>
            <fr:display-uri>index</fr:display-uri>
            <fr:route>/index/</fr:route>
            <fr:title text="Forests of Mathematics">Forests of Mathematics</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>This roughly corresponds to my "mental model" of Mathematics as I have learned it. For more rambling about this, see the <fr:link href="/preface/" title="Preface" uri="http://localhost:8000/preface/" display-uri="preface" type="local">Preface</fr:link>.</html:p>
            <html:ol><html:li><fr:link href="/preface/" title="Preface" uri="http://localhost:8000/preface/" display-uri="preface" type="local">Preface</fr:link></html:li>
<html:li><fr:link href="/ela/" title="Elementary linear algebra" uri="http://localhost:8000/ela/" display-uri="ela" type="local">Elementary linear algebra</fr:link></html:li> <html:li><fr:link href="/nst/" title="Naive set theory" uri="http://localhost:8000/nst/" display-uri="nst" type="local">Naive set theory</fr:link></html:li> <html:li><fr:link href="/ila/" title="Intermediate linear algebra" uri="http://localhost:8000/ila/" display-uri="ila" type="local">Intermediate linear algebra</fr:link></html:li> <html:li><fr:link href="/ca/" title="Classical Analysis" uri="http://localhost:8000/ca/" display-uri="ca" type="local">Classical Analysis</fr:link></html:li>  <html:li><fr:link href="/iaa/" title="Introduction to Abstract Algebra" uri="http://localhost:8000/iaa/" display-uri="iaa" type="local">Introduction to Abstract Algebra</fr:link></html:li> <html:li><fr:link href="/ac/" title="Commutative Algebra" uri="http://localhost:8000/ac/" display-uri="ac" type="local">Commutative Algebra</fr:link></html:li>  <html:li><fr:link href="/sl/" title="Special linear group" uri="http://localhost:8000/sl/" display-uri="sl" type="local">Special linear group</fr:link></html:li>
<html:li><fr:link href="/jordan/" title="Jordan algebras" uri="http://localhost:8000/jordan/" display-uri="jordan" type="local">Jordan algebras</fr:link></html:li></html:ol>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
